diff -Napur a/CMakeLists.txt f/CMakeLists.txt
diff -Napur a/ChangeLog f/ChangeLog
diff -Napur a/OSX-package/inputs/Info.plist f/OSX-package/inputs/Info.plist
diff -Napur a/OSX-package/inputs/Scribus.pkg-Info.plist f/OSX-package/inputs/Scribus.pkg-Info.plist
diff -Napur a/Scribus.app/Contents/Info.plist f/Scribus.app/Contents/Info.plist
diff -Napur a/config.h.cmake f/config.h.cmake
diff -Napur a/resources/translations/CMakeLists.txt f/resources/translations/CMakeLists.txt
diff -Napur a/resources/translations/scribus.af.ts f/resources/translations/scribus.af.ts
diff -Napur a/resources/translations/scribus.ar.ts f/resources/translations/scribus.ar.ts
diff -Napur a/resources/translations/scribus.az.ts f/resources/translations/scribus.az.ts
diff -Napur a/resources/translations/scribus.be.ts f/resources/translations/scribus.be.ts
diff -Napur a/resources/translations/scribus.bg.ts f/resources/translations/scribus.bg.ts
diff -Napur a/resources/translations/scribus.bn_IN.ts f/resources/translations/scribus.bn_IN.ts
diff -Napur a/resources/translations/scribus.br.ts f/resources/translations/scribus.br.ts
diff -Napur a/resources/translations/scribus.ca.ts f/resources/translations/scribus.ca.ts
diff -Napur a/resources/translations/scribus.cs_CZ.ts f/resources/translations/scribus.cs_CZ.ts
diff -Napur a/resources/translations/scribus.cy.ts f/resources/translations/scribus.cy.ts
diff -Napur a/resources/translations/scribus.da_DK.ts f/resources/translations/scribus.da_DK.ts
diff -Napur a/resources/translations/scribus.de.ts f/resources/translations/scribus.de.ts
diff -Napur a/resources/translations/scribus.de_1901.ts f/resources/translations/scribus.de_1901.ts
diff -Napur a/resources/translations/scribus.de_CH.ts f/resources/translations/scribus.de_CH.ts
diff -Napur a/resources/translations/scribus.el.ts f/resources/translations/scribus.el.ts
diff -Napur a/resources/translations/scribus.en_AU.ts f/resources/translations/scribus.en_AU.ts
diff -Napur a/resources/translations/scribus.en_GB.ts f/resources/translations/scribus.en_GB.ts
diff -Napur a/resources/translations/scribus.en_US.ts f/resources/translations/scribus.en_US.ts
diff -Napur a/resources/translations/scribus.eo.ts f/resources/translations/scribus.eo.ts
diff -Napur a/resources/translations/scribus.es_AR.ts f/resources/translations/scribus.es_AR.ts
diff -Napur a/resources/translations/scribus.es_ES.ts f/resources/translations/scribus.es_ES.ts
diff -Napur a/resources/translations/scribus.et.ts f/resources/translations/scribus.et.ts
diff -Napur a/resources/translations/scribus.eu.ts f/resources/translations/scribus.eu.ts
diff -Napur a/resources/translations/scribus.fa_IR.ts f/resources/translations/scribus.fa_IR.ts
diff -Napur a/resources/translations/scribus.fi.ts f/resources/translations/scribus.fi.ts
diff -Napur a/resources/translations/scribus.fr.ts f/resources/translations/scribus.fr.ts
diff -Napur a/resources/translations/scribus.gl.ts f/resources/translations/scribus.gl.ts
diff -Napur a/resources/translations/scribus.he_IL.ts f/resources/translations/scribus.he_IL.ts
diff -Napur a/resources/translations/scribus.hi_IN.ts f/resources/translations/scribus.hi_IN.ts
diff -Napur a/resources/translations/scribus.hr_HR.ts f/resources/translations/scribus.hr_HR.ts
diff -Napur a/resources/translations/scribus.hu.ts f/resources/translations/scribus.hu.ts
diff -Napur a/resources/translations/scribus.id.ts f/resources/translations/scribus.id.ts
diff -Napur a/resources/translations/scribus.it.ts f/resources/translations/scribus.it.ts
diff -Napur a/resources/translations/scribus.ja.ts f/resources/translations/scribus.ja.ts
diff -Napur a/resources/translations/scribus.kab.ts f/resources/translations/scribus.kab.ts
diff -Napur a/resources/translations/scribus.kn_IN.ts f/resources/translations/scribus.kn_IN.ts
diff -Napur a/resources/translations/scribus.ko.ts f/resources/translations/scribus.ko.ts
diff -Napur a/resources/translations/scribus.lb.ts f/resources/translations/scribus.lb.ts
diff -Napur a/resources/translations/scribus.lt_LT.ts f/resources/translations/scribus.lt_LT.ts
diff -Napur a/resources/translations/scribus.ml.ts f/resources/translations/scribus.ml.ts
diff -Napur a/resources/translations/scribus.mn_MN.ts f/resources/translations/scribus.mn_MN.ts
diff -Napur a/resources/translations/scribus.ms_MY.ts f/resources/translations/scribus.ms_MY.ts
diff -Napur a/resources/translations/scribus.nb_NO.ts f/resources/translations/scribus.nb_NO.ts
diff -Napur a/resources/translations/scribus.nl.ts f/resources/translations/scribus.nl.ts
diff -Napur a/resources/translations/scribus.nn_NO.ts f/resources/translations/scribus.nn_NO.ts
diff -Napur a/resources/translations/scribus.oc.ts f/resources/translations/scribus.oc.ts
diff -Napur a/resources/translations/scribus.pl_PL.ts f/resources/translations/scribus.pl_PL.ts
diff -Napur a/resources/translations/scribus.pms.ts f/resources/translations/scribus.pms.ts
diff -Napur a/resources/translations/scribus.pt_BR.ts f/resources/translations/scribus.pt_BR.ts
diff -Napur a/resources/translations/scribus.pt_PT.ts f/resources/translations/scribus.pt_PT.ts
diff -Napur a/resources/translations/scribus.ro.ts f/resources/translations/scribus.ro.ts
diff -Napur a/resources/translations/scribus.ru.ts f/resources/translations/scribus.ru.ts
diff -Napur a/resources/translations/scribus.sa.ts f/resources/translations/scribus.sa.ts
diff -Napur a/resources/translations/scribus.si.ts f/resources/translations/scribus.si.ts
diff -Napur a/resources/translations/scribus.sk_SK.ts f/resources/translations/scribus.sk_SK.ts
diff -Napur a/resources/translations/scribus.sl.ts f/resources/translations/scribus.sl.ts
diff -Napur a/resources/translations/scribus.so.ts f/resources/translations/scribus.so.ts
diff -Napur a/resources/translations/scribus.sq.ts f/resources/translations/scribus.sq.ts
diff -Napur a/resources/translations/scribus.sr.ts f/resources/translations/scribus.sr.ts
diff -Napur a/resources/translations/scribus.sv.ts f/resources/translations/scribus.sv.ts
diff -Napur a/resources/translations/scribus.ta.ts f/resources/translations/scribus.ta.ts
diff -Napur a/resources/translations/scribus.te.ts f/resources/translations/scribus.te.ts
diff -Napur a/resources/translations/scribus.th_TH.ts f/resources/translations/scribus.th_TH.ts
diff -Napur a/resources/translations/scribus.tr.ts f/resources/translations/scribus.tr.ts
diff -Napur a/resources/translations/scribus.uk.ts f/resources/translations/scribus.uk.ts
diff -Napur a/resources/translations/scribus.untranslated.ts f/resources/translations/scribus.untranslated.ts
diff -Napur a/resources/translations/scribus.zh_CN.ts f/resources/translations/scribus.zh_CN.ts
diff -Napur a/resources/translations/scribus.zh_TW.ts f/resources/translations/scribus.zh_TW.ts
diff -Napur a/scribus/canvas.cpp f/scribus/canvas.cpp
--- a/scribus/canvas.cpp	2025-01-08 21:31:39.000000000 +0100
+++ f/scribus/canvas.cpp	2025-02-07 13:56:48.393894086 +0100
@@ -1,1411 +1,1410 @@
-/*
- For general Scribus (>=1.3.2) copyright and licensing information please refer
- to the COPYING file provided with the program. Following this notice may exist
- a copyright and/or license notice that predates the release of Scribus 1.3.2
- for which a new license (GPL+exception) is in place.
- */
-/***************************************************************************
-*                                                                         *
-*   This program is free software; you can redistribute it and/or modify  *
-*   it under the terms of the GNU General Public License as published by  *
-*   the Free Software Foundation; either version 2 of the License, or     *
-*   (at your option) any later version.                                   *
-*                                                                         *
-***************************************************************************/
-
-#if defined(_MSC_VER) && !defined(_USE_MATH_DEFINES)
-#define _USE_MATH_DEFINES
-#endif
-#include <cmath>
-
-// #include <QDebug>
-#include <QToolTip>
-#include <QWidget>
-
-#include "appmodes.h"
-#include "canvas.h"
-#include "canvasmode.h"
-#include "pageitem_textframe.h"
-#include "pageitem_group.h"
-#include "pageitemiterator.h"
-#include "prefsmanager.h"
-#include "scpage.h"
-#include "scpainter.h"
-#include "scribusdoc.h"
-#include "scribusview.h"
-#include "selection.h"
-#include "ui/hruler.h"
-#include "ui/vruler.h"
-#include "util.h"
-#include "util_math.h"
-#include "units.h"
-
-#define DRAW_DEBUG_LINES 0
-
-static QPoint contentsToViewport(QPoint p)
-{
-	return p;
-}
-
-QDataStream &operator<< ( QDataStream & ds, const CanvasViewMode & vm )
-{
-	ds << vm.scale
-	<< vm.previewMode
-	<< vm.viewAsPreview
-	<< vm.previewVisual
-	<< vm.m_MouseButtonPressed
-	<< vm.operItemMoving
-	<< vm.operItemResizing
-	<< vm.operItemSelecting
-	<< vm.redrawPolygon
-	<< vm.linkedFramesToShow
-	<< vm.drawSelectedItemsWithControls
-	<< vm.drawFramelinksWithContents
-	<< vm.forceRedraw;
-	return ds;
-}
-
-QDataStream &operator>> ( QDataStream & ds, CanvasViewMode & vm )
-{
-	ds >> vm.scale
-	>> vm.previewMode
-	>> vm.viewAsPreview
-	>> vm.previewVisual
-	>> vm.m_MouseButtonPressed
-	>> vm.operItemMoving
-	>> vm.operItemResizing
-	>> vm.operItemSelecting
-	>> vm.redrawPolygon
-	>> vm.linkedFramesToShow
-	>> vm.drawSelectedItemsWithControls
-	>> vm.drawFramelinksWithContents
-	>> vm.forceRedraw;
-	return ds;
-}
-	
-
-Canvas::Canvas(ScribusDoc* doc, ScribusView* parent) : QWidget(parent), m_doc(doc), m_view(parent)
-{
-	setAutoFillBackground(true);
-	setAttribute(Qt::WA_OpaquePaintEvent, true);
-	setAttribute(Qt::WA_NoSystemBackground, true);
-	m_buffer = QPixmap();
-	m_bufferRect = QRect();
-	m_renderMode = RENDER_NORMAL;
-}
-
-void Canvas::setPreviewVisual(int mode)
-{
-	m_viewMode.previewVisual = qMax(0, mode);
-	m_viewMode.viewAsPreview = (mode >= 0);
-}
-// ______________________________
-// Coordinate Conversion Routines:
-
-
-FPoint Canvas::localToCanvas(QPoint p) const
-{
-
-/* Allow the user to select the exact coordinate represented by a ruler mark
-   when the mouse is lined up with the ruler, rather than returning the 
-   coordinate represented by the mathematical centre of the pixel which
-   may not be exactly the same as the coordinate represented by the ruler.
-*/
-
-// (xmin, xmax) = canvas top-left
-	double xmin = m_doc->minCanvasCoordinate.x();
-	double ymin = m_doc->minCanvasCoordinate.y();
-
-// (xoff, yoff) = ruler origin relative to canvas top-left
-	double xoff = m_doc->rulerXoffset - xmin;
-	double yoff = m_doc->rulerYoffset - ymin;
-	if (m_doc->guidesPrefs().rulerMode) {
-		xoff += m_doc->currentPage()->xOffset();
-		yoff += m_doc->currentPage()->yOffset();
-	}
-// (xsp, ysp) = spacing of ruler divisions
-	double xsp = m_doc->view()->horizRuler->ruleSpacing();
-	double ysp = m_doc->view()->vertRuler->ruleSpacing();
-
-	double sc = m_viewMode.scale;
-
-// number of ruler divisions from ruler origin to ruler mark closest to the
-// selected mouse coordinate
-	double xn = qRound((p.x()/sc - xoff)/xsp);
-	double yn = qRound((p.y()/sc - yoff)/ysp);
-
-// xn*xsp + xoff, yn*ysp + yoff = distance in canvas coordinates
-// from canvas top-left to ruler mark closest to selected mouse coordinate
-
-// If these round to the selected mouse coordinate, use these to define
-// (x,y), the coordinates of the desired point relative to the canvas top-left.
-// Otherwise, simply scale the mouse coordinates.
-	double x = ( qRound(sc*(xn*xsp + xoff)) == p.x() ? 
-	             xn * xsp + xoff : p.x() / sc );
-	double y = ( qRound(sc*(yn*ysp + yoff)) == p.y() ? 
-	             yn * ysp + yoff : p.y() / sc );
-		
-// Finally, add xmin,ymin to get the absolute canvas coordinates of the
-// desired point.
-	return FPoint(x + xmin, y + ymin);
-}
-
-QPoint Canvas::canvasToLocal(const FPoint& p) const
-{
-	return { qRound((p.x() - m_doc->minCanvasCoordinate.x()) * m_viewMode.scale),
-	         qRound((p.y() - m_doc->minCanvasCoordinate.y()) * m_viewMode.scale) };
-}
-
-QPoint Canvas::canvasToLocal(QPointF p) const
-{
-	return { qRound((p.x() - m_doc->minCanvasCoordinate.x()) * m_viewMode.scale),
-	         qRound((p.y() - m_doc->minCanvasCoordinate.y()) * m_viewMode.scale) };
-}
-
-QRect Canvas::canvasToLocal(const QRectF& p) const
-{
-	return { qRound((p.x() - m_doc->minCanvasCoordinate.x()) * m_viewMode.scale),
-	         qRound((p.y() - m_doc->minCanvasCoordinate.y()) * m_viewMode.scale),
-	         qRound(p.width() * m_viewMode.scale),
-	         qRound(p.height() * m_viewMode.scale) };
-}
-
-QRectF Canvas::canvasToLocalF(const QRectF& p) const
-{
-	return { (p.x() - m_doc->minCanvasCoordinate.x()) * m_viewMode.scale,
-	         (p.y() - m_doc->minCanvasCoordinate.y()) * m_viewMode.scale,
-	         p.width() * m_viewMode.scale,
-	         p.height() * m_viewMode.scale };
-}
-
-QPoint Canvas::canvasToGlobal(const FPoint& p) const
-{
-	return mapToParent(QPoint(0,0)) + parentWidget()->mapToGlobal(QPoint(0, 0)) + canvasToLocal(p);
-}
-
-QPoint Canvas::canvasToGlobal(QPointF p) const
-{
-	return mapToParent(QPoint(0,0)) + parentWidget()->mapToGlobal(QPoint(0, 0)) + canvasToLocal(p);
-}
-
-QRect Canvas::canvasToGlobal(const QRectF& p) const
-{
-	return { mapToParent(QPoint(0,0) + canvasToLocal(p.topLeft())) + parentWidget()->mapToGlobal(QPoint(0, 0)),
-	         QSize(qRound(p.width() * m_viewMode.scale), qRound(p.height() * m_viewMode.scale)) };
-}
-
-FPoint Canvas::globalToCanvas(QPoint p) const
-{
-	return localToCanvas(p - (mapToParent(QPoint(0, 0)) + parentWidget()->mapToGlobal(QPoint(0, 0))));
-}
-
-QRectF Canvas::globalToCanvas(QRect p) const
-{
-	FPoint org = globalToCanvas(p.topLeft());
-	return { org.x(), org.y(), p.width() / m_viewMode.scale, p.height() / m_viewMode.scale };
-}
-
-// ________________________
-// Tests for Finding Things:
-
-bool Canvas::hitsCanvasPoint(QPoint globalPoint, const FPoint& canvasPoint) const
-{
-	QPoint localPoint1 = globalPoint - (mapToParent(QPoint(0,0)) + parentWidget()->mapToGlobal(QPoint(0, 0)));
-	QPoint localPoint2 = canvasToLocal(canvasPoint);
-	int radius = m_doc->guidesPrefs().grabRadius;
-	return qAbs(localPoint1.x() - localPoint2.x()) < radius && qAbs(localPoint1.y() - localPoint2.y()) < radius;
-}
-
-
-bool Canvas::hitsCanvasPoint(QPoint globalPoint, QPointF canvasPoint) const
-{
-	QPoint localPoint1 = globalPoint - (mapToParent(QPoint(0,0)) + parentWidget()->mapToGlobal(QPoint(0, 0)));
-	QPoint localPoint2 = canvasToLocal(canvasPoint);
-	int radius = m_doc->guidesPrefs().grabRadius;
-	return qAbs(localPoint1.x() - localPoint2.x()) < radius && qAbs(localPoint1.y() - localPoint2.y()) < radius;
-}
-
-bool Canvas::hitsCanvasPoint(const FPoint& globalPoint, const QPointF& canvasPoint) const
-{
-	double radius = m_doc->guidesPrefs().grabRadius;
-	return qAbs(globalPoint.x() - canvasPoint.x()) < radius && qAbs(globalPoint.y() - canvasPoint.y()) < radius;
-}
-
-QRect Canvas::exposedRect() const
-{
-	int ex( -(x() / m_viewMode.scale) + m_doc->minCanvasCoordinate.x());
-	int ey( -(y() / m_viewMode.scale) + m_doc->minCanvasCoordinate.y());
-	int ew( (m_view->visibleWidth() * 1.2) / m_viewMode.scale);
-	int eh( (m_view->visibleHeight() * 1.2) / m_viewMode.scale);
-	
-	return { ex, ey, ew, eh };
-}
-
-
-/// Little helper to calculate |p|^2
-
-static double length2(const QPointF& p)
-{
-	return p.x()*p.x() + p.y()*p.y();
-}
-
-
-
-/*!
-  returns -1 if canvasPoint is outside the frame + grabradius.
-  returns frameHandle if canvasPoint is near a framehandle
-  otherwise 0
- */
-Canvas::FrameHandle Canvas::frameHitTest(QPointF canvasPoint, PageItem* item) const
-{
-	// As item->getTransform() will translate to Pos, we need to adjust the rect passed
-	// to frameHitTest in order to take line width, which in very *creative* design can
-	// be huge, into account.
-	// ### might be interesting to investigate if it would be painless to just change 
-	// PageItem::getTransform.
-	double extraS = - item->visualLineWidth() / 2.0;
-//	if (item->lineColor() != CommonStrings::None)
-//		extraS = (item->lineWidth() / -2.0);
-	if (item->isTextFrame() && (m_doc->appMode == modeEdit) && !item->asTextFrame()->availableRegion().contains(item->getTransform().inverted().map(canvasPoint.toPoint())))
-		return OUTSIDE;
-	QRectF visualRect = item->isLine() ? QRectF(0, extraS, item->visualWidth(), item->visualHeight()) 
-		                               : QRectF(extraS, extraS, item->visualWidth(), item->visualHeight());
-	Canvas::FrameHandle result = frameHitTest(item->getTransform().inverted().map(canvasPoint), visualRect);
-//	qDebug() << "frameHitTest for item" << item->ItemNr 
-//		<< item->getTransform().inverted().map(canvasPoint) 
-//		<< item->getTransform().inverted() 
-//		<< QRectF(0, 0, item->width(), item->height());
-	return result;
-}
-
-Canvas::FrameHandle Canvas::frameHitTest(QPointF canvasPoint, const QRectF& frame) const
-{
-	FrameHandle result = INSIDE;
-	const double radius = m_doc->guidesPrefs().grabRadius / m_viewMode.scale;
-	const double radius2 = radius * radius;
-	double resultDistance = radius2 * 10.0; // far off
-	
-	const double frameWidth = frame.width();
-	const double frameHeight = frame.height();
-	const QPointF frameOrigin = frame.topLeft();
-	
-	if (canvasPoint.x() < frameOrigin.x() - radius ||
-		canvasPoint.x() > frameOrigin.x() + frameWidth + radius ||
-		canvasPoint.y() < frameOrigin.y() - radius ||
-		canvasPoint.y() > frameOrigin.y() + frameHeight + radius)
-	{
-//		qDebug() << "framehittest" << canvasPoint << frame << "-> OUTSIDE";
-		return OUTSIDE;
-	}
-	
-	QPointF framePoint = frameOrigin;
-	double distance = length2(canvasPoint - framePoint);
-	if (distance < radius2 && distance < resultDistance)
-	{
-		result = NORTHWEST;
-		resultDistance = distance;
-	}
-	
-	framePoint.setX(frameOrigin.x() + frameWidth/2);
-	distance = length2(canvasPoint - framePoint);
-	if (distance < radius2 && distance < resultDistance)
-	{
-		result = NORTH;
-		resultDistance = distance;
-	}
-	
-	framePoint.setX(frameOrigin.x() + frameWidth);
-	distance = length2(canvasPoint - framePoint);
-	if (distance < radius2 && distance < resultDistance)
-	{
-		result = NORTHEAST;
-		resultDistance = distance;
-	}
-	
-	framePoint.setY(frameOrigin.y() + frameHeight/2);
-	distance = length2(canvasPoint - framePoint);
-	if (distance < radius2 && distance < resultDistance)
-	{
-		result = EAST;
-		resultDistance = distance;
-	}
-	
-	framePoint.setY(frameOrigin.y() + frameHeight);
-	distance = length2(canvasPoint - framePoint);
-	if (distance < radius2 && distance < resultDistance)
-	{
-		result = SOUTHEAST;
-		resultDistance = distance;
-	}
-	
-	framePoint.setX(frameOrigin.x() + frameWidth/2);
-	distance = length2(canvasPoint - framePoint);
-	if (distance < radius2 && distance < resultDistance)
-	{
-		result = SOUTH;
-		resultDistance = distance;
-	}
-	
-	framePoint.setX(frameOrigin.x());
-	distance = length2(canvasPoint - framePoint);
-	if (distance < radius2 && distance < resultDistance)
-	{
-		result = SOUTHWEST;
-		resultDistance = distance;
-	}
-	
-	framePoint.setY(frameOrigin.y() + frameHeight/2);
-	distance = length2(canvasPoint - framePoint);
-	if (distance < radius2 && distance < resultDistance)
-	{
-		result = WEST;
-		//resultDistance = distance;
-	}
-	
-//	qDebug() << "framehittest" << canvasPoint << frame << "->" << result;
-	return result;
-}
-
-
-PageItem* Canvas::itemUnderCursor(QPoint globalPos, PageItem* itemAbove, bool allowInGroup, bool allowMasterItems) const
-{
-	PageItem* currItem;
-	QRectF mouseArea = globalToCanvas(QRect(globalPos, QSize(2*m_doc->guidesPrefs().grabRadius, 2*m_doc->guidesPrefs().grabRadius)));
-	// look for masterpage items first
-	if (allowMasterItems && !m_doc->masterPageMode() && m_doc->currentPage()->FromMaster.count() != 0)
-	{
-		ScPage* Mp = m_doc->MasterPages.at(m_doc->MasterNames[m_doc->currentPage()->masterPageName()]);
-		// if itemAbove is given, we expect to find it among the masterpage items of this page
-		int currNr = itemAbove ? m_doc->currentPage()->FromMaster.indexOf(itemAbove) - 1 : m_doc->currentPage()->FromMaster.count() - 1;
-		if (currNr < 0)
-			return nullptr;
-		while (currNr >= 0)
-		{
-			currItem = m_doc->currentPage()->FromMaster.at(currNr);
-			QTransform itemPos;
-			if (m_doc->canSelectItemOnLayer(currItem->m_layerID))
-			{
-				if (!currItem->ChangedMasterItem)
-				{
-					itemPos.translate(-Mp->xOffset() + m_doc->currentPage()->xOffset(), -Mp->yOffset() + m_doc->currentPage()->yOffset());
-				}
-				currItem->getTransform(itemPos);
-				QPainterPath currPath;
-				if (currItem->isLine())
-				{
-					double visualLineWidth = currItem->visualLineWidth();
-					currPath.moveTo(itemPos.map(QPointF(0.0, -visualLineWidth / 2.0)));
-					currPath.lineTo(itemPos.map(QPointF(currItem->width(), -visualLineWidth / 2.0)));
-					currPath.lineTo(itemPos.map(QPointF(currItem->width(),  visualLineWidth / 2.0)));
-					currPath.lineTo(itemPos.map(QPointF(0.0,  visualLineWidth / 2.0)));
-				}
-				else
-				{
-					currPath.moveTo(itemPos.map(QPointF(0, 0)));
-					currPath.lineTo(itemPos.map(QPointF(currItem->width(), 0)));
-					currPath.lineTo(itemPos.map(QPointF(currItem->width(), currItem->height())));
-					currPath.lineTo(itemPos.map(QPointF(0, currItem->height())));
-				}
-				currPath.closeSubpath();
-				QPainterPath currClip;
-				currClip.addPolygon(itemPos.map(QPolygonF(currItem->Clip)));
-				currClip.closeSubpath();
-				if (currPath.intersects(mouseArea) || currClip.intersects(mouseArea))
-				{
-					if (currItem->isGroup() && allowInGroup)
-					{
-						currItem->asGroupFrame()->adjustXYPosition();
-						PageItem* ret = itemInGroup(currItem, mouseArea);
-						if (ret != nullptr)
-							return ret;
-					}
-					return currItem;
-				}
-			}
-			--currNr;
-		}
-	}
-	// now look for normal items
-	if (m_doc->Items->isEmpty())
-		return nullptr;
-
-	QList<PageItem*> *itemList = (itemAbove && itemAbove->isGroupChild()) ? &itemAbove->parentGroup()->groupItemList : m_doc->Items;
-	int currNr = itemAbove ? itemList->indexOf(itemAbove) - 1 : itemList->count() - 1;
-	while (currNr >= 0)
-	{
-		currItem = itemList->at(currNr);
-		if ((m_doc->masterPageMode())  && (!((currItem->OwnPage == -1) || (currItem->OwnPage == static_cast<int>(m_doc->currentPage()->pageNr())))))
-		{
-			--currNr;
-			continue;
-		}
-		if ((m_doc->drawAsPreview && !m_doc->editOnPreview) && !(currItem->isAnnotation() || currItem->isGroup()))
-		{
-			--currNr;
-			continue;
-		}
-		if (m_doc->canSelectItemOnLayer(currItem->m_layerID))
-		{
-			QTransform itemPos = currItem->getTransform();
-			QPainterPath currPath;
-			if (currItem->isLine())
-			{
-				double visualLineWidth = currItem->visualLineWidth();
-				currPath.moveTo(itemPos.map(QPointF(0.0, -visualLineWidth / 2.0)));
-				currPath.lineTo(itemPos.map(QPointF(currItem->width(), -visualLineWidth / 2.0)));
-				currPath.lineTo(itemPos.map(QPointF(currItem->width(),  visualLineWidth / 2.0)));
-				currPath.lineTo(itemPos.map(QPointF(0.0,  visualLineWidth / 2.0)));
-			}
-			else
-			{
-				currPath.moveTo(itemPos.map(QPointF(0, 0)));
-				currPath.lineTo(itemPos.map(QPointF(currItem->width(), 0)));
-				currPath.lineTo(itemPos.map(QPointF(currItem->width(), currItem->height())));
-				currPath.lineTo(itemPos.map(QPointF(0, currItem->height())));
-			}
-			currPath.closeSubpath();
-			QPainterPath currClip;
-			currClip.addPolygon(itemPos.map(QPolygonF(currItem->Clip)));
-			currClip.closeSubpath();
-			if (currPath.intersects(mouseArea) || currClip.intersects(mouseArea))
-			{
-				if (currItem->isGroup() && allowInGroup)
-				{
-					currItem->asGroupFrame()->adjustXYPosition();
-					PageItem* ret = itemInGroup(currItem, mouseArea);
-					if (ret != nullptr)
-					{
-						if ((m_doc->drawAsPreview && !m_doc->editOnPreview) && !ret->isAnnotation())
-							return nullptr;
-						return ret;
-					}
-				}
-				return currItem;
-			}
-		}
-		--currNr;
-	}
-	return nullptr;
-}
-
-bool Canvas::cursorOverTextFrameControl(QPoint globalPos, PageItem* frame)
-{
-	FPoint mp = globalToCanvas(globalPos);
-	qreal sideLength = 10 / qMax(m_viewMode.scale, 1.0);
-	qreal left  = frame->xPos() + frame->width() - sideLength;
-	qreal right = left + sideLength;
-	qreal top   = frame->yPos() + frame->height() - sideLength;
-	qreal bottom = top + sideLength;
-	return mp.x()>left && mp.x()<right && mp.y()>top && mp.y()<bottom;
-}
-
-bool Canvas::cursorOverFrameControl(QPoint globalPos, const QRectF& targetRect, PageItem* frame)
-{
-	FPoint mp = globalToCanvas(globalPos);
-	QRectF tg = targetRect.translated(frame->xPos(), frame->yPos());
-	return tg.contains(QPointF(mp.x(), mp.y()));
-}
-
-PageItem* Canvas::itemInGroup(PageItem* group, const QRectF& mouseArea) const
-{
-	int currNr = group->groupItemList.count() - 1;
-	while (currNr >= 0)
-	{
-		PageItem* embedded = group->groupItemList.at(currNr);
-		QTransform itemPosN = embedded->getTransform();
-		QPainterPath currPath(itemPosN.map(QPointF(0, 0)));
-		currPath.lineTo(itemPosN.map(QPointF(embedded->width(), 0)));
-		currPath.lineTo(itemPosN.map(QPointF(embedded->width(), embedded->height())));
-		currPath.lineTo(itemPosN.map(QPointF(0, embedded->height())));
-		currPath.closeSubpath();
-		QPainterPath currClip;
-		currClip.addPolygon(itemPosN.map(QPolygonF(embedded->Clip)));
-		currClip.closeSubpath();
-		currClip.translate(embedded->gXpos, embedded->gYpos);
-		if (currPath.intersects(mouseArea) || currClip.intersects(mouseArea))
-		{
-			if (embedded->isGroup())
-			{
-				PageItem* ret = itemInGroup(embedded, mouseArea);
-				if (ret != nullptr)
-					return ret;
-			}
-			else
-				return embedded;
-		}
-		--currNr;
-	}
-	return nullptr;
-}
-
-PageItem * Canvas::itemUnderItem(PageItem * item, int& index) const
-{
-	int indice = qMin(index, m_doc->Items->count());
-	if (index < 0 || indice < 0)
-		return nullptr;
-
-	int itemid = m_doc->Items->indexOf(item);
-	QRectF baseRect(item->getBoundingRect());
-	int itemLevel = m_doc->layerLevelFromID(item->m_layerID);
-	if (itemLevel < 0)
-		return nullptr;
-
-	for(index = indice - 1; index >= 0; --index)
-	{
-		PageItem* item1 = m_doc->Items->at(index);
-		int item1id = m_doc->Items->indexOf(item1);
-		int level = m_doc->layerLevelFromID(item1->m_layerID);
-		if ((item != item1) && (level >= 0) && (level <= itemLevel))
-		{
-			if ((level == itemLevel) && (item1id > itemid))
-				continue;
-			QRectF uRect(item1->getBoundingRect());
-			if (baseRect.intersects(uRect))
-				return item1;
-		}
-	}
-	return nullptr;
-}
-
-// __________________
-// Buffered rendering:
-
-/*
- Rendermodes:
- 
- m_buffer holds the current page(s)
- m_bufferRect describes the contents in local coordinates:
-
- minCanvasCoordinate |-> local (0,0) 
- 
- (0,0) |-> local (scale*minCanvasCoordinate) 
- 
- local m_bufferRect.topLeft |-> buffer (0,0)
- 
- 
- */
-
-void Canvas::setRenderMode(RenderMode mode)
-{
-//	qDebug() << "setRenderMode" << m_renderMode << "-->" << mode;
-	if ( (mode < RENDER_SELECTION_SEPARATE) != (m_renderMode < RENDER_SELECTION_SEPARATE) )
-	{
-		clearBuffers();
-	}
-	m_renderMode = mode;
-}
-
-
-void Canvas::clearBuffers()
-{
-	m_buffer = QPixmap();
-	m_bufferRect = QRect();
-	m_selectionBuffer = QPixmap();
-	m_selectionRect = QRect();
-}
-
-void Canvas::setScale(double scale)
-{
-	if (m_viewMode.scale == scale)
-		return;
-	m_viewMode.scale = scale;
-	clearBuffers();
-	update();
-}
-
-
-bool Canvas::adjustBuffer()
-{
-	bool ret = false;
-	QRect viewport(-x(), -y(), m_view->viewport()->width(), m_view->viewport()->height());
-// 	qDebug()<<"Canvas::adjustBuffer"<<viewport<<m_viewMode.forceRedraw<<m_viewMode.operItemSelecting;
-	QPoint minCanvasCoordinate = canvasToLocal(QPointF(0.0, 0.0));
-	if (minCanvasCoordinate != m_oldMinCanvasCoordinate)
-	{
-		m_bufferRect.translate(minCanvasCoordinate.x() - m_oldMinCanvasCoordinate.x(),
-							   minCanvasCoordinate.y() - m_oldMinCanvasCoordinate.y());
-		m_oldMinCanvasCoordinate = minCanvasCoordinate;
-	}
-#if DRAW_DEBUG_LINES
-//	qDebug() << "adjust buffer" << m_bufferRect << "for viewport" << viewport;
-#endif
-	if (!m_bufferRect.isValid())
-	{
-//		qDebug() << "adjust buffer: invalid buffer, viewport" << viewport;
-		m_bufferRect = viewport;
-		m_buffer = createPixmap(m_bufferRect.width(), m_bufferRect.height());
-		fillBuffer(&m_buffer, m_bufferRect.topLeft(), m_bufferRect);
-		ret = true;
-#if DRAW_DEBUG_LINES
-		QPainter p(&m_buffer);
-		p.setPen(Qt::blue);
-		p.drawLine(0, 0, m_buffer.width(), m_buffer.height());
-		p.drawLine(m_buffer.width(), 0, 0, m_buffer.height());
-		p.end();
-#endif
-	}
-	else if (!m_bufferRect.contains(viewport))
-	{
-		QRect newRect(m_bufferRect);
-		if (m_bufferRect.left() > viewport.left())
-			newRect.translate(viewport.left() - m_bufferRect.left(), 0);
-		if (m_bufferRect.right() < viewport.right())
-			newRect.translate(viewport.right() - m_bufferRect.right(), 0);
-		if (m_bufferRect.top() > viewport.top())
-			newRect.translate(0, viewport.top() - m_bufferRect.top());
-		if (m_bufferRect.bottom() < viewport.bottom())
-			newRect.translate(0, viewport.bottom() - m_bufferRect.bottom());
-//		qDebug() << "adjust buffer: " << m_bufferRect << "outside viewport" << viewport << " new rect:" << newRect;
-		
-		if (!m_bufferRect.intersects(newRect))
-		{
-//			qDebug() << "adjust buffer: fresh buffer" << m_bufferRect << "-->" << newRect;
-			m_bufferRect = newRect;
-			m_buffer = createPixmap(m_bufferRect.width(), m_bufferRect.height());
-			fillBuffer(&m_buffer, m_bufferRect.topLeft(), m_bufferRect);
-			ret = true;
-#if DRAW_DEBUG_LINES
-			QPainter p(&m_buffer);
-			p.setPen(Qt::blue);
-			p.drawLine(0, 0, m_buffer.width(), m_buffer.height());
-			p.drawLine(m_buffer.width(), 0, 0, m_buffer.height());
-			p.end();
-#endif			
-		}
-		else
-		{
-			// copy buffer:
-			QPixmap newBuffer = createPixmap(newRect.width(), newRect.height());
-			QPainter p(&newBuffer);
-			int xpos = m_bufferRect.x() - newRect.x();
-			int ypos = m_bufferRect.y() - newRect.y();
-			int x = 0;
-			int y = 0;
-			int width = m_bufferRect.width();
-			int height = m_bufferRect.height();
-			if (xpos < 0)
-			{
-				x = -xpos;
-				width -= x;
-				xpos = 0;
-			}
-			if (ypos < 0)
-			{
-				y = -ypos;
-				height -= y;
-				ypos = 0;
-			}
-			if (xpos + width > newRect.width())
-			{
-				width = newRect.width() - xpos;
-			}
-			if (ypos + height > newRect.height())
-			{
-				height = newRect.height() - ypos;
-			}
-
-			drawPixmap(p, xpos, ypos, m_buffer, x, y, width + 1, height + 1);
-#if DRAW_DEBUG_LINES
-			p.setPen(Qt::blue);
-			p.drawLine(xpos, ypos + height / 2, xpos + width / 2, ypos);
-			p.drawLine(xpos + width, ypos + height / 2, xpos + width / 2, ypos);
-			p.drawLine(xpos, ypos + height / 2, xpos + width / 2, ypos + height);
-			p.drawLine(xpos + width, ypos + height / 2, xpos + width / 2, ypos + height);
-//			qDebug() << "adjust buffer old" << m_bufferRect << "@" << xpos << ypos << "--> new" << newRect;
-#endif
-			p.end();
-
-			// #8548, #13470 do not return true in this case, we only partially update buffer content
-			// and the redraw rect from paintEvent may not be included in the updated area if
-			// canvas has just been resized, after an object has been put in scrap area for eg.
-			if (newRect.top() < m_bufferRect.top())
-			{
-				fillBuffer(&newBuffer, newRect.topLeft(), QRect(newRect.left(), newRect.top(), newRect.width(), m_bufferRect.top() - newRect.top() + 2));
-				//ret = true;
-			}
-			if (newRect.bottom() > m_bufferRect.bottom())
-			{
-				fillBuffer(&newBuffer, newRect.topLeft(), QRect(newRect.left(), m_bufferRect.bottom() - 1, newRect.width(), newRect.bottom() - m_bufferRect.bottom() + 2));
-				//ret = true;
-			}
-			if (newRect.left() < m_bufferRect.left())
-			{
-				fillBuffer(&newBuffer, newRect.topLeft(), QRect(newRect.left(), m_bufferRect.top(), m_bufferRect.left() - newRect.left() + 2, m_bufferRect.height()));
-				//ret = true;
-			}
-			if (newRect.right() > m_bufferRect.right())
-			{
-				fillBuffer(&newBuffer, newRect.topLeft(), QRect(m_bufferRect.right() - 1, m_bufferRect.top(), newRect.right() - m_bufferRect.right() + 2, m_bufferRect.height()));
-				//ret = true;
-			}
-			m_buffer = newBuffer;
-			m_bufferRect = newRect;
-#if DRAW_DEBUG_LINES
-			QPainter p2(&m_buffer);
-			p2.setPen(Qt::blue);
-			p2.drawRect(xpos, ypos, width, height);
-			p2.end();
-#endif
-		}
-	}
-//	else
-//		qDebug() << "adjustBuffer: reusing" << m_bufferRect;
-// 	qDebug() << "Canvas::adjustBuffer"<<ret;
-	return ret;
-}
-
-void Canvas::fillBuffer(QPaintDevice* buffer, QPoint bufferOrigin, QRect clipRect)
-{
-// 	qDebug()<<"Canvas::fillBuffer"<<clipRect<<m_viewMode.forceRedraw<<m_viewMode.operItemSelecting;
-	QPainter painter(buffer);
-	painter.translate(-bufferOrigin.x(), -bufferOrigin.y());
-	drawContents(&painter, clipRect.x(), clipRect.y(), clipRect.width(), clipRect.height());
-	painter.end();
-}
-
-/**
-  Actually we have at least three super-layers:
-  - background (page outlines, guides if below)
-  - content (master & page objects)
-  - controls (selection, mode specific mrks, guides if above)
-  For export we only need the contents.
-*/
-void Canvas::paintEvent ( QPaintEvent * p )
-{
-//	qDebug()<<"Canvas::paintEvent"<<p->rect()<<m_viewMode.forceRedraw<<m_viewMode.operItemSelecting;
-// 	printBacktrace(62);
-	if (m_doc->isLoading() || !m_doc->DoDrawing)
-		return;
-// #define SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
-#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
-	QTime t;
-	QString dmode("");
-	int t1, t2, t3, t4, t5, t6;
-	t1 = t2 = t3 = t4 = t5 = t6 = 0;
-	t.start();
-#endif
-	// fill buffer if necessary
-	bool bufferFilled = adjustBuffer();
-	QPainter qp(this);
-	switch (m_renderMode)
-	{
-		case RENDER_NORMAL:
-		{
-#if DRAW_DEBUG_LINES
-//			qDebug() << "update Buffer:" << m_bufferRect << p->rect() << m_viewMode.forceRedraw;
-#endif
-#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
-			dmode = "NORMAL";
-			t1 = t.elapsed();
-			t.start();
-#endif
-			if ((m_viewMode.forceRedraw || m_viewMode.operTextSelecting) && (!bufferFilled))
-			{
-//				qDebug() << "Canvas::paintEvent: forceRedraw=" << m_viewMode.forceRedraw << "bufferFilled=" << bufferFilled;
-				fillBuffer(&m_buffer, m_bufferRect.topLeft(), p->rect());
-			}
-#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
-			t2 = t.elapsed();
-			t.start();
-#endif
-			int xV = p->rect().x() - m_bufferRect.x();
-			int yV = p->rect().y() - m_bufferRect.y();
-			int wV = p->rect().width();
-			int hV = p->rect().height();
-			if (hV > 0 && wV > 0)
-			{
-				drawPixmap(qp, p->rect().x(), p->rect().y(), m_buffer, xV, yV,  wV, hV);
-#if DRAW_DEBUG_LINES
-//				qDebug() << "normal rendering" << xV << yV << wV << hV << "at" << p->rect().x() << p->rect().y();
-				qp.setPen(Qt::blue);
-				qp.drawLine(p->rect().x(), p->rect().y(), p->rect().x() + p->rect().width(), p->rect().y() + p->rect().height());
-				qp.drawLine(p->rect().x() + p->rect().width(), p->rect().y(), p->rect().x(), p->rect().y() + p->rect().height());
-#endif
-			}
-		}
-#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
-			t3 = t.elapsed();
-			t.start();
-#endif
-			if (m_doc->appMode != modeNormal)
-			{
-				qp.save();
-				qp.scale(m_viewMode.scale, m_viewMode.scale);
-				qp.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
-				drawControls( &qp );
-				qp.restore();
-			}	
-#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
-			t4 = t.elapsed();
-			t.start();
-#endif			
-			break;
-		case RENDER_BUFFERED:
-		{
-#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
-			dmode = "BUFFER";
-			t1 = t.elapsed();
-			t.start();
-#endif
-				int xV = p->rect().x() - m_bufferRect.x();
-				int yV = p->rect().y() - m_bufferRect.y();
-				int wV = p->rect().width();
-				int hV = p->rect().height();
-				if (xV < 0)
-				{
-					wV += xV;
-					xV = 0;
-				}
-				if (yV < 0)
-				{
-					hV += yV;
-					yV = 0;
-				}
-#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
-				t2 = t.elapsed();
-				t.start();
-#endif
-				if (hV > 0 && wV > 0)
-				{
-					drawPixmap(qp, p->rect().x(), p->rect().y(), m_buffer, xV, yV,  wV, hV);
-	#if DRAW_DEBUG_LINES
-//					qDebug() << "buffered rendering" << xV << yV << wV << hV << "at" << p->rect().x() << p->rect().y();
-					qp.setPen(Qt::green);
-					qp.drawLine(p->rect().x(), p->rect().y(), p->rect().x() + p->rect().width(), p->rect().y() + p->rect().height());
-					qp.drawLine(p->rect().x() + p->rect().width(), p->rect().y(), p->rect().x(), p->rect().y() + p->rect().height());
-	#endif
-				}
-#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
-				t3 = t.elapsed();
-				t.start();
-#endif
-				if (m_doc->appMode != modeNormal)
-				{
-					qp.save();
-					qp.scale(m_viewMode.scale, m_viewMode.scale);
-					qp.translate(-m_doc->minCanvasCoordinate.x(), -m_doc->minCanvasCoordinate.y());
-					drawControls( &qp );
-					qp.restore();
-				}
-#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
-				t4 = t.elapsed();
-				t.start();
-#endif
-			}
-			break;
-		case RENDER_SELECTION_SEPARATE:
-			break;
-		case RENDER_SELECTION_BUFFERED:
-			break;
-		case RENDER_LEGACY:
-		default:
-			assert (false);
-	}
-	
-#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
-	t5 = t.elapsed();
-	t.start();
-#endif
-	// does mode specific rendering, currently selection in legacymode and nodes in nodeedit
-	m_view->m_canvasMode->drawControls(&qp);
-	m_view->m_canvasMode->drawSnapLine(&qp);
-#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
-	t6 = t.elapsed();
-	qDebug()<<dmode<<t1<<t2<<t3<<t4<<t5<<t6<<"-" <<t1+t2+t3+t4+t5+t6;
-#endif
-	m_viewMode.forceRedraw = false;
-	m_viewMode.operItemSelecting = false;
-	m_viewMode.operTextSelecting = false;
-}
-
-
-void Canvas::drawContents(QPainter *psx, int clipx, int clipy, int clipw, int cliph)
-{
-//	int Tsetup, Toutlines , Tbackground, Tcontents;
-//	Toutlines=0;
-//	QTime tim;
-//	tim.start();
-// 	qDebug() << "Canvas::drawContents" << clipx << clipy << clipw << cliph<<m_viewMode.forceRedraw<<m_viewMode.operItemSelecting;
-	int docPagesCount = m_doc->Pages->count();
-	ScPainter *painter = nullptr;
-	QImage img(clipw * devicePixelRatioF(), cliph * devicePixelRatioF(), QImage::Format_ARGB32_Premultiplied);
-	img.setDevicePixelRatio(devicePixelRatioF());
-	painter = new ScPainter(&img, img.width(), img.height(), 1.0, 0);
-	painter->clear(PrefsManager::instance().appPrefs.displayPrefs.scratchColor);	
-	painter->newPath();
-	painter->moveTo(0, 0);
-	painter->lineTo(clipw, 0);
-	painter->lineTo(clipw, cliph);
-	painter->lineTo(0, cliph);
-	painter->closePath();
-	painter->setClipPath();
-	painter->translate(-clipx, -clipy);
-	painter->setZoomFactor(m_viewMode.scale);
-	painter->translate(-m_doc->minCanvasCoordinate.x(), -m_doc->minCanvasCoordinate.y());
-	painter->setLineWidth(1);
-	painter->setFillMode(ScPainter::Solid);
-
-	ScLayer layer;
-	layer.isViewable = false;
-	layer.ID = 0;
-
-	if (!m_doc->masterPageMode())
-	{
-		drawBackgroundPageOutlines(painter, clipx, clipy, clipw, cliph);
-		m_viewMode.linkedFramesToShow.clear();
-		QRectF clip(clipx, clipy, clipw, cliph);
-		DrawPageBorder(painter, clip);
-		if (m_viewMode.viewAsPreview)
-		{
-			FPointArray PoLine;
-			getClipPathForPages(&PoLine);
-			painter->beginLayer(1.0, 0, &PoLine);
-		}
-		else
-			painter->beginLayer(1.0, 0);
-		int renderStackCount = m_doc->guidesPrefs().renderStackOrder.count();
-		for (int r = 0; r < renderStackCount; r++)
-		{
-			int ri = m_doc->guidesPrefs().renderStackOrder[r];
-			if (ri == 0)
-			{
-				if (!m_viewMode.viewAsPreview)
-					DrawPageMargins(painter, clip);			// drawing stack id = 0
-			}
-			else if (ri == 1)
-			{
-				if (!m_viewMode.viewAsPreview)
-					DrawPageBaselineGrid(painter, clip);	// drawing stack id = 1
-			}
-			else if (ri == 2)
-			{
-				if (!m_viewMode.viewAsPreview)
-					DrawPageGrid(painter, clip);			// drawing stack id = 2
-			}
-			else if (ri == 3)
-			{
-				if (!m_viewMode.viewAsPreview)
-					DrawPageGuides(painter, clip);			// drawing stack id = 3
-			}
-			else if (ri == 4)
-			{
-				int layerCount = m_doc->layerCount();	// drawing stack id = 4
-				for (int layerLevel = 0; layerLevel < layerCount; ++layerLevel)
-				{
-					m_doc->Layers.levelToLayer(layer, layerLevel);
-					for (int a = 0; a < docPagesCount; ++a)
-					{
-						DrawMasterItems(painter, m_doc->Pages->at(a), layer, QRect(clipx, clipy, clipw, cliph));
-					}
-					//first pass draws all except notes frames
-					DrawPageItems(painter, layer, QRect(clipx, clipy, clipw, cliph), false);
-					//second only for notes frames
-					DrawPageItems(painter, layer, QRect(clipx, clipy, clipw, cliph), true);
-				}
-			}
-		}
-		if (!m_viewMode.viewAsPreview)
-			DrawPageIndicator(painter, clip);
-		painter->endLayer();
-	}
-	else // masterPageMode
-	{			
-		m_viewMode.linkedFramesToShow.clear();
-		drawBackgroundMasterpage(painter, clipx, clipy, clipw, cliph);
-		painter->beginLayer(1.0, 0);
-		QRectF clip(clipx, clipy, clipw, cliph);
-		DrawPageBorder(painter, clip, true);
-		int renderStackCount = m_doc->guidesPrefs().renderStackOrder.count();
-		for (int r = 0; r < renderStackCount; r++)
-		{
-			int ri = m_doc->guidesPrefs().renderStackOrder[r];
-			if (ri == 0)
-			{
-				DrawPageMargins(painter, clip, true);			// drawing stack id = 0
-			}
-			else if (ri == 1)
-			{
-				DrawPageBaselineGrid(painter, clip, true);	// drawing stack id = 1
-			}
-			else if (ri == 2)
-			{
-				DrawPageGrid(painter, clip, true);			// drawing stack id = 2
-			}
-			else if (ri == 3)
-			{
-				DrawPageGuides(painter, clip, true);			// drawing stack id = 3
-			}
-			else if (ri == 4)
-			{
-				int layerCount = m_doc->layerCount();	// drawing stack id = 4
-				for (int layerLevel = 0; layerLevel < layerCount; ++layerLevel)
-				{
-					m_doc->Layers.levelToLayer(layer, layerLevel);
-					//first pass draws all except notes frames
-					DrawPageItems(painter, layer, QRect(clipx, clipy, clipw, cliph), false);
-					//second pass draw only notes frames
-					DrawPageItems(painter, layer, QRect(clipx, clipy, clipw, cliph), true);
-				}
-			}
-		}
-		DrawPageIndicator(painter, clip, true);
-		painter->endLayer();
-	}
-	if (((m_doc->m_Selection->count() != 0) || (m_viewMode.linkedFramesToShow.count() != 0))  && (!m_viewMode.viewAsPreview))
-	{
-		drawFrameLinks(painter);
-	}
-	painter->end();
-	psx->drawImage(clipx, clipy, img);
-	delete painter;
-	painter = nullptr;
-// 	qDebug( "Time elapsed: %d ms, setup=%d, outlines=%d, background=%d, contents=%d, rest=%d", tim.elapsed(), Tsetup,Toutlines -Tsetup, Tbackground-Toutlines, Tcontents-Tbackground, tim.elapsed() - Tcontents );
-}
-
-void Canvas::drawControls(QPainter *psx)
-{
-	psx->save();
-	if ((m_doc->appMode == modeDrawBezierLine) && (!m_viewMode.redrawPolygon.isEmpty()) && (m_doc->m_Selection->count() != 0))
-	{
-		drawControlsBezierCurve(psx, m_doc->m_Selection->itemAt(0));
-	}
-	if (m_viewMode.m_MouseButtonPressed && (m_doc->appMode == modeMeasurementTool))
-	{
-		drawControlsMeasurementLine(psx);
-	}
-	if (m_viewMode.m_MouseButtonPressed && (m_doc->appMode == modeDrawLine))
-	{
-		drawControlsDrawLine(psx);
-	}
-	if (m_viewMode.operItemMoving || m_viewMode.operItemResizing)
-	{
-		if (m_viewMode.operItemResizing)
-		{
-			if (!m_viewMode.redrawPolygon.isEmpty())
-			{
-				if (m_viewMode.m_MouseButtonPressed && ((m_doc->appMode == modeDrawFreehandLine) || (m_doc->appMode == modeDrawCalligraphicLine)))
-				{
-					drawControlsFreehandLine(psx);
-				}
-				else if (m_doc->appMode != modeDrawFreehandLine)
-				{
-//					qDebug() << "XXX drawControls - operItemResizing";
-					assert(false);
-//					drawControlsHighlightRect(psx);
-				}
-			}
-		}
-		else
-		{
-			drawControlsMovingItemsRect(psx);
-		}
-	}
-	else
-	{
-		if ((m_doc->m_Selection->count() != 0) && (m_doc->appMode != modeDrawBezierLine))
-		{
-//			drawControlsSelection(psx, m_doc->m_Selection->itemAt(0));
-			/*
-			 PageItem *currItem = m_doc->m_Selection->itemAt(0);
-			 if ((m_doc->appMode == modeEditClip) && (currItem->isSelected()))
-			 {
-				 drawControlsNodeEditPoints(psx, currItem);
-			 }
-			 else
-			 {
-				 drawControlsSelectionSpecial(psx, currItem);
-			 }*/
-		}
-	}
-	psx->restore();
-}	
-
-
-
-/**
- 
-*/
-void Canvas::drawControlsMovingItemsRect(QPainter* pp)
-{
-	int selectedItemCount = m_doc->m_Selection->count();
-	if (selectedItemCount <= 0)
-		return;
-		
-	PageItem *currItem = nullptr;
-	if (selectedItemCount >= moveWithBoxesOnlyThreshold)
-	{
-		double gx, gy, gw, gh;
-		m_doc->m_Selection->getGroupRect(&gx, &gy, &gw, &gh);
-		pp->translate(gx, gy);
-		pp->drawRect(QRectF(0.0, 0.0, gw, gh));
-		return;
-	}
-
-	for (int cu = 0; cu < selectedItemCount; cu++)
-	{
-		currItem = m_doc->m_Selection->itemAt(cu);
-		pp->save();
-		pp->translate(currItem->xPos(), currItem->yPos());
-		pp->rotate(currItem->rotation());							
-		pp->setBrush(Qt::NoBrush);
-		pp->setPen(QPen(Qt::black, 1.0 / m_viewMode.scale, Qt::DotLine, Qt::FlatCap, Qt::MiterJoin));
-		if (currItem->isGroup())
-		{
-			PageItem_Group* gItem = currItem->asGroupFrame();
-			pp->scale(gItem->width() / gItem->groupWidth, gItem->height() / gItem->groupHeight);
-			int itemCountG = gItem->groupItemList.count();
-			if (itemCountG < moveWithFullOutlinesThreshold)
-			{
-				for (int cg = 0; cg < itemCountG; cg++)
-				{
-					currItem = gItem->groupItemList.at(cg);
-					if (!(currItem->isLine()))
-						currItem->DrawPolyL(pp, currItem->Clip);
-					else
-					{
-						if (currItem->isLine())
-						{
-							int lw2 = 1;
-							int lw = 1;
-							Qt::PenCapStyle le = Qt::FlatCap;
-							if (currItem->NamedLStyle.isEmpty())
-							{
-								if (currItem->lineColor() != CommonStrings::None)
-								{
-									lw2 = qRound(currItem->lineWidth()  / 2.0);
-									lw = qRound(qMax(currItem->lineWidth(), 1.0));
-								}
-								le = currItem->PLineEnd;
-							}
-							else
-							{
-								MultiLine ml = m_doc->docLineStyles[currItem->NamedLStyle];
-								lw2 = qRound(ml[ml.size()-1].Width  / 2.0);
-								lw = qRound(qMax(ml[ml.size()-1].Width, 1.0));
-								le = static_cast<Qt::PenCapStyle>(ml[ml.size()-1].LineEnd);
-							}
-							if (le != Qt::FlatCap)
-								pp->drawRect(-lw2, -lw2, qRound(currItem->width())+lw, lw);
-							else
-								pp->drawRect(-1, -lw2, qRound(currItem->width()), lw);
-						}
-					}
-				}
-			}
-		}
-		else if (selectedItemCount < moveWithFullOutlinesThreshold)
-		{
-			if (!currItem->asLine())
-				currItem->DrawPolyL(pp, currItem->Clip);
-			else
-			{
-				int lw2 = 1;
-				int lw = 1;
-				Qt::PenCapStyle le = Qt::FlatCap;
-				if (currItem->NamedLStyle.isEmpty())
-				{
-					if (currItem->lineColor() != CommonStrings::None)
-					{
-						lw2 = qRound(currItem->lineWidth()  / 2.0);
-						lw = qRound(qMax(currItem->lineWidth(), 1.0));
-					}
-					le = currItem->PLineEnd;
-				}
-				else
-				{
-					MultiLine ml = m_doc->docLineStyles[currItem->NamedLStyle];
-					lw2 = qRound(ml[ml.size()-1].Width  / 2.0);
-					lw = qRound(qMax(ml[ml.size()-1].Width, 1.0));
-					le = static_cast<Qt::PenCapStyle>(ml[ml.size()-1].LineEnd);
-				}
-				if (le != Qt::FlatCap)
-					pp->drawRect(-lw2, -lw2, qRound(currItem->width())+lw, lw);
-				else
-					pp->drawRect(-1, -lw2, qRound(currItem->width()), lw);
-			}
-		}
-		else
-			pp->drawRect(0, 0, static_cast<int>(currItem->width())+1, static_cast<int>(currItem->height())+1);
-		pp->restore();
-	}
-}
-
-/**
-  draws the bezier curve in edit bezier mode
-  */
-void Canvas::drawControlsBezierCurve(QPainter* pp, PageItem* currItem)
-{
-	pp->setBrush(Qt::NoBrush);
-	pp->setPen(QPen(Qt::black, 1.0 / m_viewMode.scale, Qt::DotLine, Qt::FlatCap, Qt::MiterJoin));
-	pp->translate(static_cast<int>(currItem->xPos()), static_cast<int>(currItem->yPos()));
-	pp->rotate(currItem->rotation());
-	QPainterPath Bez;
-	if (currItem->PoLine.size() > 1)
-	{
-		QPoint nXY = m_viewMode.redrawPolygon.point(0);
-		if (!m_viewMode.m_MouseButtonPressed)
-		{
-			FPoint a1 = currItem->PoLine.point(currItem->PoLine.size()-2);
-			FPoint a2 = currItem->PoLine.point(currItem->PoLine.size()-1);
-			Bez.moveTo(a1.x(), a1.y());
-			Bez.cubicTo(a2.x(), a2.y(), nXY.x(), nXY.y(), nXY.x(), nXY.y());
-			pp->drawPath(Bez);
-		}
-		else
-		{
-			FPoint a2 = currItem->PoLine.point(currItem->PoLine.size()-1);
-			if (currItem->PoLine.size() > 2)
-			{
-				FPoint a1 = currItem->PoLine.point(currItem->PoLine.size()-2);
-				FPoint a3 = currItem->PoLine.point(currItem->PoLine.size()-3);
-				Bez.moveTo(a3.x(), a3.y());
-				Bez.cubicTo(a1.x(), a1.y(), nXY.x(), nXY.y(), a2.x(), a2.y());
-				pp->drawPath(Bez);
-			}
-			pp->drawLine(QPoint(qRound(a2.x()), qRound(a2.y())), nXY);
-		}
-	}
-	else
-	{
-		QPoint a2 = currItem->PoLine.pointQ(currItem->PoLine.size()-1);
-		QPoint nXY = m_viewMode.redrawPolygon.point(0);
-		pp->drawLine(a2, nXY);
-	}
-	m_viewMode.redrawPolygon.clear();
-}
-
-
-
-
-/**
-  draws the measurement line in measure mode
- */
-void Canvas::drawControlsMeasurementLine(QPainter* pp)
-{
-	pp->setBrush(Qt::NoBrush);
-	pp->setPen(QPen(Qt::black, 1.0, Qt::DotLine, Qt::FlatCap, Qt::MiterJoin));
-	pp->drawPolyline(m_viewMode.redrawPolygon);
-	m_viewMode.redrawPolygon.clear();
-}
-
-
-/**
-  draws the line in drawline mode
- */
-void Canvas::drawControlsDrawLine(QPainter* pp)
-{
-	pp->setBrush(Qt::NoBrush);
-	pp->setPen(QPen(Qt::black, 1.0 / m_viewMode.scale, Qt::DotLine, Qt::FlatCap, Qt::MiterJoin));
-	pp->drawPolyline(m_viewMode.redrawPolygon);
-	m_viewMode.redrawPolygon.clear();
-}
-
-
-/**
-  draws the freehand curve in freehand mode
- */
-void Canvas::drawControlsFreehandLine(QPainter* pp)
-{
-	pp->setBrush(Qt::NoBrush);
-	pp->setPen(QPen(Qt::black, 1.0 / m_viewMode.scale, Qt::DotLine, Qt::FlatCap, Qt::MiterJoin));
-	pp->drawPolyline(m_viewMode.redrawPolygon);
-	m_viewMode.redrawPolygon.clear();
-}
-
-
-/**
-  draws masterpage items of a specific layer
- */
-void Canvas::DrawMasterItems(ScPainter *painter, ScPage *page, ScLayer& layer, QRect clip)
-{
-	if ((m_viewMode.previewMode) && (!layer.isPrintable))
-		return;
-	if ((m_viewMode.viewAsPreview) && (!layer.isPrintable))
-		return;
-	if (!layer.isViewable)
-		return;
-	if (page->masterPageNameEmpty())
-		return;
-	if (page->FromMaster.count() <= 0)
-		return;
-
-	FPoint orig = localToCanvas(clip.topLeft());
-	QRectF cullingArea(static_cast<int>(orig.x()), static_cast<int>(orig.y()), 
-	                   qRound(clip.width() / m_viewMode.scale + 0.5), qRound(clip.height() / m_viewMode.scale + 0.5));
-
+/*
+ For general Scribus (>=1.3.2) copyright and licensing information please refer
+ to the COPYING file provided with the program. Following this notice may exist
+ a copyright and/or license notice that predates the release of Scribus 1.3.2
+ for which a new license (GPL+exception) is in place.
+ */
+/***************************************************************************
+*                                                                         *
+*   This program is free software; you can redistribute it and/or modify  *
+*   it under the terms of the GNU General Public License as published by  *
+*   the Free Software Foundation; either version 2 of the License, or     *
+*   (at your option) any later version.                                   *
+*                                                                         *
+***************************************************************************/
+
+#if defined(_MSC_VER) && !defined(_USE_MATH_DEFINES)
+#define _USE_MATH_DEFINES
+#endif
+#include <cmath>
+
+// #include <QDebug>
+#include <QToolTip>
+#include <QWidget>
+
+#include "appmodes.h"
+#include "canvas.h"
+#include "canvasmode.h"
+#include "pageitem_textframe.h"
+#include "pageitem_group.h"
+#include "pageitemiterator.h"
+#include "prefsmanager.h"
+#include "scpage.h"
+#include "scpainter.h"
+#include "scribusdoc.h"
+#include "scribusview.h"
+#include "selection.h"
+#include "ui/hruler.h"
+#include "ui/vruler.h"
+#include "util.h"
+#include "util_math.h"
+#include "units.h"
+
+#define DRAW_DEBUG_LINES 0
+
+static QPoint contentsToViewport(QPoint p)
+{
+	return p;
+}
+
+QDataStream &operator<< ( QDataStream & ds, const CanvasViewMode & vm )
+{
+	ds << vm.scale
+	<< vm.previewMode
+	<< vm.viewAsPreview
+	<< vm.previewVisual
+	<< vm.m_MouseButtonPressed
+	<< vm.operItemMoving
+	<< vm.operItemResizing
+	<< vm.operItemSelecting
+	<< vm.redrawPolygon
+	<< vm.linkedFramesToShow
+	<< vm.drawSelectedItemsWithControls
+	<< vm.drawFramelinksWithContents
+	<< vm.forceRedraw;
+	return ds;
+}
+
+QDataStream &operator>> ( QDataStream & ds, CanvasViewMode & vm )
+{
+	ds >> vm.scale
+	>> vm.previewMode
+	>> vm.viewAsPreview
+	>> vm.previewVisual
+	>> vm.m_MouseButtonPressed
+	>> vm.operItemMoving
+	>> vm.operItemResizing
+	>> vm.operItemSelecting
+	>> vm.redrawPolygon
+	>> vm.linkedFramesToShow
+	>> vm.drawSelectedItemsWithControls
+	>> vm.drawFramelinksWithContents
+	>> vm.forceRedraw;
+	return ds;
+}
+	
+
+Canvas::Canvas(ScribusDoc* doc, ScribusView* parent) : QWidget(parent), m_doc(doc), m_view(parent)
+{
+	setAutoFillBackground(true);
+	setAttribute(Qt::WA_OpaquePaintEvent, true);
+	setAttribute(Qt::WA_NoSystemBackground, true);
+	m_buffer = QPixmap();
+	m_bufferRect = QRect();
+	m_renderMode = RENDER_NORMAL;
+}
+
+void Canvas::setPreviewVisual(int mode)
+{
+	m_viewMode.previewVisual = qMax(0, mode);
+	m_viewMode.viewAsPreview = (mode >= 0);
+}
+// ______________________________
+// Coordinate Conversion Routines:
+
+
+FPoint Canvas::localToCanvas(QPoint p) const
+{
+
+/* Allow the user to select the exact coordinate represented by a ruler mark
+   when the mouse is lined up with the ruler, rather than returning the 
+   coordinate represented by the mathematical centre of the pixel which
+   may not be exactly the same as the coordinate represented by the ruler.
+*/
+
+// (xmin, xmax) = canvas top-left
+	double xmin = m_doc->minCanvasCoordinate.x();
+	double ymin = m_doc->minCanvasCoordinate.y();
+
+// (xoff, yoff) = ruler origin relative to canvas top-left
+	double xoff = m_doc->rulerXoffset - xmin;
+	double yoff = m_doc->rulerYoffset - ymin;
+	if (m_doc->guidesPrefs().rulerMode) {
+		xoff += m_doc->currentPage()->xOffset();
+		yoff += m_doc->currentPage()->yOffset();
+	}
+// (xsp, ysp) = spacing of ruler divisions
+	double xsp = m_doc->view()->horizRuler->ruleSpacing();
+	double ysp = m_doc->view()->vertRuler->ruleSpacing();
+
+	double sc = m_viewMode.scale;
+
+// number of ruler divisions from ruler origin to ruler mark closest to the
+// selected mouse coordinate
+	double xn = qRound((p.x()/sc - xoff)/xsp);
+	double yn = qRound((p.y()/sc - yoff)/ysp);
+
+// xn*xsp + xoff, yn*ysp + yoff = distance in canvas coordinates
+// from canvas top-left to ruler mark closest to selected mouse coordinate
+
+// If these round to the selected mouse coordinate, use these to define
+// (x,y), the coordinates of the desired point relative to the canvas top-left.
+// Otherwise, simply scale the mouse coordinates.
+	double x = ( qRound(sc*(xn*xsp + xoff)) == p.x() ? 
+	             xn * xsp + xoff : p.x() / sc );
+	double y = ( qRound(sc*(yn*ysp + yoff)) == p.y() ? 
+	             yn * ysp + yoff : p.y() / sc );
+		
+// Finally, add xmin,ymin to get the absolute canvas coordinates of the
+// desired point.
+	return FPoint(x + xmin, y + ymin);
+}
+
+QPoint Canvas::canvasToLocal(const FPoint& p) const
+{
+	return { qRound((p.x() - m_doc->minCanvasCoordinate.x()) * m_viewMode.scale),
+	         qRound((p.y() - m_doc->minCanvasCoordinate.y()) * m_viewMode.scale) };
+}
+
+QPoint Canvas::canvasToLocal(QPointF p) const
+{
+	return { qRound((p.x() - m_doc->minCanvasCoordinate.x()) * m_viewMode.scale),
+	         qRound((p.y() - m_doc->minCanvasCoordinate.y()) * m_viewMode.scale) };
+}
+
+QRect Canvas::canvasToLocal(const QRectF& p) const
+{
+	return { qRound((p.x() - m_doc->minCanvasCoordinate.x()) * m_viewMode.scale),
+	         qRound((p.y() - m_doc->minCanvasCoordinate.y()) * m_viewMode.scale),
+	         qRound(p.width() * m_viewMode.scale),
+	         qRound(p.height() * m_viewMode.scale) };
+}
+
+QRectF Canvas::canvasToLocalF(const QRectF& p) const
+{
+	return { (p.x() - m_doc->minCanvasCoordinate.x()) * m_viewMode.scale,
+	         (p.y() - m_doc->minCanvasCoordinate.y()) * m_viewMode.scale,
+	         p.width() * m_viewMode.scale,
+	         p.height() * m_viewMode.scale };
+}
+
+QPoint Canvas::canvasToGlobal(const FPoint& p) const
+{
+	return mapToParent(QPoint(0,0)) + parentWidget()->mapToGlobal(QPoint(0, 0)) + canvasToLocal(p);
+}
+
+QPoint Canvas::canvasToGlobal(QPointF p) const
+{
+	return mapToParent(QPoint(0,0)) + parentWidget()->mapToGlobal(QPoint(0, 0)) + canvasToLocal(p);
+}
+
+QRect Canvas::canvasToGlobal(const QRectF& p) const
+{
+	return { mapToParent(QPoint(0,0) + canvasToLocal(p.topLeft())) + parentWidget()->mapToGlobal(QPoint(0, 0)),
+	         QSize(qRound(p.width() * m_viewMode.scale), qRound(p.height() * m_viewMode.scale)) };
+}
+
+FPoint Canvas::globalToCanvas(QPoint p) const
+{
+	return localToCanvas(p - (mapToParent(QPoint(0, 0)) + parentWidget()->mapToGlobal(QPoint(0, 0))));
+}
+
+QRectF Canvas::globalToCanvas(QRect p) const
+{
+	FPoint org = globalToCanvas(p.topLeft());
+	return { org.x(), org.y(), p.width() / m_viewMode.scale, p.height() / m_viewMode.scale };
+}
+
+// ________________________
+// Tests for Finding Things:
+
+bool Canvas::hitsCanvasPoint(QPoint globalPoint, const FPoint& canvasPoint) const
+{
+	QPoint localPoint1 = globalPoint - (mapToParent(QPoint(0,0)) + parentWidget()->mapToGlobal(QPoint(0, 0)));
+	QPoint localPoint2 = canvasToLocal(canvasPoint);
+	int radius = m_doc->guidesPrefs().grabRadius;
+	return qAbs(localPoint1.x() - localPoint2.x()) < radius && qAbs(localPoint1.y() - localPoint2.y()) < radius;
+}
+
+
+bool Canvas::hitsCanvasPoint(QPoint globalPoint, QPointF canvasPoint) const
+{
+	QPoint localPoint1 = globalPoint - (mapToParent(QPoint(0,0)) + parentWidget()->mapToGlobal(QPoint(0, 0)));
+	QPoint localPoint2 = canvasToLocal(canvasPoint);
+	int radius = m_doc->guidesPrefs().grabRadius;
+	return qAbs(localPoint1.x() - localPoint2.x()) < radius && qAbs(localPoint1.y() - localPoint2.y()) < radius;
+}
+
+bool Canvas::hitsCanvasPoint(const FPoint& globalPoint, const QPointF& canvasPoint) const
+{
+	double radius = m_doc->guidesPrefs().grabRadius;
+	return qAbs(globalPoint.x() - canvasPoint.x()) < radius && qAbs(globalPoint.y() - canvasPoint.y()) < radius;
+}
+
+QRect Canvas::exposedRect() const
+{
+	int ex( -(x() / m_viewMode.scale) + m_doc->minCanvasCoordinate.x());
+	int ey( -(y() / m_viewMode.scale) + m_doc->minCanvasCoordinate.y());
+	int ew( (m_view->visibleWidth() * 1.2) / m_viewMode.scale);
+	int eh( (m_view->visibleHeight() * 1.2) / m_viewMode.scale);
+	
+	return { ex, ey, ew, eh };
+}
+
+
+/// Little helper to calculate |p|^2
+
+static double length2(const QPointF& p)
+{
+	return p.x()*p.x() + p.y()*p.y();
+}
+
+
+
+/*!
+  returns -1 if canvasPoint is outside the frame + grabradius.
+  returns frameHandle if canvasPoint is near a framehandle
+  otherwise 0
+ */
+Canvas::FrameHandle Canvas::frameHitTest(QPointF canvasPoint, PageItem* item) const
+{
+	// As item->getTransform() will translate to Pos, we need to adjust the rect passed
+	// to frameHitTest in order to take line width, which in very *creative* design can
+	// be huge, into account.
+	// ### might be interesting to investigate if it would be painless to just change 
+	// PageItem::getTransform.
+	double extraS = - item->visualLineWidth() / 2.0;
+//	if (item->lineColor() != CommonStrings::None)
+//		extraS = (item->lineWidth() / -2.0);
+	if (item->isTextFrame() && (m_doc->appMode == modeEdit) && !item->asTextFrame()->availableRegion().contains(item->getTransform().inverted().map(canvasPoint.toPoint())))
+		return OUTSIDE;
+	QRectF visualRect = item->isLine() ? QRectF(0, extraS, item->visualWidth(), item->visualHeight()) 
+		                               : QRectF(extraS, extraS, item->visualWidth(), item->visualHeight());
+	Canvas::FrameHandle result = frameHitTest(item->getTransform().inverted().map(canvasPoint), visualRect);
+//	qDebug() << "frameHitTest for item" << item->ItemNr 
+//		<< item->getTransform().inverted().map(canvasPoint) 
+//		<< item->getTransform().inverted() 
+//		<< QRectF(0, 0, item->width(), item->height());
+	return result;
+}
+
+Canvas::FrameHandle Canvas::frameHitTest(QPointF canvasPoint, const QRectF& frame) const
+{
+	FrameHandle result = INSIDE;
+	const double radius = m_doc->guidesPrefs().grabRadius / m_viewMode.scale;
+	const double radius2 = radius * radius;
+	double resultDistance = radius2 * 10.0; // far off
+	
+	const double frameWidth = frame.width();
+	const double frameHeight = frame.height();
+	const QPointF frameOrigin = frame.topLeft();
+	
+	if (canvasPoint.x() < frameOrigin.x() - radius ||
+		canvasPoint.x() > frameOrigin.x() + frameWidth + radius ||
+		canvasPoint.y() < frameOrigin.y() - radius ||
+		canvasPoint.y() > frameOrigin.y() + frameHeight + radius)
+	{
+//		qDebug() << "framehittest" << canvasPoint << frame << "-> OUTSIDE";
+		return OUTSIDE;
+	}
+	
+	QPointF framePoint = frameOrigin;
+	double distance = length2(canvasPoint - framePoint);
+	if (distance < radius2 && distance < resultDistance)
+	{
+		result = NORTHWEST;
+		resultDistance = distance;
+	}
+	
+	framePoint.setX(frameOrigin.x() + frameWidth/2);
+	distance = length2(canvasPoint - framePoint);
+	if (distance < radius2 && distance < resultDistance)
+	{
+		result = NORTH;
+		resultDistance = distance;
+	}
+	
+	framePoint.setX(frameOrigin.x() + frameWidth);
+	distance = length2(canvasPoint - framePoint);
+	if (distance < radius2 && distance < resultDistance)
+	{
+		result = NORTHEAST;
+		resultDistance = distance;
+	}
+	
+	framePoint.setY(frameOrigin.y() + frameHeight/2);
+	distance = length2(canvasPoint - framePoint);
+	if (distance < radius2 && distance < resultDistance)
+	{
+		result = EAST;
+		resultDistance = distance;
+	}
+	
+	framePoint.setY(frameOrigin.y() + frameHeight);
+	distance = length2(canvasPoint - framePoint);
+	if (distance < radius2 && distance < resultDistance)
+	{
+		result = SOUTHEAST;
+		resultDistance = distance;
+	}
+	
+	framePoint.setX(frameOrigin.x() + frameWidth/2);
+	distance = length2(canvasPoint - framePoint);
+	if (distance < radius2 && distance < resultDistance)
+	{
+		result = SOUTH;
+		resultDistance = distance;
+	}
+	
+	framePoint.setX(frameOrigin.x());
+	distance = length2(canvasPoint - framePoint);
+	if (distance < radius2 && distance < resultDistance)
+	{
+		result = SOUTHWEST;
+		resultDistance = distance;
+	}
+	
+	framePoint.setY(frameOrigin.y() + frameHeight/2);
+	distance = length2(canvasPoint - framePoint);
+	if (distance < radius2 && distance < resultDistance)
+	{
+		result = WEST;
+		//resultDistance = distance;
+	}
+	
+//	qDebug() << "framehittest" << canvasPoint << frame << "->" << result;
+	return result;
+}
+
+
+PageItem* Canvas::itemUnderCursor(QPoint globalPos, PageItem* itemAbove, bool allowInGroup, bool allowMasterItems) const
+{
+	PageItem* currItem;
+	QRectF mouseArea = globalToCanvas(QRect(globalPos, QSize(2*m_doc->guidesPrefs().grabRadius, 2*m_doc->guidesPrefs().grabRadius)));
+	// look for masterpage items first
+	if (allowMasterItems && !m_doc->masterPageMode() && m_doc->currentPage()->FromMaster.count() != 0)
+	{
+		ScPage* Mp = m_doc->MasterPages.at(m_doc->MasterNames[m_doc->currentPage()->masterPageName()]);
+		// if itemAbove is given, we expect to find it among the masterpage items of this page
+		int currNr = itemAbove ? m_doc->currentPage()->FromMaster.indexOf(itemAbove) - 1 : m_doc->currentPage()->FromMaster.count() - 1;
+		if (currNr < 0)
+			return nullptr;
+		while (currNr >= 0)
+		{
+			currItem = m_doc->currentPage()->FromMaster.at(currNr);
+			QTransform itemPos;
+			if (m_doc->canSelectItemOnLayer(currItem->m_layerID))
+			{
+				if (!currItem->ChangedMasterItem)
+				{
+					itemPos.translate(-Mp->xOffset() + m_doc->currentPage()->xOffset(), -Mp->yOffset() + m_doc->currentPage()->yOffset());
+				}
+				currItem->getTransform(itemPos);
+				QPainterPath currPath;
+				if (currItem->isLine())
+				{
+					double visualLineWidth = currItem->visualLineWidth();
+					currPath.moveTo(itemPos.map(QPointF(0.0, -visualLineWidth / 2.0)));
+					currPath.lineTo(itemPos.map(QPointF(currItem->width(), -visualLineWidth / 2.0)));
+					currPath.lineTo(itemPos.map(QPointF(currItem->width(),  visualLineWidth / 2.0)));
+					currPath.lineTo(itemPos.map(QPointF(0.0,  visualLineWidth / 2.0)));
+				}
+				else
+				{
+					currPath.moveTo(itemPos.map(QPointF(0, 0)));
+					currPath.lineTo(itemPos.map(QPointF(currItem->width(), 0)));
+					currPath.lineTo(itemPos.map(QPointF(currItem->width(), currItem->height())));
+					currPath.lineTo(itemPos.map(QPointF(0, currItem->height())));
+				}
+				currPath.closeSubpath();
+				QPainterPath currClip;
+				currClip.addPolygon(itemPos.map(QPolygonF(currItem->Clip)));
+				currClip.closeSubpath();
+				if (currPath.intersects(mouseArea) || currClip.intersects(mouseArea))
+				{
+					if (currItem->isGroup() && allowInGroup)
+					{
+						currItem->asGroupFrame()->adjustXYPosition();
+						PageItem* ret = itemInGroup(currItem, mouseArea);
+						if (ret != nullptr)
+							return ret;
+					}
+					return currItem;
+				}
+			}
+			--currNr;
+		}
+	}
+	// now look for normal items
+	if (m_doc->Items->isEmpty())
+		return nullptr;
+
+	QList<PageItem*> *itemList = (itemAbove && itemAbove->isGroupChild()) ? &itemAbove->parentGroup()->groupItemList : m_doc->Items;
+	int currNr = itemAbove ? itemList->indexOf(itemAbove) - 1 : itemList->count() - 1;
+	while (currNr >= 0)
+	{
+		currItem = itemList->at(currNr);
+		if ((m_doc->masterPageMode())  && (!((currItem->OwnPage == -1) || (currItem->OwnPage == static_cast<int>(m_doc->currentPage()->pageNr())))))
+		{
+			--currNr;
+			continue;
+		}
+		if ((m_doc->drawAsPreview && !m_doc->editOnPreview) && !(currItem->isAnnotation() || currItem->isGroup()))
+		{
+			--currNr;
+			continue;
+		}
+		if (m_doc->canSelectItemOnLayer(currItem->m_layerID))
+		{
+			QTransform itemPos = currItem->getTransform();
+			QPainterPath currPath;
+			if (currItem->isLine())
+			{
+				double visualLineWidth = currItem->visualLineWidth();
+				currPath.moveTo(itemPos.map(QPointF(0.0, -visualLineWidth / 2.0)));
+				currPath.lineTo(itemPos.map(QPointF(currItem->width(), -visualLineWidth / 2.0)));
+				currPath.lineTo(itemPos.map(QPointF(currItem->width(),  visualLineWidth / 2.0)));
+				currPath.lineTo(itemPos.map(QPointF(0.0,  visualLineWidth / 2.0)));
+			}
+			else
+			{
+				currPath.moveTo(itemPos.map(QPointF(0, 0)));
+				currPath.lineTo(itemPos.map(QPointF(currItem->width(), 0)));
+				currPath.lineTo(itemPos.map(QPointF(currItem->width(), currItem->height())));
+				currPath.lineTo(itemPos.map(QPointF(0, currItem->height())));
+			}
+			currPath.closeSubpath();
+			QPainterPath currClip;
+			currClip.addPolygon(itemPos.map(QPolygonF(currItem->Clip)));
+			currClip.closeSubpath();
+			if (currPath.intersects(mouseArea) || currClip.intersects(mouseArea))
+			{
+				if (currItem->isGroup() && allowInGroup)
+				{
+					currItem->asGroupFrame()->adjustXYPosition();
+					PageItem* ret = itemInGroup(currItem, mouseArea);
+					if (ret != nullptr)
+					{
+						if ((m_doc->drawAsPreview && !m_doc->editOnPreview) && !ret->isAnnotation())
+							return nullptr;
+						return ret;
+					}
+				}
+				return currItem;
+			}
+		}
+		--currNr;
+	}
+	return nullptr;
+}
+
+bool Canvas::cursorOverTextFrameControl(QPoint globalPos, PageItem* frame)
+{
+	FPoint mp = globalToCanvas(globalPos);
+	qreal sideLength = 10 / qMax(m_viewMode.scale, 1.0);
+	qreal left  = frame->xPos() + frame->width() - sideLength;
+	qreal right = left + sideLength;
+	qreal top   = frame->yPos() + frame->height() - sideLength;
+	qreal bottom = top + sideLength;
+	return mp.x()>left && mp.x()<right && mp.y()>top && mp.y()<bottom;
+}
+
+bool Canvas::cursorOverFrameControl(QPoint globalPos, const QRectF& targetRect, PageItem* frame)
+{
+	FPoint mp = globalToCanvas(globalPos);
+	QRectF tg = targetRect.translated(frame->xPos(), frame->yPos());
+	return tg.contains(QPointF(mp.x(), mp.y()));
+}
+
+PageItem* Canvas::itemInGroup(PageItem* group, const QRectF& mouseArea) const
+{
+	int currNr = group->groupItemList.count() - 1;
+	while (currNr >= 0)
+	{
+		PageItem* embedded = group->groupItemList.at(currNr);
+		QTransform itemPosN = embedded->getTransform();
+		QPainterPath currPath(itemPosN.map(QPointF(0, 0)));
+		currPath.lineTo(itemPosN.map(QPointF(embedded->width(), 0)));
+		currPath.lineTo(itemPosN.map(QPointF(embedded->width(), embedded->height())));
+		currPath.lineTo(itemPosN.map(QPointF(0, embedded->height())));
+		currPath.closeSubpath();
+		QPainterPath currClip;
+		currClip.addPolygon(itemPosN.map(QPolygonF(embedded->Clip)));
+		currClip.closeSubpath();
+		currClip.translate(embedded->gXpos, embedded->gYpos);
+		if (currPath.intersects(mouseArea) || currClip.intersects(mouseArea))
+		{
+			if (embedded->isGroup())
+			{
+				PageItem* ret = itemInGroup(embedded, mouseArea);
+				if (ret != nullptr)
+					return ret;
+			}
+			else
+				return embedded;
+		}
+		--currNr;
+	}
+	return nullptr;
+}
+
+PageItem * Canvas::itemUnderItem(PageItem * item, int& index) const
+{
+	int indice = qMin(index, m_doc->Items->count());
+	if (index < 0 || indice < 0)
+		return nullptr;
+
+	int itemid = m_doc->Items->indexOf(item);
+	QRectF baseRect(item->getBoundingRect());
+	int itemLevel = m_doc->layerLevelFromID(item->m_layerID);
+	if (itemLevel < 0)
+		return nullptr;
+
+	for(index = indice - 1; index >= 0; --index)
+	{
+		PageItem* item1 = m_doc->Items->at(index);
+		int item1id = m_doc->Items->indexOf(item1);
+		int level = m_doc->layerLevelFromID(item1->m_layerID);
+		if ((item != item1) && (level >= 0) && (level <= itemLevel))
+		{
+			if ((level == itemLevel) && (item1id > itemid))
+				continue;
+			QRectF uRect(item1->getBoundingRect());
+			if (baseRect.intersects(uRect))
+				return item1;
+		}
+	}
+	return nullptr;
+}
+
+// __________________
+// Buffered rendering:
+
+/*
+ Rendermodes:
+ 
+ m_buffer holds the current page(s)
+ m_bufferRect describes the contents in local coordinates:
+
+ minCanvasCoordinate |-> local (0,0) 
+ 
+ (0,0) |-> local (scale*minCanvasCoordinate) 
+ 
+ local m_bufferRect.topLeft |-> buffer (0,0)
+ 
+ 
+ */
+
+void Canvas::setRenderMode(RenderMode mode)
+{
+//	qDebug() << "setRenderMode" << m_renderMode << "-->" << mode;
+	if ( (mode < RENDER_SELECTION_SEPARATE) != (m_renderMode < RENDER_SELECTION_SEPARATE) )
+	{
+		clearBuffers();
+	}
+	m_renderMode = mode;
+}
+
+
+void Canvas::clearBuffers()
+{
+	m_buffer = QPixmap();
+	m_bufferRect = QRect();
+	m_selectionBuffer = QPixmap();
+	m_selectionRect = QRect();
+}
+
+void Canvas::setScale(double scale)
+{
+	if (m_viewMode.scale == scale)
+		return;
+	m_viewMode.scale = scale;
+	clearBuffers();
+	update();
+}
+
+
+bool Canvas::adjustBuffer()
+{
+	bool ret = false;
+	QRect viewport(-x(), -y(), m_view->viewport()->width(), m_view->viewport()->height());
+// 	qDebug()<<"Canvas::adjustBuffer"<<viewport<<m_viewMode.forceRedraw<<m_viewMode.operItemSelecting;
+	QPoint minCanvasCoordinate = canvasToLocal(QPointF(0.0, 0.0));
+	if (minCanvasCoordinate != m_oldMinCanvasCoordinate)
+	{
+		m_bufferRect.translate(minCanvasCoordinate.x() - m_oldMinCanvasCoordinate.x(),
+							   minCanvasCoordinate.y() - m_oldMinCanvasCoordinate.y());
+		m_oldMinCanvasCoordinate = minCanvasCoordinate;
+	}
+#if DRAW_DEBUG_LINES
+//	qDebug() << "adjust buffer" << m_bufferRect << "for viewport" << viewport;
+#endif
+	if (!m_bufferRect.isValid())
+	{
+//		qDebug() << "adjust buffer: invalid buffer, viewport" << viewport;
+		m_bufferRect = viewport;
+		m_buffer = createPixmap(m_bufferRect.width(), m_bufferRect.height());
+		fillBuffer(&m_buffer, m_bufferRect.topLeft(), m_bufferRect);
+		ret = true;
+#if DRAW_DEBUG_LINES
+		QPainter p(&m_buffer);
+		p.setPen(Qt::blue);
+		p.drawLine(0, 0, m_buffer.width(), m_buffer.height());
+		p.drawLine(m_buffer.width(), 0, 0, m_buffer.height());
+		p.end();
+#endif
+	}
+	else if (!m_bufferRect.contains(viewport))
+	{
+		QRect newRect(m_bufferRect);
+		if (m_bufferRect.left() > viewport.left())
+			newRect.translate(viewport.left() - m_bufferRect.left(), 0);
+		if (m_bufferRect.right() < viewport.right())
+			newRect.translate(viewport.right() - m_bufferRect.right(), 0);
+		if (m_bufferRect.top() > viewport.top())
+			newRect.translate(0, viewport.top() - m_bufferRect.top());
+		if (m_bufferRect.bottom() < viewport.bottom())
+			newRect.translate(0, viewport.bottom() - m_bufferRect.bottom());
+//		qDebug() << "adjust buffer: " << m_bufferRect << "outside viewport" << viewport << " new rect:" << newRect;
+		
+		if (!m_bufferRect.intersects(newRect))
+		{
+//			qDebug() << "adjust buffer: fresh buffer" << m_bufferRect << "-->" << newRect;
+			m_bufferRect = newRect;
+			m_buffer = createPixmap(m_bufferRect.width(), m_bufferRect.height());
+			fillBuffer(&m_buffer, m_bufferRect.topLeft(), m_bufferRect);
+			ret = true;
+#if DRAW_DEBUG_LINES
+			QPainter p(&m_buffer);
+			p.setPen(Qt::blue);
+			p.drawLine(0, 0, m_buffer.width(), m_buffer.height());
+			p.drawLine(m_buffer.width(), 0, 0, m_buffer.height());
+			p.end();
+#endif			
+		}
+		else
+		{
+			// copy buffer:
+			QPixmap newBuffer = createPixmap(newRect.width(), newRect.height());
+			QPainter p(&newBuffer);
+			int xpos = m_bufferRect.x() - newRect.x();
+			int ypos = m_bufferRect.y() - newRect.y();
+			int x = 0;
+			int y = 0;
+			int width = m_bufferRect.width();
+			int height = m_bufferRect.height();
+			if (xpos < 0)
+			{
+				x = -xpos;
+				width -= x;
+				xpos = 0;
+			}
+			if (ypos < 0)
+			{
+				y = -ypos;
+				height -= y;
+				ypos = 0;
+			}
+			if (xpos + width > newRect.width())
+			{
+				width = newRect.width() - xpos;
+			}
+			if (ypos + height > newRect.height())
+			{
+				height = newRect.height() - ypos;
+			}
+
+			drawPixmap(p, xpos, ypos, m_buffer, x, y, width + 1, height + 1);
+#if DRAW_DEBUG_LINES
+			p.setPen(Qt::blue);
+			p.drawLine(xpos, ypos + height / 2, xpos + width / 2, ypos);
+			p.drawLine(xpos + width, ypos + height / 2, xpos + width / 2, ypos);
+			p.drawLine(xpos, ypos + height / 2, xpos + width / 2, ypos + height);
+			p.drawLine(xpos + width, ypos + height / 2, xpos + width / 2, ypos + height);
+//			qDebug() << "adjust buffer old" << m_bufferRect << "@" << xpos << ypos << "--> new" << newRect;
+#endif
+			p.end();
+
+			// #8548, #13470 do not return true in this case, we only partially update buffer content
+			// and the redraw rect from paintEvent may not be included in the updated area if
+			// canvas has just been resized, after an object has been put in scrap area for eg.
+			if (newRect.top() < m_bufferRect.top())
+			{
+				fillBuffer(&newBuffer, newRect.topLeft(), QRect(newRect.left(), newRect.top(), newRect.width(), m_bufferRect.top() - newRect.top() + 2));
+				//ret = true;
+			}
+			if (newRect.bottom() > m_bufferRect.bottom())
+			{
+				fillBuffer(&newBuffer, newRect.topLeft(), QRect(newRect.left(), m_bufferRect.bottom() - 1, newRect.width(), newRect.bottom() - m_bufferRect.bottom() + 2));
+				//ret = true;
+			}
+			if (newRect.left() < m_bufferRect.left())
+			{
+				fillBuffer(&newBuffer, newRect.topLeft(), QRect(newRect.left(), m_bufferRect.top(), m_bufferRect.left() - newRect.left() + 2, m_bufferRect.height()));
+				//ret = true;
+			}
+			if (newRect.right() > m_bufferRect.right())
+			{
+				fillBuffer(&newBuffer, newRect.topLeft(), QRect(m_bufferRect.right() - 1, m_bufferRect.top(), newRect.right() - m_bufferRect.right() + 2, m_bufferRect.height()));
+				//ret = true;
+			}
+			m_buffer = newBuffer;
+			m_bufferRect = newRect;
+#if DRAW_DEBUG_LINES
+			QPainter p2(&m_buffer);
+			p2.setPen(Qt::blue);
+			p2.drawRect(xpos, ypos, width, height);
+			p2.end();
+#endif
+		}
+	}
+//	else
+//		qDebug() << "adjustBuffer: reusing" << m_bufferRect;
+// 	qDebug() << "Canvas::adjustBuffer"<<ret;
+	return ret;
+}
+
+void Canvas::fillBuffer(QPaintDevice* buffer, QPoint bufferOrigin, QRect clipRect)
+{
+// 	qDebug()<<"Canvas::fillBuffer"<<clipRect<<m_viewMode.forceRedraw<<m_viewMode.operItemSelecting;
+	QPainter painter(buffer);
+	painter.translate(-bufferOrigin.x(), -bufferOrigin.y());
+	drawContents(&painter, clipRect.x(), clipRect.y(), clipRect.width(), clipRect.height());
+	painter.end();
+}
+
+/**
+  Actually we have at least three super-layers:
+  - background (page outlines, guides if below)
+  - content (master & page objects)
+  - controls (selection, mode specific mrks, guides if above)
+  For export we only need the contents.
+*/
+void Canvas::paintEvent ( QPaintEvent * p )
+{
+//	qDebug()<<"Canvas::paintEvent"<<p->rect()<<m_viewMode.forceRedraw<<m_viewMode.operItemSelecting;
+// 	printBacktrace(62);
+	if (m_doc->isLoading() || !m_doc->DoDrawing)
+		return;
+// #define SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
+#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
+	QTime t;
+	QString dmode("");
+	int t1, t2, t3, t4, t5, t6;
+	t1 = t2 = t3 = t4 = t5 = t6 = 0;
+	t.start();
+#endif
+	// fill buffer if necessary
+	bool bufferFilled = adjustBuffer();
+	QPainter qp(this);
+	switch (m_renderMode)
+	{
+		case RENDER_NORMAL:
+		{
+#if DRAW_DEBUG_LINES
+//			qDebug() << "update Buffer:" << m_bufferRect << p->rect() << m_viewMode.forceRedraw;
+#endif
+#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
+			dmode = "NORMAL";
+			t1 = t.elapsed();
+			t.start();
+#endif
+			if ((m_viewMode.forceRedraw || m_viewMode.operTextSelecting) && (!bufferFilled))
+			{
+//				qDebug() << "Canvas::paintEvent: forceRedraw=" << m_viewMode.forceRedraw << "bufferFilled=" << bufferFilled;
+				fillBuffer(&m_buffer, m_bufferRect.topLeft(), p->rect());
+			}
+#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
+			t2 = t.elapsed();
+			t.start();
+#endif
+			int xV = p->rect().x() - m_bufferRect.x();
+			int yV = p->rect().y() - m_bufferRect.y();
+			int wV = p->rect().width();
+			int hV = p->rect().height();
+			if (hV > 0 && wV > 0)
+			{
+				drawPixmap(qp, p->rect().x(), p->rect().y(), m_buffer, xV, yV,  wV, hV);
+#if DRAW_DEBUG_LINES
+//				qDebug() << "normal rendering" << xV << yV << wV << hV << "at" << p->rect().x() << p->rect().y();
+				qp.setPen(Qt::blue);
+				qp.drawLine(p->rect().x(), p->rect().y(), p->rect().x() + p->rect().width(), p->rect().y() + p->rect().height());
+				qp.drawLine(p->rect().x() + p->rect().width(), p->rect().y(), p->rect().x(), p->rect().y() + p->rect().height());
+#endif
+			}
+		}
+#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
+			t3 = t.elapsed();
+			t.start();
+#endif
+			if (m_doc->appMode != modeNormal)
+			{
+				qp.save();
+				qp.scale(m_viewMode.scale, m_viewMode.scale);
+				qp.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
+				drawControls( &qp );
+				qp.restore();
+			}	
+#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
+			t4 = t.elapsed();
+			t.start();
+#endif			
+			break;
+		case RENDER_BUFFERED:
+		{
+#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
+			dmode = "BUFFER";
+			t1 = t.elapsed();
+			t.start();
+#endif
+				int xV = p->rect().x() - m_bufferRect.x();
+				int yV = p->rect().y() - m_bufferRect.y();
+				int wV = p->rect().width();
+				int hV = p->rect().height();
+				if (xV < 0)
+				{
+					wV += xV;
+					xV = 0;
+				}
+				if (yV < 0)
+				{
+					hV += yV;
+					yV = 0;
+				}
+#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
+				t2 = t.elapsed();
+				t.start();
+#endif
+				if (hV > 0 && wV > 0)
+				{
+					drawPixmap(qp, p->rect().x(), p->rect().y(), m_buffer, xV, yV,  wV, hV);
+	#if DRAW_DEBUG_LINES
+//					qDebug() << "buffered rendering" << xV << yV << wV << hV << "at" << p->rect().x() << p->rect().y();
+					qp.setPen(Qt::green);
+					qp.drawLine(p->rect().x(), p->rect().y(), p->rect().x() + p->rect().width(), p->rect().y() + p->rect().height());
+					qp.drawLine(p->rect().x() + p->rect().width(), p->rect().y(), p->rect().x(), p->rect().y() + p->rect().height());
+	#endif
+				}
+#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
+				t3 = t.elapsed();
+				t.start();
+#endif
+				if (m_doc->appMode != modeNormal)
+				{
+					qp.save();
+					qp.scale(m_viewMode.scale, m_viewMode.scale);
+					qp.translate(-m_doc->minCanvasCoordinate.x(), -m_doc->minCanvasCoordinate.y());
+					drawControls( &qp );
+					qp.restore();
+				}
+#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
+				t4 = t.elapsed();
+				t.start();
+#endif
+			}
+			break;
+		case RENDER_SELECTION_SEPARATE:
+			break;
+		case RENDER_SELECTION_BUFFERED:
+			break;
+		case RENDER_LEGACY:
+		default:
+			assert (false);
+	}
+	
+#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
+	t5 = t.elapsed();
+	t.start();
+#endif
+	// does mode specific rendering, currently selection in legacymode and nodes in nodeedit
+	m_view->m_canvasMode->drawControls(&qp);
+	m_view->m_canvasMode->drawSnapLine(&qp);
+#ifdef SHOW_ME_WHAT_YOU_GET_IN_D_CANVA
+	t6 = t.elapsed();
+	qDebug()<<dmode<<t1<<t2<<t3<<t4<<t5<<t6<<"-" <<t1+t2+t3+t4+t5+t6;
+#endif
+	m_viewMode.forceRedraw = false;
+	m_viewMode.operItemSelecting = false;
+	m_viewMode.operTextSelecting = false;
+}
+
+
+void Canvas::drawContents(QPainter *psx, int clipx, int clipy, int clipw, int cliph)
+{
+//	int Tsetup, Toutlines , Tbackground, Tcontents;
+//	Toutlines=0;
+//	QTime tim;
+//	tim.start();
+// 	qDebug() << "Canvas::drawContents" << clipx << clipy << clipw << cliph<<m_viewMode.forceRedraw<<m_viewMode.operItemSelecting;
+	int docPagesCount = m_doc->Pages->count();
+	ScPainter *painter = nullptr;
+	QImage img(clipw * devicePixelRatioF(), cliph * devicePixelRatioF(), QImage::Format_ARGB32_Premultiplied);
+	img.setDevicePixelRatio(devicePixelRatioF());
+	painter = new ScPainter(&img, img.width(), img.height(), 1.0, 0);
+	painter->clear(PrefsManager::instance().appPrefs.displayPrefs.scratchColor);	
+	painter->newPath();
+	painter->moveTo(0, 0);
+	painter->lineTo(clipw, 0);
+	painter->lineTo(clipw, cliph);
+	painter->lineTo(0, cliph);
+	painter->closePath();
+	painter->setClipPath();
+	painter->translate(-clipx, -clipy);
+	painter->setZoomFactor(m_viewMode.scale);
+	painter->translate(-m_doc->minCanvasCoordinate.x(), -m_doc->minCanvasCoordinate.y());
+	painter->setLineWidth(1);
+	painter->setFillMode(ScPainter::Solid);
+
+	ScLayer layer;
+	layer.isViewable = false;
+	layer.ID = 0;
+
+	if (!m_doc->masterPageMode())
+	{
+		drawBackgroundPageOutlines(painter, clipx, clipy, clipw, cliph);
+		m_viewMode.linkedFramesToShow.clear();
+		QRectF clip(clipx, clipy, clipw, cliph);
+		DrawPageBorder(painter, clip);
+		if (m_viewMode.viewAsPreview)
+		{
+			FPointArray PoLine;
+			getClipPathForPages(&PoLine);
+			painter->beginLayer(1.0, 0, &PoLine);
+		}
+		else
+			painter->beginLayer(1.0, 0);
+		int renderStackCount = m_doc->guidesPrefs().renderStackOrder.count();
+		for (int r = 0; r < renderStackCount; r++)
+		{
+			int ri = m_doc->guidesPrefs().renderStackOrder[r];
+			if (ri == 0)
+			{
+				if (!m_viewMode.viewAsPreview)
+					DrawPageMargins(painter, clip);			// drawing stack id = 0
+			}
+			else if (ri == 1)
+			{
+				if (!m_viewMode.viewAsPreview)
+					DrawPageBaselineGrid(painter, clip);	// drawing stack id = 1
+			}
+			else if (ri == 2)
+			{
+				if (!m_viewMode.viewAsPreview)
+					DrawPageGrid(painter, clip);			// drawing stack id = 2
+			}
+			else if (ri == 3)
+			{
+				if (!m_viewMode.viewAsPreview)
+					DrawPageGuides(painter, clip);			// drawing stack id = 3
+			}
+			else if (ri == 4)
+			{
+				int layerCount = m_doc->layerCount();	// drawing stack id = 4
+				for (int layerLevel = 0; layerLevel < layerCount; ++layerLevel)
+				{
+					m_doc->Layers.levelToLayer(layer, layerLevel);
+					for (int a = 0; a < docPagesCount; ++a)
+					{
+						DrawMasterItems(painter, m_doc->Pages->at(a), layer, QRect(clipx, clipy, clipw, cliph));
+					}
+					//first pass draws all except notes frames
+					DrawPageItems(painter, layer, QRect(clipx, clipy, clipw, cliph), false);
+					//second only for notes frames
+					DrawPageItems(painter, layer, QRect(clipx, clipy, clipw, cliph), true);
+				}
+			}
+		}
+		if (!m_viewMode.viewAsPreview)
+			DrawPageIndicator(painter, clip);
+		painter->endLayer();
+	}
+	else // masterPageMode
+	{			
+		m_viewMode.linkedFramesToShow.clear();
+		drawBackgroundMasterpage(painter, clipx, clipy, clipw, cliph);
+		painter->beginLayer(1.0, 0);
+		QRectF clip(clipx, clipy, clipw, cliph);
+		DrawPageBorder(painter, clip, true);
+		int renderStackCount = m_doc->guidesPrefs().renderStackOrder.count();
+		for (int r = 0; r < renderStackCount; r++)
+		{
+			int ri = m_doc->guidesPrefs().renderStackOrder[r];
+			if (ri == 0)
+			{
+				DrawPageMargins(painter, clip, true);			// drawing stack id = 0
+			}
+			else if (ri == 1)
+			{
+				DrawPageBaselineGrid(painter, clip, true);	// drawing stack id = 1
+			}
+			else if (ri == 2)
+			{
+				DrawPageGrid(painter, clip, true);			// drawing stack id = 2
+			}
+			else if (ri == 3)
+			{
+				DrawPageGuides(painter, clip, true);			// drawing stack id = 3
+			}
+			else if (ri == 4)
+			{
+				int layerCount = m_doc->layerCount();	// drawing stack id = 4
+				for (int layerLevel = 0; layerLevel < layerCount; ++layerLevel)
+				{
+					m_doc->Layers.levelToLayer(layer, layerLevel);
+					//first pass draws all except notes frames
+					DrawPageItems(painter, layer, QRect(clipx, clipy, clipw, cliph), false);
+					//second pass draw only notes frames
+					DrawPageItems(painter, layer, QRect(clipx, clipy, clipw, cliph), true);
+				}
+			}
+		}
+		DrawPageIndicator(painter, clip, true);
+		painter->endLayer();
+	}
+	if (((m_doc->m_Selection->count() != 0) || (m_viewMode.linkedFramesToShow.count() != 0))  && (!m_viewMode.viewAsPreview))
+	{
+		drawFrameLinks(painter);
+	}
+	painter->end();
+	psx->drawImage(clipx, clipy, img);
+	delete painter;
+	painter = nullptr;
+// 	qDebug( "Time elapsed: %d ms, setup=%d, outlines=%d, background=%d, contents=%d, rest=%d", tim.elapsed(), Tsetup,Toutlines -Tsetup, Tbackground-Toutlines, Tcontents-Tbackground, tim.elapsed() - Tcontents );
+}
+
+void Canvas::drawControls(QPainter *psx)
+{
+	psx->save();
+	if ((m_doc->appMode == modeDrawBezierLine) && (!m_viewMode.redrawPolygon.isEmpty()) && (m_doc->m_Selection->count() != 0))
+	{
+		drawControlsBezierCurve(psx, m_doc->m_Selection->itemAt(0));
+	}
+	if (m_viewMode.m_MouseButtonPressed && (m_doc->appMode == modeMeasurementTool))
+	{
+		drawControlsMeasurementLine(psx);
+	}
+	if (m_viewMode.m_MouseButtonPressed && (m_doc->appMode == modeDrawLine))
+	{
+		drawControlsDrawLine(psx);
+	}
+	if (m_viewMode.operItemMoving || m_viewMode.operItemResizing)
+	{
+		if (m_viewMode.operItemResizing)
+		{
+			if (!m_viewMode.redrawPolygon.isEmpty())
+			{
+				if (m_viewMode.m_MouseButtonPressed && ((m_doc->appMode == modeDrawFreehandLine) || (m_doc->appMode == modeDrawCalligraphicLine)))
+				{
+					drawControlsFreehandLine(psx);
+				}
+				else if (m_doc->appMode != modeDrawFreehandLine)
+				{
+//					qDebug() << "XXX drawControls - operItemResizing";
+					assert(false);
+//					drawControlsHighlightRect(psx);
+				}
+			}
+		}
+		else
+		{
+			drawControlsMovingItemsRect(psx);
+		}
+	}
+	else
+	{
+		if ((m_doc->m_Selection->count() != 0) && (m_doc->appMode != modeDrawBezierLine))
+		{
+//			drawControlsSelection(psx, m_doc->m_Selection->itemAt(0));
+			/*
+			 PageItem *currItem = m_doc->m_Selection->itemAt(0);
+			 if ((m_doc->appMode == modeEditClip) && (currItem->isSelected()))
+			 {
+				 drawControlsNodeEditPoints(psx, currItem);
+			 }
+			 else
+			 {
+				 drawControlsSelectionSpecial(psx, currItem);
+			 }*/
+		}
+	}
+	psx->restore();
+}	
+
+
+
+/**
+ 
+*/
+void Canvas::drawControlsMovingItemsRect(QPainter* pp)
+{
+	int selectedItemCount = m_doc->m_Selection->count();
+	if (selectedItemCount <= 0)
+		return;
+		
+	PageItem *currItem = nullptr;
+	if (selectedItemCount >= moveWithBoxesOnlyThreshold)
+	{
+		double gx, gy, gw, gh;
+		m_doc->m_Selection->getGroupRect(&gx, &gy, &gw, &gh);
+		pp->translate(gx, gy);
+		pp->drawRect(QRectF(0.0, 0.0, gw, gh));
+		return;
+	}
+
+	for (int cu = 0; cu < selectedItemCount; cu++)
+	{
+		currItem = m_doc->m_Selection->itemAt(cu);
+		pp->save();
+		pp->translate(currItem->xPos(), currItem->yPos());
+		pp->rotate(currItem->rotation());							
+		pp->setBrush(Qt::NoBrush);
+		pp->setPen(QPen(Qt::black, 1.0 / m_viewMode.scale, Qt::DotLine, Qt::FlatCap, Qt::MiterJoin));
+		if (currItem->isGroup())
+		{
+			PageItem_Group* gItem = currItem->asGroupFrame();
+			pp->scale(gItem->width() / gItem->groupWidth, gItem->height() / gItem->groupHeight);
+			int itemCountG = gItem->groupItemList.count();
+			if (itemCountG < moveWithFullOutlinesThreshold)
+			{
+				for (int cg = 0; cg < itemCountG; cg++)
+				{
+					currItem = gItem->groupItemList.at(cg);
+					if (!(currItem->isLine()))
+						currItem->DrawPolyL(pp, currItem->Clip);
+					else
+					{
+						if (currItem->isLine())
+						{
+							int lw2 = 1;
+							int lw = 1;
+							Qt::PenCapStyle le = Qt::FlatCap;
+							if (currItem->NamedLStyle.isEmpty())
+							{
+								if (currItem->lineColor() != CommonStrings::None)
+								{
+									lw2 = qRound(currItem->lineWidth()  / 2.0);
+									lw = qRound(qMax(currItem->lineWidth(), 1.0));
+								}
+								le = currItem->PLineEnd;
+							}
+							else
+							{
+								MultiLine ml = m_doc->docLineStyles[currItem->NamedLStyle];
+								lw2 = qRound(ml[ml.size()-1].Width  / 2.0);
+								lw = qRound(qMax(ml[ml.size()-1].Width, 1.0));
+								le = static_cast<Qt::PenCapStyle>(ml[ml.size()-1].LineEnd);
+							}
+							if (le != Qt::FlatCap)
+								pp->drawRect(-lw2, -lw2, qRound(currItem->width())+lw, lw);
+							else
+								pp->drawRect(-1, -lw2, qRound(currItem->width()), lw);
+						}
+					}
+				}
+			}
+		}
+		else if (selectedItemCount < moveWithFullOutlinesThreshold)
+		{
+			if (!currItem->asLine())
+				currItem->DrawPolyL(pp, currItem->Clip);
+			else
+			{
+				int lw2 = 1;
+				int lw = 1;
+				Qt::PenCapStyle le = Qt::FlatCap;
+				if (currItem->NamedLStyle.isEmpty())
+				{
+					if (currItem->lineColor() != CommonStrings::None)
+					{
+						lw2 = qRound(currItem->lineWidth()  / 2.0);
+						lw = qRound(qMax(currItem->lineWidth(), 1.0));
+					}
+					le = currItem->PLineEnd;
+				}
+				else
+				{
+					MultiLine ml = m_doc->docLineStyles[currItem->NamedLStyle];
+					lw2 = qRound(ml[ml.size()-1].Width  / 2.0);
+					lw = qRound(qMax(ml[ml.size()-1].Width, 1.0));
+					le = static_cast<Qt::PenCapStyle>(ml[ml.size()-1].LineEnd);
+				}
+				if (le != Qt::FlatCap)
+					pp->drawRect(-lw2, -lw2, qRound(currItem->width())+lw, lw);
+				else
+					pp->drawRect(-1, -lw2, qRound(currItem->width()), lw);
+			}
+		}
+		else
+			pp->drawRect(0, 0, static_cast<int>(currItem->width())+1, static_cast<int>(currItem->height())+1);
+		pp->restore();
+	}
+}
+
+/**
+  draws the bezier curve in edit bezier mode
+  */
+void Canvas::drawControlsBezierCurve(QPainter* pp, PageItem* currItem)
+{
+	pp->setBrush(Qt::NoBrush);
+	pp->setPen(QPen(Qt::black, 1.0 / m_viewMode.scale, Qt::DotLine, Qt::FlatCap, Qt::MiterJoin));
+	pp->translate(static_cast<int>(currItem->xPos()), static_cast<int>(currItem->yPos()));
+	pp->rotate(currItem->rotation());
+	QPainterPath Bez;
+	if (currItem->PoLine.size() > 1)
+	{
+		QPoint nXY = m_viewMode.redrawPolygon.point(0);
+		if (!m_viewMode.m_MouseButtonPressed)
+		{
+			FPoint a1 = currItem->PoLine.point(currItem->PoLine.size()-2);
+			FPoint a2 = currItem->PoLine.point(currItem->PoLine.size()-1);
+			Bez.moveTo(a1.x(), a1.y());
+			Bez.cubicTo(a2.x(), a2.y(), nXY.x(), nXY.y(), nXY.x(), nXY.y());
+			pp->drawPath(Bez);
+		}
+		else
+		{
+			FPoint a2 = currItem->PoLine.point(currItem->PoLine.size()-1);
+			if (currItem->PoLine.size() > 2)
+			{
+				FPoint a1 = currItem->PoLine.point(currItem->PoLine.size()-2);
+				FPoint a3 = currItem->PoLine.point(currItem->PoLine.size()-3);
+				Bez.moveTo(a3.x(), a3.y());
+				Bez.cubicTo(a1.x(), a1.y(), nXY.x(), nXY.y(), a2.x(), a2.y());
+				pp->drawPath(Bez);
+			}
+			pp->drawLine(QPoint(qRound(a2.x()), qRound(a2.y())), nXY);
+		}
+	}
+	else
+	{
+		QPoint a2 = currItem->PoLine.pointQ(currItem->PoLine.size()-1);
+		QPoint nXY = m_viewMode.redrawPolygon.point(0);
+		pp->drawLine(a2, nXY);
+	}
+	m_viewMode.redrawPolygon.clear();
+}
+
+
+
+
+/**
+  draws the measurement line in measure mode
+ */
+void Canvas::drawControlsMeasurementLine(QPainter* pp)
+{
+	pp->setBrush(Qt::NoBrush);
+	pp->setPen(QPen(Qt::black, 1.0, Qt::DotLine, Qt::FlatCap, Qt::MiterJoin));
+	pp->drawPolyline(m_viewMode.redrawPolygon);
+	m_viewMode.redrawPolygon.clear();
+}
+
+
+/**
+  draws the line in drawline mode
+ */
+void Canvas::drawControlsDrawLine(QPainter* pp)
+{
+	pp->setBrush(Qt::NoBrush);
+	pp->setPen(QPen(Qt::black, 1.0 / m_viewMode.scale, Qt::DotLine, Qt::FlatCap, Qt::MiterJoin));
+	pp->drawPolyline(m_viewMode.redrawPolygon);
+	m_viewMode.redrawPolygon.clear();
+}
+
+
+/**
+  draws the freehand curve in freehand mode
+ */
+void Canvas::drawControlsFreehandLine(QPainter* pp)
+{
+	pp->setBrush(Qt::NoBrush);
+	pp->setPen(QPen(Qt::black, 1.0 / m_viewMode.scale, Qt::DotLine, Qt::FlatCap, Qt::MiterJoin));
+	pp->drawPolyline(m_viewMode.redrawPolygon);
+	m_viewMode.redrawPolygon.clear();
+}
+
+
+/**
+  draws masterpage items of a specific layer
+ */
+void Canvas::DrawMasterItems(ScPainter *painter, ScPage *page, ScLayer& layer, QRect clip)
+{
+	if ((m_viewMode.previewMode) && (!layer.isPrintable))
+		return;
+	if ((m_viewMode.viewAsPreview) && (!layer.isPrintable))
+		return;
+	if (!layer.isViewable)
+		return;
+	if (page->masterPageNameEmpty())
+		return;
+	if (page->FromMaster.count() <= 0)
+		return;
+
+	FPoint orig = localToCanvas(clip.topLeft());
+	QRectF cullingArea(static_cast<int>(orig.x()), static_cast<int>(orig.y()), 
+	                   qRound(clip.width() / m_viewMode.scale + 0.5), qRound(clip.height() / m_viewMode.scale + 0.5));
+
 	PageItem *currItem;
 	ScPage* Mp = m_doc->MasterPages.at(m_doc->MasterNames[page->masterPageName()]);
-	int layerCount = m_doc->layerCount();
 	if (((layer.blendMode != 0) || (layer.transparency != 1.0)) && (!layer.outlineMode))
 		painter->beginLayer(layer.transparency, layer.blendMode);
 	int pageFromMasterCount = page->FromMaster.count();
 	for (int a = 0; a < pageFromMasterCount; ++a)
-	{
-		currItem = page->FromMaster.at(a);
-		if (currItem->m_layerID != layer.ID)
-			continue;
-		if ((currItem->OwnPage != -1) && (currItem->OwnPage != static_cast<int>(Mp->pageNr())))
-			continue;
-		if ((m_viewMode.previewMode) && (!currItem->printEnabled()))
-			continue;
-		if ((m_viewMode.viewAsPreview) && (!currItem->printEnabled()))
-			continue;
-		double oldX = currItem->xPos();
-		double oldY = currItem->yPos();
-		double oldBX = currItem->BoundingX;
-		double oldBY = currItem->BoundingY;
-		if (!currItem->ChangedMasterItem)
-		{
-			//Hack to not check for undo changes, indicate drawing only
-			currItem->moveBy(-Mp->xOffset() + page->xOffset(), -Mp->yOffset() + page->yOffset(), true);
-			currItem->BoundingX = oldBX - Mp->xOffset() + page->xOffset();
-			currItem->BoundingY = oldBY - Mp->yOffset() + page->yOffset();
-		}
-		// Save PageItem's OwnPage and set its value to page number
-		// so that page number placed in text frames can work, also modify
-		// OwnPage of items embedded inside groups for same reason
-		currItem->savedOwnPage = currItem->OwnPage;
-		currItem->OwnPage = page->pageNr();
-		if (currItem->isGroup())
-		{
-			PageItem_Group *groupItem = currItem->asGroupFrame();
-			PageItemIterator itemIt(groupItem->groupItemList, PageItemIterator::IterateInGroups);
-			for ( ; *itemIt; ++itemIt)
-			{
-				PageItem* item = *itemIt;
-				item->savedOwnPage = item->OwnPage;
-				item->OwnPage = page->pageNr();
-			}
-		}
-		if (cullingArea.intersects(currItem->getBoundingRect().adjusted(0.0, 0.0, 1.0, 1.0)))
-		{
-			if (!((m_viewMode.operItemMoving) && (currItem->isSelected())))
-			{
-				if (m_viewMode.forceRedraw)
-					currItem->invalidateLayout();
-				currItem->DrawObj(painter, cullingArea);
-				currItem->DrawObj_Decoration(painter);
-			}
-//			else 
-//				qDebug() << "skip masterpage item (move/resizeEdit/selected)" << m_viewMode.operItemMoving << currItem->isSelected();
-		}
-		// Restore items' OwnPage including those of item embedded inside groups 
-		if (currItem->isGroup())
-		{
-			PageItem_Group *groupItem = currItem->asGroupFrame();
-			PageItemIterator itemIt(groupItem->groupItemList, PageItemIterator::IterateInGroups);
-			for ( ; *itemIt; ++itemIt)
-			{
-				PageItem* item = *itemIt;
-				item->OwnPage = item->savedOwnPage;
-			}
-		}
-		currItem->OwnPage = currItem->savedOwnPage;
-		if (!currItem->ChangedMasterItem)
-		{
-			//Hack to not check for undo changes, indicate drawing only
-			currItem->setXYPos(oldX, oldY, true);
-			currItem->BoundingX = oldBX;
+	{
+		currItem = page->FromMaster.at(a);
+		if (currItem->m_layerID != layer.ID)
+			continue;
+		if ((currItem->OwnPage != -1) && (currItem->OwnPage != static_cast<int>(Mp->pageNr())))
+			continue;
+		if ((m_viewMode.previewMode) && (!currItem->printEnabled()))
+			continue;
+		if ((m_viewMode.viewAsPreview) && (!currItem->printEnabled()))
+			continue;
+		double oldX = currItem->xPos();
+		double oldY = currItem->yPos();
+		double oldBX = currItem->BoundingX;
+		double oldBY = currItem->BoundingY;
+		if (!currItem->ChangedMasterItem)
+		{
+			//Hack to not check for undo changes, indicate drawing only
+			currItem->moveBy(-Mp->xOffset() + page->xOffset(), -Mp->yOffset() + page->yOffset(), true);
+			currItem->BoundingX = oldBX - Mp->xOffset() + page->xOffset();
+			currItem->BoundingY = oldBY - Mp->yOffset() + page->yOffset();
+		}
+		// Save PageItem's OwnPage and set its value to page number
+		// so that page number placed in text frames can work, also modify
+		// OwnPage of items embedded inside groups for same reason
+		currItem->savedOwnPage = currItem->OwnPage;
+		currItem->OwnPage = page->pageNr();
+		if (currItem->isGroup())
+		{
+			PageItem_Group *groupItem = currItem->asGroupFrame();
+			PageItemIterator itemIt(groupItem->groupItemList, PageItemIterator::IterateInGroups);
+			for ( ; *itemIt; ++itemIt)
+			{
+				PageItem* item = *itemIt;
+				item->savedOwnPage = item->OwnPage;
+				item->OwnPage = page->pageNr();
+			}
+		}
+		if (cullingArea.intersects(currItem->getBoundingRect().adjusted(0.0, 0.0, 1.0, 1.0)))
+		{
+			if (!((m_viewMode.operItemMoving) && (currItem->isSelected())))
+			{
+				if (m_viewMode.forceRedraw)
+					currItem->invalidateLayout();
+				currItem->DrawObj(painter, cullingArea);
+				currItem->DrawObj_Decoration(painter);
+			}
+//			else 
+//				qDebug() << "skip masterpage item (move/resizeEdit/selected)" << m_viewMode.operItemMoving << currItem->isSelected();
+		}
+		// Restore items' OwnPage including those of item embedded inside groups 
+		if (currItem->isGroup())
+		{
+			PageItem_Group *groupItem = currItem->asGroupFrame();
+			PageItemIterator itemIt(groupItem->groupItemList, PageItemIterator::IterateInGroups);
+			for ( ; *itemIt; ++itemIt)
+			{
+				PageItem* item = *itemIt;
+				item->OwnPage = item->savedOwnPage;
+			}
+		}
+		currItem->OwnPage = currItem->savedOwnPage;
+		if (!currItem->ChangedMasterItem)
+		{
+			//Hack to not check for undo changes, indicate drawing only
+			currItem->setXYPos(oldX, oldY, true);
+			currItem->BoundingX = oldBX;
 			currItem->BoundingY = oldBY;
 		}
 	}
@@ -1413,97 +1412,96 @@ void Canvas::DrawMasterItems(ScPainter *
 		painter->endLayer();
 }
 
-
-/**
-  draws page items contained in a specific Layer
- */
-void Canvas::DrawPageItems(ScPainter *painter, ScLayer& layer, QRect clip, bool notesFramesPass)
-{
-	if ((m_viewMode.previewMode) && (!layer.isPrintable))
-		return;
-	if ((m_viewMode.viewAsPreview) && (!layer.isPrintable))
-		return;
-	if (!layer.isViewable)
-		return;
-	if (m_doc->Items->count() <= 0)
-		return;
-
-// 	qDebug()<<"Canvas::DrawPageItems"<<m_viewMode.forceRedraw<<m_viewMode.operItemSelecting;
-	FPoint orig = localToCanvas(clip.topLeft());
-	QRectF cullingArea (static_cast<int>(orig.x()), static_cast<int>(orig.y()), 
-	                    qRound(clip.width() / m_viewMode.scale + 0.5), qRound(clip.height() / m_viewMode.scale + 0.5));
-
-	PageItem *currItem;
-	int layerCount = m_doc->layerCount();
+
+/**
+  draws page items contained in a specific Layer
+ */
+void Canvas::DrawPageItems(ScPainter *painter, ScLayer& layer, QRect clip, bool notesFramesPass)
+{
+	if ((m_viewMode.previewMode) && (!layer.isPrintable))
+		return;
+	if ((m_viewMode.viewAsPreview) && (!layer.isPrintable))
+		return;
+	if (!layer.isViewable)
+		return;
+	if (m_doc->Items->count() <= 0)
+		return;
+
+// 	qDebug()<<"Canvas::DrawPageItems"<<m_viewMode.forceRedraw<<m_viewMode.operItemSelecting;
+	FPoint orig = localToCanvas(clip.topLeft());
+	QRectF cullingArea (static_cast<int>(orig.x()), static_cast<int>(orig.y()), 
+	                    qRound(clip.width() / m_viewMode.scale + 0.5), qRound(clip.height() / m_viewMode.scale + 0.5));
+
+	PageItem *currItem;
 	int docCurrPageNo = m_doc->currentPageNumber();
 	if (((layer.blendMode != 0) || (layer.transparency != 1.0)) && (!layer.outlineMode))
 		painter->beginLayer(layer.transparency, layer.blendMode);
 
-	//if notes are used
-	//then we must be sure that text frames are valid and all notes frames are created before we start drawing
-	if (!notesFramesPass && !m_doc->notesList().isEmpty())
-	{
-		for (auto it = m_doc->Items->begin(); it != m_doc->Items->end(); ++it)
-		{
-			PageItem* currItem = *it;
-			if ( !currItem->isTextFrame()
-				|| currItem->isNoteFrame()
-				|| !currItem->invalid
-				|| (currItem->m_layerID != layer.ID)
-				|| (m_viewMode.previewMode && !currItem->printEnabled())
-				|| (m_viewMode.viewAsPreview && (!currItem->printEnabled()))
-				|| (m_doc->masterPageMode() && ((currItem->OwnPage != -1) && (currItem->OwnPage != docCurrPageNo)))
-				|| ((!m_doc->masterPageMode() && !currItem->OnMasterPage.isEmpty()) && (currItem->OnMasterPage != m_doc->currentPage()->pageName())))
-				continue;
-			if (cullingArea.intersects(currItem->getBoundingRect().adjusted(0.0, 0.0, 1.0, 1.0)))
-				currItem->layout();
-		}
-	}
-	for (int it = 0; it < m_doc->Items->count(); ++it)
-	{
-		currItem = m_doc->Items->at(it);
-		if (notesFramesPass && !currItem->isNoteFrame())
-			continue;
-		if (!notesFramesPass && currItem->isNoteFrame())
-			continue;
-		if (currItem->m_layerID != layer.ID)
-			continue;
-		if ((m_viewMode.previewMode) && (!currItem->printEnabled()))
-			continue;
-		if ((m_viewMode.viewAsPreview) && (!currItem->printEnabled()))
-			continue;
-		if ((m_doc->masterPageMode()) && ((currItem->OwnPage != -1) && (currItem->OwnPage != docCurrPageNo)))
-			continue;
-		if (!m_doc->masterPageMode() && !currItem->OnMasterPage.isEmpty())
-		{
-			if (currItem->OnMasterPage != m_doc->currentPage()->pageName())
-				continue;
-		}
-		if (cullingArea.intersects(currItem->getBoundingRect().adjusted(0.0, 0.0, 1.0, 1.0)))
-		{
-			if ((m_viewMode.operItemMoving || m_viewMode.drawSelectedItemsWithControls) && currItem->isSelected())
-			{
-//					qDebug() << "skipping pageitem (move/resizeEdit/selected)" << m_viewMode.operItemMoving << currItem->isSelected();
-			}
-			else if (m_viewMode.operItemSelecting)
-			{
-				currItem->invalid = false;
-				currItem->DrawObj(painter, cullingArea);
-				currItem->DrawObj_Decoration(painter);
-			}
-			else
-			{
-				// I comment it because the "view" should not
-				// alter the "data". And it really prevents optimisation - pm
-// 				if (m_viewMode.forceRedraw)
-// 					currItem->invalidateLayout();
-				currItem->DrawObj(painter, cullingArea);
-				currItem->DrawObj_Decoration(painter);
-			}
-			getLinkedFrames(currItem);
-			if ((m_doc->appMode == modeEdit) && (currItem->isSelected()) && (currItem->itemType() == PageItem::TextFrame))
-			{
-				setupEditHRuler(currItem);
+	//if notes are used
+	//then we must be sure that text frames are valid and all notes frames are created before we start drawing
+	if (!notesFramesPass && !m_doc->notesList().isEmpty())
+	{
+		for (auto it = m_doc->Items->begin(); it != m_doc->Items->end(); ++it)
+		{
+			PageItem* currItem = *it;
+			if ( !currItem->isTextFrame()
+				|| currItem->isNoteFrame()
+				|| !currItem->invalid
+				|| (currItem->m_layerID != layer.ID)
+				|| (m_viewMode.previewMode && !currItem->printEnabled())
+				|| (m_viewMode.viewAsPreview && (!currItem->printEnabled()))
+				|| (m_doc->masterPageMode() && ((currItem->OwnPage != -1) && (currItem->OwnPage != docCurrPageNo)))
+				|| ((!m_doc->masterPageMode() && !currItem->OnMasterPage.isEmpty()) && (currItem->OnMasterPage != m_doc->currentPage()->pageName())))
+				continue;
+			if (cullingArea.intersects(currItem->getBoundingRect().adjusted(0.0, 0.0, 1.0, 1.0)))
+				currItem->layout();
+		}
+	}
+	for (int it = 0; it < m_doc->Items->count(); ++it)
+	{
+		currItem = m_doc->Items->at(it);
+		if (notesFramesPass && !currItem->isNoteFrame())
+			continue;
+		if (!notesFramesPass && currItem->isNoteFrame())
+			continue;
+		if (currItem->m_layerID != layer.ID)
+			continue;
+		if ((m_viewMode.previewMode) && (!currItem->printEnabled()))
+			continue;
+		if ((m_viewMode.viewAsPreview) && (!currItem->printEnabled()))
+			continue;
+		if ((m_doc->masterPageMode()) && ((currItem->OwnPage != -1) && (currItem->OwnPage != docCurrPageNo)))
+			continue;
+		if (!m_doc->masterPageMode() && !currItem->OnMasterPage.isEmpty())
+		{
+			if (currItem->OnMasterPage != m_doc->currentPage()->pageName())
+				continue;
+		}
+		if (cullingArea.intersects(currItem->getBoundingRect().adjusted(0.0, 0.0, 1.0, 1.0)))
+		{
+			if ((m_viewMode.operItemMoving || m_viewMode.drawSelectedItemsWithControls) && currItem->isSelected())
+			{
+//					qDebug() << "skipping pageitem (move/resizeEdit/selected)" << m_viewMode.operItemMoving << currItem->isSelected();
+			}
+			else if (m_viewMode.operItemSelecting)
+			{
+				currItem->invalid = false;
+				currItem->DrawObj(painter, cullingArea);
+				currItem->DrawObj_Decoration(painter);
+			}
+			else
+			{
+				// I comment it because the "view" should not
+				// alter the "data". And it really prevents optimisation - pm
+// 				if (m_viewMode.forceRedraw)
+// 					currItem->invalidateLayout();
+				currItem->DrawObj(painter, cullingArea);
+				currItem->DrawObj_Decoration(painter);
+			}
+			getLinkedFrames(currItem);
+			if ((m_doc->appMode == modeEdit) && (currItem->isSelected()) && (currItem->itemType() == PageItem::TextFrame))
+			{
+				setupEditHRuler(currItem);
 			}
 		}
 	}
@@ -1511,1041 +1509,1041 @@ void Canvas::DrawPageItems(ScPainter *pa
 		painter->endLayer();
 }
 
-/**
-  Draws the canvas background for masterpages, incl. bleeds
- */
-void Canvas::drawBackgroundMasterpage(ScPainter* painter, int clipx, int clipy, int clipw, int cliph)
-{
-	const ScPage* currentPage = m_doc->currentPage();
-	double x = currentPage->xOffset() * m_viewMode.scale;
-	double y = currentPage->yOffset() * m_viewMode.scale;
-	double w = currentPage->width() * m_viewMode.scale;
-	double h = currentPage->height() * m_viewMode.scale;
-	QRectF drawRect(x, y, w + 5, h + 5);
-	drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
-	if (!drawRect.intersects(QRectF(clipx, clipy, clipw, cliph)))
-		return;
-
-	painter->setFillMode(ScPainter::Solid);
-	painter->setBrush(QColor(128,128,128));
-	MarginStruct pageBleeds;
-	if (!m_doc->bleeds()->isNull() && m_doc->guidesPrefs().showBleed)
-		m_doc->getBleeds(currentPage, pageBleeds);
-	double px = currentPage->xOffset() - pageBleeds.left();
-	double py = currentPage->yOffset() - pageBleeds.top();
-	double pw = currentPage->width() + pageBleeds.left() + pageBleeds.right();
-	double ph = currentPage->height() + pageBleeds.bottom() + pageBleeds.top();
-	painter->setAntialiasing(false);
-	painter->setPen(Qt::black, 1 / m_viewMode.scale, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
-	if (PrefsManager::instance().appPrefs.displayPrefs.showPageShadow)
-		painter->drawRect(px + 5, py + 5, pw, ph);
-	painter->setBrush(m_doc->paperColor());
-	painter->drawRect(px, py, pw, ph);
-	painter->setAntialiasing(true);
-}
-
-
-
-/**
-  draws the page outlines on canvas, including bleed area
- */
-void Canvas::drawBackgroundPageOutlines(ScPainter* painter, int clipx, int clipy, int clipw, int cliph)
-{
-	int docPagesCount = m_doc->Pages->count();
-	if (PrefsManager::instance().appPrefs.displayPrefs.showPageShadow)
-	{
-		painter->setBrush(QColor(128,128,128));
-		painter->setAntialiasing(false);
-		painter->setPen(Qt::black, 1.0 / m_viewMode.scale, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
-		ScPage *actPg;
-		MarginStruct pageBleeds;
-		for (int a = 0; a < static_cast<int>(docPagesCount); ++a)
-		{
-			actPg = m_doc->Pages->at(a);
-			m_doc->getBleeds(actPg, pageBleeds);
-			if (m_viewMode.viewAsPreview)
-				pageBleeds.resetToZero();
-			double blx = (actPg->xOffset() - pageBleeds.left()) * m_viewMode.scale;
-			double bly = (actPg->yOffset() - pageBleeds.top()) * m_viewMode.scale;
-			double blw = (actPg->width() + pageBleeds.left() + pageBleeds.right()) * m_viewMode.scale;
-			double blh = (actPg->height() + pageBleeds.bottom() + pageBleeds.top()) * m_viewMode.scale;
-			
-			QRectF drawRect(blx - 1, bly - 1, blw + 6, blh + 6);
-			drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
-			if (drawRect.intersects(QRectF(clipx, clipy, clipw, cliph)))
-			{
-				painter->setFillMode(ScPainter::Solid);
-				double blx2 = actPg->xOffset();
-				double bly2 = actPg->yOffset();
-				double blw2 = actPg->width();
-				double blh2 = actPg->height();
-				if (m_doc->guidesPrefs().showBleed)
-				{
-					blx2 -= pageBleeds.left();
-					bly2 -= pageBleeds.top();
-					blw2 += pageBleeds.left() + pageBleeds.right();
-					blh2 += pageBleeds.bottom() + pageBleeds.top();
-				}
-				painter->drawRect(blx2 + 5, bly2 + 5, blw2, blh2);
-				if (!m_doc->bleeds()->isNull() && m_doc->guidesPrefs().showBleed)
-				{
-					painter->setFillMode(ScPainter::None);
-					painter->setPen(Qt::black, 1.0 / m_viewMode.scale, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
-					painter->drawRect(blx2 - 1 / m_viewMode.scale, bly2 - 1 / m_viewMode.scale, blw2 + 2 / m_viewMode.scale, blh2 + 2 / m_viewMode.scale);
-				}
-			}
-		}
-		painter->setAntialiasing(true);
-	}
-	painter->setFillMode(ScPainter::Solid);
-	ScPage *actPg;
-	MarginStruct pageBleeds;
-	for (int a = 0; a < static_cast<int>(docPagesCount); ++a)
-	{
-		actPg = m_doc->Pages->at(a);
-		double x = actPg->xOffset();
-		double y = actPg->yOffset();
-		double w = actPg->width();
-		double h = actPg->height();
-		bool drawBleed = false;
-		if (!m_doc->bleeds()->isNull() && m_doc->guidesPrefs().showBleed)
-		{
-			drawBleed = true;
-			m_doc->getBleeds(a, pageBleeds);
-		}
-		else
-			pageBleeds.resetToZero();
-		double blx = (actPg->xOffset() - pageBleeds.left()) * m_viewMode.scale;
-		double bly = (actPg->yOffset() - pageBleeds.top()) * m_viewMode.scale;
-		double blw = (actPg->width() + pageBleeds.left() + pageBleeds.right()) * m_viewMode.scale;
-		double blh = (actPg->height() + pageBleeds.bottom() + pageBleeds.top()) * m_viewMode.scale;
-		
-		QRectF drawRect(blx, bly, blw+5, blh+5);
-		drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
-		if (drawRect.intersects(QRectF(clipx, clipy, clipw, cliph)))
-		{
-			painter->setFillMode(ScPainter::Solid);
-			painter->setPen(Qt::black, 0, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
-			painter->setAntialiasing(false);
-			painter->setLineWidth(0.0);
-			painter->setBrush(m_doc->paperColor());
-			if (!m_viewMode.viewAsPreview)
-			{
-				double blx2 = actPg->xOffset() - pageBleeds.left();
-				double bly2 = actPg->yOffset() - pageBleeds.top();
-				double blw2 = actPg->width() + pageBleeds.left() + pageBleeds.right();
-				double blh2 = actPg->height() + pageBleeds.bottom() + pageBleeds.top();
-				painter->drawRect(blx2, bly2, blw2, blh2);
-				if (drawBleed)
-					painter->drawRect(x, y, w, h);
-			}
-			else
-				painter->drawRect(x, y, w, h);
-			painter->setAntialiasing(true);
-		}
-	}
-}
-
-void Canvas::getLinkedFrames(PageItem* currItem)
-{
-	if (currItem->isGroup())
-	{
-		for (int em = 0; em < currItem->groupItemList.count(); ++em)
-		{
-			PageItem* embedded = currItem->groupItemList.at(em);
-			getLinkedFrames(embedded);
-		}
-
-	}
-	else if ((currItem->isTextFrame()) && ((currItem->nextInChain() != nullptr) || (currItem->prevInChain() != nullptr)))
-	{
-		PageItem *nextItem = currItem;
-		while (nextItem != nullptr)
-		{
-			if (nextItem->prevInChain() != nullptr)
-				nextItem = nextItem->prevInChain();
-			else
-				break;
-		}
-		if (!m_viewMode.linkedFramesToShow.contains(nextItem))
-			m_viewMode.linkedFramesToShow.append(nextItem);
-	}
-}
-
-/**
- fills PoLine with a clippath for the doc pages
- */
-void Canvas::getClipPathForPages(FPointArray* PoLine)
-{
-	PoLine->resize(0);
-	bool first = true;
-	ScPage *actPg;
-	
-	int firstPage = 0;
-	int lastPage  = m_doc->Pages->count();
-	if (m_doc->Pages == &m_doc->MasterPages)
-	{
-		firstPage = m_doc->currentPage()->pageNr();
-		lastPage  = firstPage + 1;
-	}
-
-	for (int i = firstPage; i < lastPage; ++i)
-	{
-		if (!first)
-			PoLine->setMarker();
-		first = false;
-		actPg = m_doc->Pages->at(i);
-		double x = actPg->xOffset();
-		double y = actPg->yOffset();
-		double w = actPg->width();
-		double h = actPg->height();
-		static double rect[] = {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0,
-			1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0,
-			0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0};
-		for (int j = 0; j < 29; j += 4)
-		{
-			PoLine->addPoint(x + w * rect[j], y + h * rect[j+1]);
-			PoLine->addPoint(x + w * rect[j+2], y + h * rect[j+3]);
-		}
-	}
-}
-
-/**
-  draws page border
-  */
-void Canvas::DrawPageBorderSub(ScPainter *p, ScPage *page)
-{
-	p->save();
-	p->setAntialiasing(false);
-	p->translate(page->xOffset(), page->yOffset());
-	double lineWidth = 1.0 / m_viewMode.scale;
-	double pageHeight = page->height();
-	double pageWidth = page->width();
-	p->setFillMode(ScPainter::None);
-	p->setStrokeMode(ScPainter::Solid);
-	p->setPen(Qt::black, lineWidth, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
-	p->drawRect(0, 0, pageWidth, pageHeight);
-	p->setAntialiasing(true);
-	p->restore();
-}
-
-void Canvas::DrawPageBorder(ScPainter *p, const QRectF& clip, bool master)
-{
-	if (master)
-	{
-		ScPage *page = m_doc->currentPage();
-		double x = m_doc->scratch()->left() * m_viewMode.scale;
-		double y = m_doc->scratch()->top() * m_viewMode.scale;
-		double w = page->width() * m_viewMode.scale;
-		double h = page->height() * m_viewMode.scale;
-		QRectF drawRect(x, y, w + 5, h + 5);
-		drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
-		if (drawRect.intersects(clip))
-			DrawPageBorderSub(p, page);
-	}
-	else
-	{
-		int docPagesCount = m_doc->Pages->count();
-		for (int a = 0; a < docPagesCount; ++a)
-		{
-			ScPage *page = m_doc->Pages->at(a);
-			QRectF drawRect(page->xOffset() * m_viewMode.scale, page->yOffset() * m_viewMode.scale, page->width() * m_viewMode.scale + 5, page->height() * m_viewMode.scale + 5);
-			drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
-			if (drawRect.intersects(clip))
-				DrawPageBorderSub(p, page);
-		}
-	}
-}
-
-/**
-  draws margins
- */
-void Canvas::DrawPageMarginsGridSub(ScPainter *p, ScPage *page)
-{
-	p->save();
-	p->setAntialiasing(false);
-	p->translate(page->xOffset(), page->yOffset());
-	double lineWidth = 1.0 / m_viewMode.scale;
-	double pageHeight = page->height();
-	double pageWidth = page->width();
-	p->setFillMode(ScPainter::None);
-	p->setStrokeMode(ScPainter::Solid);
-	p->setPen(Qt::black, lineWidth, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
-	if (m_doc->guidesPrefs().marginsShown)
-	{
-		p->setPen(m_doc->guidesPrefs().marginColor);
-		if (m_doc->marginColored())
-		{
-			p->setFillMode(ScPainter::Solid);
-			p->setBrush(m_doc->guidesPrefs().marginColor);
-			p->drawRect(0, 0, pageWidth, page->Margins.top());
-			p->drawRect(0, page->Margins.top(), page->Margins.left(), pageHeight - page->Margins.top());
-			p->drawRect(page->Margins.left(), pageHeight - page->Margins.bottom(), pageWidth - page->Margins.right() - page->Margins.left(), page->Margins.bottom());
-			p->drawRect(pageWidth - page->Margins.right(), page->Margins.top(), page->Margins.right(), pageHeight-page->Margins.top());
-			p->setFillMode(ScPainter::None);
-		}
-		p->setFillMode(ScPainter::None);
-		p->drawRect(page->Margins.left(), page->Margins.top(), pageWidth - page->Margins.left() - page->Margins.right(), pageHeight - page->Margins.top() - page->Margins.bottom());
-	}
-	p->setAntialiasing(true);
-	p->restore();
-}
-
-void Canvas::DrawPageMargins(ScPainter *p, const QRectF& clip, bool master)
-{
-	if (master)
-	{
-		ScPage *page = m_doc->currentPage();
-		double x = m_doc->scratch()->left() * m_viewMode.scale;
-		double y = m_doc->scratch()->top() * m_viewMode.scale;
-		double w = page->width() * m_viewMode.scale;
-		double h = page->height() * m_viewMode.scale;
-		QRectF drawRect(x, y, w + 5, h + 5);
-		drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
-		if (drawRect.intersects(clip))
-			DrawPageMarginsGridSub(p, page);
-	}
-	else
-	{
-		int docPagesCount = m_doc->Pages->count();
-		for (int a = 0; a < docPagesCount; ++a)
-		{
-			ScPage *page = m_doc->Pages->at(a);
-			QRectF drawRect(page->xOffset() * m_viewMode.scale, page->yOffset() * m_viewMode.scale, page->width() * m_viewMode.scale + 5, page->height() * m_viewMode.scale + 5);
-			drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
-			if (drawRect.intersects(clip))
-				DrawPageMarginsGridSub(p, page);
-		}
-	}
-}
-
-/**
-  draws baseline grid
- */
-void Canvas::DrawPageBaselineGridSub(ScPainter *p, ScPage *page)
-{
-	if (!m_doc->guidesPrefs().baselineGridShown)
-		return;
-
-	p->save();
-	p->setAntialiasing(false);
-	p->translate(page->xOffset(), page->yOffset());
-	double lineWidth = 1.0 / m_viewMode.scale;
-	double pageHeight = page->height();
-	double pageWidth = page->width();
-	p->setFillMode(ScPainter::None);
-	p->setStrokeMode(ScPainter::Solid);
-	p->setPen(m_doc->guidesPrefs().baselineGridColor, lineWidth, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
-	for (double yg = m_doc->guidesPrefs().offsetBaselineGrid; yg < pageHeight; yg += m_doc->guidesPrefs().valueBaselineGrid)
-		p->drawLine(FPoint(0, yg), FPoint(pageWidth, yg));
-	p->setAntialiasing(true);
-	p->restore();
-}
-
-void Canvas::DrawPageBaselineGrid(ScPainter *p, const QRectF& clip, bool master)
-{
-	if (!m_doc->guidesPrefs().baselineGridShown)
-		return;
-
-	if (master)
-	{
-		ScPage *page = m_doc->currentPage();
-		double x = m_doc->scratch()->left() * m_viewMode.scale;
-		double y = m_doc->scratch()->top() * m_viewMode.scale;
-		double w = page->width() * m_viewMode.scale;
-		double h = page->height() * m_viewMode.scale;
-		QRectF drawRect(x, y, w + 5, h + 5);
-		drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
-		if (drawRect.intersects(clip))
-			DrawPageBaselineGridSub(p, page);
-	}
-	else
-	{
-		int docPagesCount = m_doc->Pages->count();
-		for (int a = 0; a < docPagesCount; ++a)
-		{
-			ScPage *page = m_doc->Pages->at(a);
-			QRectF drawRect(page->xOffset() * m_viewMode.scale, page->yOffset() * m_viewMode.scale, page->width() * m_viewMode.scale + 5, page->height() * m_viewMode.scale + 5);
-			drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
-			if (drawRect.intersects(clip))
-				DrawPageBaselineGridSub(p, page);
-		}
-	}
-}
-
-/**
-  draws grid
- */
-void Canvas::DrawPageGridSub(ScPainter *p, ScPage *page, const QRectF& clip)
-{
-	if (!m_doc->guidesPrefs().gridShown)
-		return;
-
-	p->save();
-	FPointArray PoLine;
-	getClipPathForPages(&PoLine);
-	p->beginLayer(1.0, 0, &PoLine);
-	p->setAntialiasing(false);
-	p->translate(page->xOffset(), page->yOffset());
-	double lineWidth = 1.0 / m_viewMode.scale;
-	double pageHeight = page->height();
-	double pageWidth = page->width();
-	p->setFillMode(ScPainter::None);
-	p->setStrokeMode(ScPainter::Solid);
-	p->setPen(Qt::black, lineWidth, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
-
-	double lowerBx = qMax(clip.x() / m_viewMode.scale + m_doc->minCanvasCoordinate.x() - page->xOffset(), 0.0);
-	double lowerBy = qMax(clip.y() / m_viewMode.scale + m_doc->minCanvasCoordinate.y() - page->yOffset(), 0.0);
-	double highBx = qMin(lowerBx + clip.width() / m_viewMode.scale, pageWidth);
-	double highBy = qMin(lowerBy + clip.height() / m_viewMode.scale, pageHeight);
-	if (m_viewMode.scale > 0.49)
-	{
-		if (m_doc->guidesPrefs().gridType == 0)
-		{
-			double i,start;
-			i = m_doc->guidesPrefs().majorGridSpacing;
-			p->setPen(m_doc->guidesPrefs().majorGridColor, lineWidth, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
-			start = floor(lowerBy / i);
-			start *= i;
-			for (double b = start; b <= highBy; b += i)
-			{
-				p->drawLine(FPoint(qMax(lowerBx, 0.0), b), FPoint(qMin(pageWidth, highBx), b));
-			}
-			start = floor(lowerBx / i);
-			start *= i;
-			for (double b = start; b <= highBx; b += i)
-			{
-				p->drawLine(FPoint(b, qMax(lowerBy, 0.0)), FPoint(b, qMin(pageHeight, highBy)));
-			}
-			i = m_doc->guidesPrefs().minorGridSpacing;
-			p->setPen(m_doc->guidesPrefs().minorGridColor, lineWidth, Qt::DotLine, Qt::FlatCap, Qt::MiterJoin);
-			start = floor(lowerBy / i);
-			start *= i;
-			for (double b = start; b <= highBy; b += i)
-			{
-				p->drawLine(FPoint(qMax(lowerBx, 0.0), b), FPoint(qMin(pageWidth, highBx), b));
-			}
-			start = floor(lowerBx / i);
-			start *= i;
-			for (double b = start; b <= highBx; b += i)
-			{
-				p->drawLine(FPoint(b, qMax(lowerBy, 0.0)), FPoint(b, qMin(pageHeight, highBy)));
-			}
-		}
-		else if (m_doc->guidesPrefs().gridType == 1)
-		{
-			double i, startX, startY;
-			i = m_doc->guidesPrefs().minorGridSpacing;
-			p->setPen(m_doc->guidesPrefs().minorGridColor, 3.0 / m_viewMode.scale, Qt::SolidLine, Qt::RoundCap, Qt::MiterJoin);
-			startY = floor(lowerBy / i);
-			startY *= i;
-			startX = floor(lowerBx / i);
-			startX *= i;
-			for (double b = startY; b <= highBy; b += i)
-			{
-				for (double bb = startX; bb <= highBx; bb += i)
-				{
-					p->drawLine(FPoint(bb, b), FPoint(bb, b));
-				}
-			}
-			i = m_doc->guidesPrefs().majorGridSpacing;
-			p->setPen(m_doc->guidesPrefs().majorGridColor, lineWidth * 2, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
-			startY = floor(lowerBy / i);
-			startY *= i;
-			startX = floor(lowerBx / i);
-			startX *= i;
-			for (double b = startY; b <= highBy; b += i)
-			{
-				for (double bb = startX; bb <= highBx; bb += i)
-				{
-					p->drawLine(FPoint(bb - 4, b), FPoint(bb + 4, b));
-					p->drawLine(FPoint(bb, b - 4), FPoint(bb, b + 4));
-				}
-			}
-		}
-	}
-
-	p->setAntialiasing(true);
-	p->endLayer();
-	p->restore();
-}
-
-void Canvas::DrawPageGrid(ScPainter *p, const QRectF& clip, bool master)
-{
-	if (!m_doc->guidesPrefs().gridShown)
-		return;
-
-	if (master)
-	{
-		ScPage *page = m_doc->currentPage();
-		double x = m_doc->scratch()->left() * m_viewMode.scale;
-		double y = m_doc->scratch()->top() * m_viewMode.scale;
-		double w = page->width() * m_viewMode.scale;
-		double h = page->height() * m_viewMode.scale;
-		QRectF drawRect(x, y, w + 5, h + 5);
-		drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
-		if (drawRect.intersects(clip))
-			DrawPageGridSub(p, page, clip);
-	}
-	else
-	{
-		int docPagesCount = m_doc->Pages->count();
-		for (int a = 0; a < docPagesCount; ++a)
-		{
-			ScPage *page = m_doc->Pages->at(a);
-			QRectF drawRect(page->xOffset() * m_viewMode.scale, page->yOffset() * m_viewMode.scale, page->width() * m_viewMode.scale + 5, page->height() * m_viewMode.scale + 5);
-			drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
-			if (drawRect.intersects(clip))
-				DrawPageGridSub(p, page, clip);
-		}
-	}
-}
-
-/**
-  draws guides
- */
-void Canvas::DrawPageGuidesSub(ScPainter *p, ScPage *page)
-{
-	if (!m_doc->guidesPrefs().guidesShown)
-		return;
-
-	p->save();
-	p->setAntialiasing(false);
-	p->translate(page->xOffset(), page->yOffset());
-	double lineWidth = 1.0 / m_viewMode.scale;
-	p->setFillMode(ScPainter::None);
-	p->setStrokeMode(ScPainter::Solid);
-	p->setPen(Qt::black, lineWidth, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
-	page->guides.drawPage(p, m_doc, lineWidth);
-	p->setAntialiasing(true);
-	p->restore();
-}
-
-void Canvas::DrawPageGuides(ScPainter *p, const QRectF& clip, bool master)
-{
-	if (!m_doc->guidesPrefs().guidesShown)
-		return;
-
-	if (master)
-	{
-		ScPage *page = m_doc->currentPage();
-		double x = m_doc->scratch()->left() * m_viewMode.scale;
-		double y = m_doc->scratch()->top() * m_viewMode.scale;
-		double w = page->width() * m_viewMode.scale;
-		double h = page->height() * m_viewMode.scale;
-		QRectF drawRect(x, y, w + 5, h + 5);
-		drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
-		if (drawRect.intersects(clip))
-			DrawPageGuidesSub(p, page);
-	}
-	else
-	{
-		int docPagesCount = m_doc->Pages->count();
-		for (int a = 0; a < docPagesCount; ++a)
-		{
-			ScPage *page = m_doc->Pages->at(a);
-			QRectF drawRect(page->xOffset() * m_viewMode.scale, page->yOffset() * m_viewMode.scale, page->width() * m_viewMode.scale + 5, page->height() * m_viewMode.scale + 5);
-			drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
-			if (drawRect.intersects(clip))
-				DrawPageGuidesSub(p, page);
-		}
-	}
-}
-
-/**
-  draws actual page indicator frame
- */
-void Canvas::DrawPageIndicatorSub(ScPainter *p, ScPage *page)
-{
-	p->save();
-	int fm = p->fillMode();
-	p->setAntialiasing(false);
-	p->translate(page->xOffset(), page->yOffset());
-	double lineWidth = 1.0 / m_viewMode.scale;
-	double pageHeight = page->height();
-	double pageWidth = page->width();
-	p->setFillMode(ScPainter::None);
-	p->setStrokeMode(ScPainter::Solid);
-	p->setPen(Qt::black, lineWidth, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
-	p->setPen(PrefsManager::instance().appPrefs.displayPrefs.pageBorderColor, 1 / m_viewMode.scale, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
-	p->drawRect(0, 0, pageWidth, pageHeight);
-	p->setAntialiasing(true);
-	p->setFillMode(fm);
-	p->restore();
-}
-
-void Canvas::DrawPageIndicator(ScPainter *p, const QRectF& clip, bool master)
-{
-	if (master)
-	{
-		ScPage *page = m_doc->currentPage();
-		double x = m_doc->scratch()->left() * m_viewMode.scale;
-		double y = m_doc->scratch()->top() * m_viewMode.scale;
-		double w = page->width() * m_viewMode.scale;
-		double h = page->height() * m_viewMode.scale;
-		QRectF drawRect(x, y, w + 5, h + 5);
-		drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
-		if (drawRect.intersects(clip))
-			DrawPageIndicatorSub(p, page);
-	}
-	else
-	{
-		int docPagesCount = m_doc->Pages->count();
-		for (int a = 0; a < docPagesCount; ++a)
-		{
-			ScPage *page = m_doc->Pages->at(a);
-			if (page == m_doc->currentPage())
-			{
-				QRectF drawRect(page->xOffset() * m_viewMode.scale, page->yOffset() * m_viewMode.scale, page->width() * m_viewMode.scale + 5, page->height() * m_viewMode.scale + 5);
-				drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
-				if (drawRect.intersects(clip))
-					DrawPageIndicatorSub(p, page);
-			}
-		}
-	}
-}
-
-/**
-  draws the links between textframe chains.
-  needs the list of visible textframes in m_viewMode.linkedFramesToShow
- */
-void Canvas::drawFrameLinks(ScPainter* painter)
-{
-	PageItem *currItem = nullptr;
-	if ((m_doc->appMode == modeLinkFrames) || (m_doc->appMode == modeUnlinkFrames))
-	{
-		if (m_doc->m_Selection->count() > 0)
-			currItem = m_doc->m_Selection->itemAt(0);
-		else if (m_viewMode.linkedFramesToShow.count() > 0)
-			currItem = m_viewMode.linkedFramesToShow.at(0);
-		if (currItem && (currItem->itemType() != PageItem::TextFrame))
-			currItem = nullptr;
-	}
-
-	//Draw the frame links
-	painter->save();
-	if (m_doc->guidesPrefs().linkShown || m_viewMode.drawFramelinksWithContents)
-	{
-		for (int i = 0; i < m_viewMode.linkedFramesToShow.count(); ++i)
-		{
-			PageItem* nextItem = m_viewMode.linkedFramesToShow.at(i);
-			while (nextItem != nullptr)
-			{
-				if (nextItem->nextInChain() != nullptr)
-				{
-					FPoint start, end;
-					calculateFrameLinkPoints(nextItem, nextItem->nextInChain(), start, end);
-					drawLinkFrameLine(painter, start, end);
-				}
-				nextItem = nextItem->nextInChain();
-			}
-		}
-	}
-	else if ((((m_doc->appMode == modeLinkFrames) || (m_doc->appMode == modeUnlinkFrames)) && (currItem != nullptr)))
-	{
-		PageItem *nextItem = currItem->firstInChain();
-		while (nextItem != nullptr)
-		{
-			if (nextItem->nextInChain() != nullptr)
-			{
-				FPoint start, end;
-				calculateFrameLinkPoints(nextItem, nextItem->nextInChain(), start, end);
-				drawLinkFrameLine(painter, start, end);
-			}
-			nextItem = nextItem->nextInChain();
-		}
-	}
-	painter->setLineWidth(1);
-	painter->setPenOpacity(1.0);
-	painter->restore();
-}
-
-
-/**
-  draws one linkline between textframes
-  */
-void Canvas::drawLinkFrameLine(ScPainter* painter, FPoint &start, FPoint &end)
-{
-	//CB FIXME Add some checking that the painter is setup?
-	Q_ASSERT(painter != nullptr);
-	painter->setPen(Qt::black, 1.0 / m_viewMode.scale, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
-	painter->setPenOpacity(1.0);
-	painter->drawLine(start, end);
-	QTransform arrowTrans;
-	arrowTrans.translate(end.x(), end.y());
-	double r = atan2(end.y()-start.y(), end.x()-start.x())*(180.0/M_PI);
-	arrowTrans.rotate(r);
-	double sc = 0.8 / m_viewMode.scale;
-	arrowTrans.scale(sc, sc);
-	FPointArray arrow;
-	arrow.addQuadPoint(-12, 0, -12, 0, -12, 0, -12, 0);
-	arrow.addQuadPoint(-15, -5, -15, -5, -15, -5, -15, -5);
-	arrow.addQuadPoint(0, 0, 0, 0, 0, 0, 0, 0);
-	arrow.addQuadPoint(-15, 5, -15, 5, -15, 5, -15, 5);
-	arrow.addQuadPoint(-12, 0, -12, 0, -12, 0, -12, 0);
-	arrow.map(arrowTrans);
-	painter->setBrush(painter->pen());
-	painter->setBrushOpacity(1.0);
-	painter->setLineWidth(0);
-	painter->setFillMode(ScPainter::Solid);
-	painter->setupPolygon(&arrow);
-	painter->fillPath();
-}
-
-
-
-/**
-  this is a wrapper around repaint()
- */
-void Canvas::PaintSizeRect(QRect newRect)
-{
-	static QRect oldRect;
-	if (!newRect.isNull())
-	{
-		if (!oldRect.isNull())
-			newRect = newRect.united(oldRect);
-		repaint(newRect.adjusted(-10, -10, 20, 20));
-	}
-	oldRect = newRect;
-}
-
-
-/// ???
-void Canvas::PaintSizeRect(QPolygon newRect)
-{
-	static QRect oldRect;
-	QRect newR = newRect.boundingRect();
-	if (!newR.isNull())
-	{
-		if (!oldRect.isNull())
-			newRect = newRect.united(oldRect);
-		m_viewMode.redrawPolygon = newRect;
-		repaint(newR.adjusted(-20, -20, 40, 40));
-	}
-	oldRect = newR;
-}
-
-void Canvas::getGroupRectScreen(double *x, double *y, double *w, double *h)
-{
-	double gx, gy, gh, gw;
-	m_doc->m_Selection->getGroupRect(&gx, &gy, &gw, &gh);
-	QPoint in(qRound(gx* m_viewMode.scale), qRound(gy* m_viewMode.scale));
-//	in -= QPoint(qRound(m_doc->minCanvasCoordinate.x() * m_viewMode.scale), qRound(m_doc->minCanvasCoordinate.y() * m_viewMode.scale));
-	QPoint out = contentsToViewport(in);
-	*x = static_cast<double>(out.x());
-	*y = static_cast<double>(out.y());
-	*w = gw* m_viewMode.scale;
-	*h = gh* m_viewMode.scale;
-}
-
-
-void Canvas::Transform(PageItem *currItem, QPainter *p)
-{
-	p->translate(currItem->xPos()*m_viewMode.scale, currItem->yPos()*m_viewMode.scale);
-	p->scale(m_viewMode.scale, m_viewMode.scale);
-	p->rotate(currItem->rotation());
-}
-
-void Canvas::Transform(PageItem *currItem, QTransform& m)
-{
-	m.translate(currItem->xPos()*m_viewMode.scale, currItem->yPos()*m_viewMode.scale);
-	m.scale(m_viewMode.scale, m_viewMode.scale);
-	m.rotate(currItem->rotation());
-}
-
-void Canvas::TransformM(PageItem *currItem, QPainter *p)
-{
-	if (currItem->imageFlippedH())
-	{
-		p->translate(currItem->width(), 0);
-		p->scale(-1, 1);
-	}
-	if (currItem->imageFlippedV())
-	{
-		p->translate(0, currItem->height());
-		p->scale(1, -1);
-	}
-}
-
-void Canvas::calculateFrameLinkPoints(PageItem *pi1, PageItem *pi2, FPoint & start, FPoint & end)
-{
-	if (pi1 == nullptr || pi2 == nullptr)
-		return;
-	//Calculate the link points of the frames
-	double x11 = pi1->xPos();
-	double y11 = pi1->yPos();
-	double x12 = x11 + pi1->width();
-	double y12 = y11 + pi1->height();
-	if (pi1->isGroupChild())
-	{
-		QTransform itemTrans = pi1->getTransform();
-		QPointF itPos = itemTrans.map(QPointF(0, 0));
-		x11 = itPos.x();
-		y11 = itPos.y();
-		double grScXi = 1.0;
-		double grScYi = 1.0;
-		getScaleFromMatrix(itemTrans, grScXi, grScYi);
-		if (itemTrans.m11() < 0)
-			x11 -= pi1->width() * grScXi;
-		if (itemTrans.m22() < 0)
-			y11 -= pi1->height() * grScYi;
-		x12 = x11 + pi1->width() * grScXi;
-		y12 = y11 + pi1->height() * grScYi;
-	}
-	double x1mid = x11 + (x12 - x11) / 2.0;
-	double y1mid = y11 + (y12 - y11) / 2.0;
-					
-	if (pi1->rotation()!=0.000)
-	{
-		FPoint tempPoint(0,0, x11, y11, pi1->rotation(), 1, 1);
-		x11 = tempPoint.x();
-		y11 = tempPoint.y();
-		FPoint tempPoint2(0, 0, x12, y12, pi1->rotation(), 1, 1);
-		x12 = tempPoint2.x();
-		y12 = tempPoint2.y();
-		FPoint tempPoint3(0, 0, x1mid, y1mid, pi1->rotation(), 1, 1);
-		x1mid = tempPoint3.x();
-		y1mid = tempPoint3.y();
-	}
-					
-					
-	double a1, b1, a2, b2;
-	a1 = a2 = b1 = b2 = 0;
-	double x21 = pi2->xPos();
-	double y21 = pi2->yPos();
-	double x22 = x21 + pi2->width();
-	double y22 = y21 + pi2->height();
-	if (pi2->isGroupChild())
-	{
-		QTransform itemTrans = pi2->getTransform();
-		QPointF itPos = itemTrans.map(QPointF(0, 0));
-		x21 = itPos.x();
-		y21 = itPos.y();
-		double grScXi = 1.0;
-		double grScYi = 1.0;
-		getScaleFromMatrix(itemTrans, grScXi, grScYi);
-		if (itemTrans.m11() < 0)
-			x21 -= pi2->width() * grScXi;
-		if (itemTrans.m22() < 0)
-			y11 -= pi2->height() * grScYi;
-		x22 = x21 + pi2->width() * grScXi;
-		y22 = y21 + pi2->height() * grScYi;
-	}
-
-	double x2mid = x21 + (x22 - x21) / 2.0;
-	double y2mid = y21 + (y22 - y21) / 2.0;
-					
-	if (pi2->rotation()!=0.000)
-	{
-		FPoint tempPoint(0,0, x21, y21, pi2->rotation(), 1, 1);
-		x21 = tempPoint.x();
-		y21 = tempPoint.y();
-		FPoint tempPoint2(0, 0, x22, y22, pi2->rotation(), 1, 1);
-		x22 = tempPoint2.x();
-		y22 = tempPoint2.y();
-		FPoint tempPoint3(0, 0, x2mid, y2mid, pi2->rotation(), 1, 1);
-		x2mid = tempPoint3.x();
-		y2mid = tempPoint3.y();
-	}
-					
-	if (x22 < x11) { a1 = x11; a2 = x22; }
-	if (x21 > x12) { a1 = x12; a2 = x21; }
-	if (y22 < y11) { b1 = y11; b2 = y22; }
-	if (y21 > y12) { b1 = y12; b2 = y21; }
-
-	if (x21 < x12 && x21 > x11) { a1 = x1mid; a2 = x2mid; }
-	if (x21 < x11 && x22 > x11) { a1 = x1mid; a2 = x2mid; }
-
-	if (y21 < y12 && y21 > y11) { b1 = y1mid; b2 = y2mid; }
-	if (y21 < y11 && y22 > y11) { b1 = y1mid; b2 = y2mid; }
-	
-	//When our points (in pt) are exactly the same, cover this too. #3634
-	if (x11 == x21) { a1 = x1mid; a2 = x2mid; }
-	if (y11 == y21) { b1 = y1mid; b2 = y2mid; }
-	
-	//Set the link frame lines' endpoints
-	start.setXY(a1-pi1->xPos(), b1-pi1->yPos());
-	start.transform(pi1->xPos(), pi1->yPos(), pi1->rotation(), 1, 1, false);
-	end.setXY(a2-pi2->xPos(), b2-pi2->yPos());
-	end.transform(pi2->xPos(), pi2->yPos(), pi2->rotation(), 1, 1, false);
-}
-
-QPixmap Canvas::createPixmap(double w, double h)
-{
-	QPixmap p(w * devicePixelRatioF(), h * devicePixelRatioF());
-	p.setDevicePixelRatio(devicePixelRatioF());
-	return p;
-}
-
-void Canvas::drawPixmap(QPainter& painter, double x, double y, const QPixmap& pixmap, double sx, double sy, double sw, double sh)
-{
-	sx *= devicePixelRatioF();
-	sy *= devicePixelRatioF();
-	sw *= devicePixelRatioF();
-	sh *= devicePixelRatioF();
-	painter.drawPixmap(x, y, pixmap, sx, sy, sw, sh);
-}
-
-void Canvas::displayXYHUD(QPoint m)
-{
-	if (!PrefsManager::instance().appPrefs.displayPrefs.showMouseCoordinates)
-		return;
-	double gx, gy, gh, gw, r;
-	if (m_doc->m_Selection->isMultipleSelection())
-	{
-		m_doc->m_Selection->getGroupRect(&gx, &gy, &gw, &gh);
-		r = 0.0;
-	}
-	else
-	{
-		PageItem* currItem = m_doc->m_Selection->itemAt(0);
-		gx = currItem->xPos();
-		gy = currItem->yPos();
-		gw = currItem->width();
-		gh = currItem->height();
-		r = currItem->rotation();
-	}
-	QTransform ma;
-	ma.translate(gx, gy);
-	ma.rotate(r);
-	FPoint n;
-	if (m_doc->rotationMode() == 0)
-		n = FPoint(0.0, 0.0);
-	else if (m_doc->rotationMode() == 1)
-		n = FPoint(gw, 0.0);
-	else if (m_doc->rotationMode() == 2)
-		n = FPoint(gw / 2.0, gh / 2.0);
-	else if (m_doc->rotationMode() == 3)
-		n = FPoint(0.0, gh);
-	else if (m_doc->rotationMode() == 4)
-		n = FPoint(gw, gh);
-	gx = ma.m11() * n.x() + ma.m21() * n.y() + ma.dx();
-	gy = ma.m22() * n.y() + ma.m12() * n.x() + ma.dy();
-	if (m_doc->guidesPrefs().rulerMode)
-	{
-		gx -= m_doc->currentPage()->xOffset();
-		gy -= m_doc->currentPage()->yOffset();
-	}
-	gx -= m_doc->rulerXoffset;
-	gy -= m_doc->rulerYoffset;
-	displayXYHUD(m, gx, gy);
-}
-
-void Canvas::displayCorrectedXYHUD(QPoint m, double x, double y)
-{
-	if (!PrefsManager::instance().appPrefs.displayPrefs.showMouseCoordinates)
-		return;
-	double gx = x;
-	double gy = y;
-	if (m_doc->guidesPrefs().rulerMode)
-	{
-		gx -= m_doc->currentPage()->xOffset();
-		gy -= m_doc->currentPage()->yOffset();
-	}
-	gx -= m_doc->rulerXoffset;
-	gy -= m_doc->rulerYoffset;
-	QToolTip::showText(m + QPoint(5, 5), tr("X: %1\nY: %2").arg(value2String(gx, m_doc->unitIndex(), true, true), value2String(gy, m_doc->unitIndex(), true, true)), this);
-}
-
-void Canvas::displayCorrectedSingleHUD(QPoint m, double val, bool isX)
-{
-	if (!PrefsManager::instance().appPrefs.displayPrefs.showMouseCoordinates)
-		return;
-	double gx = val;
-	if (isX)
-	{
-		if (m_doc->guidesPrefs().rulerMode)
-			gx -= m_doc->currentPage()->xOffset();
-		gx -= m_doc->rulerXoffset;
-		QToolTip::showText(m + QPoint(5, 5), tr("X: %1").arg(value2String(gx, m_doc->unitIndex(), true, true)), this);
-	}
-	else
-	{
-		if (m_doc->guidesPrefs().rulerMode)
-			gx -= m_doc->currentPage()->yOffset();
-		gx -= m_doc->rulerYoffset;
-		QToolTip::showText(m + QPoint(5, 5), tr("Y: %1").arg(value2String(gx, m_doc->unitIndex(), true, true)), this);
-	}
-}
-
-void Canvas::displayXYHUD(QPoint m, double x, double y)
-{
-	if (!PrefsManager::instance().appPrefs.displayPrefs.showMouseCoordinates)
-		return;
-	QToolTip::showText(m + QPoint(5, 5), tr("X: %1\nY: %2").arg(value2String(x, m_doc->unitIndex(), true, true), value2String(y, m_doc->unitIndex(), true, true)), this);
-}
-
-void Canvas::displaySizeHUD(QPoint m, double x, double y, bool isLine)
-{
-	if (!PrefsManager::instance().appPrefs.displayPrefs.showMouseCoordinates)
-		return;
-	if (isLine)
-		QToolTip::showText(m + QPoint(5, 5), tr("Length: %1\nAngle: %2").arg(value2String(x, m_doc->unitIndex(), true, true), value2String(y, SC_DEGREES, true, true)), this);
-	else
-		QToolTip::showText(m + QPoint(5, 5), tr("Width: %1\nHeight: %2").arg(value2String(x, m_doc->unitIndex(), true, true), value2String(y, m_doc->unitIndex(), true, true)), this);
-}
-
-void Canvas::displayRotHUD(QPoint m, double rot)
-{
-	if (!PrefsManager::instance().appPrefs.displayPrefs.showMouseCoordinates)
-		return;
-	double r;
-	if (rot < 0.0)
-		r = rot * -1.0;
-	else
-		r = 360.0 - rot;
-	QToolTip::showText(m + QPoint(5, 5), tr("Angle: %1").arg(value2String(r, SC_DEGREES, true, true)), this);
-}
-
-void Canvas::displayRealRotHUD(QPoint m, double rot)
-{
-	if (!PrefsManager::instance().appPrefs.displayPrefs.showMouseCoordinates)
-		return;
-	QToolTip::showText(m + QPoint(5, 5), tr("Angle: %1").arg(value2String(rot, SC_DEGREES, true, true)), this);
-}
-
-void Canvas::displayDoubleHUD(QPoint point, const QString& label, double value)
-{
-	if (!PrefsManager::instance().appPrefs.displayPrefs.showMouseCoordinates)
-		return;
-	QToolTip::showText(point + QPoint(5, 5), QString("%1: %2").arg(label, value2String(value, m_doc->unitIndex(), true, true)), this);
-}
-
-void Canvas::setupEditHRuler(PageItem * item, bool forceAndReset)
-{
-	static QString rulerItemRef;
-	static double rulerDumbHash(0.0);
-	
-	if ((rulerItemRef != item->itemName()) 
-		   || forceAndReset )
-	{
-		rulerItemRef = item->itemName();
-		rulerDumbHash = 0.0;
-	}
-	
-	double controlHash(0.0);
-	controlHash = item->xPos() 
-			+ item->yPos()				* 1.0
-			+ item->m_columnGap 				* 2.0
-			+ item->m_columns 				* 3.0
-			+ item->textToFrameDistLeft()		* 4.0 
-			+ item->textToFrameDistRight()		* 5.0
-			+ item->currentStyle().firstIndent()	* 6.0
-			+ item->currentStyle().leftMargin()	* 7.0
-			+ item->width()				* 8.0
-			+ item->currentStyle().rightMargin()	* 9.0
-			+ (item->imageFlippedH() ? 32.32 : 13.13);
-	
-	const ParagraphStyle& currParaStyle = item->currentStyle();
-	for (const ParagraphStyle::TabRecord& tabrec : currParaStyle.tabValues())
-	{
-		controlHash += tabrec.tabPosition;
-	}
-// 	qDebug()<<"Canvas::setupEditHRuler"<<rulerItemRef<<controlHash<<rulerDumbHash;
-	if (controlHash == rulerDumbHash)
-		return;
-	
-	rulerDumbHash = controlHash;
-	m_view->horizRuler->setItem(item);
-	m_view->horizRuler->update();
-}
+/**
+  Draws the canvas background for masterpages, incl. bleeds
+ */
+void Canvas::drawBackgroundMasterpage(ScPainter* painter, int clipx, int clipy, int clipw, int cliph)
+{
+	const ScPage* currentPage = m_doc->currentPage();
+	double x = currentPage->xOffset() * m_viewMode.scale;
+	double y = currentPage->yOffset() * m_viewMode.scale;
+	double w = currentPage->width() * m_viewMode.scale;
+	double h = currentPage->height() * m_viewMode.scale;
+	QRectF drawRect(x, y, w + 5, h + 5);
+	drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
+	if (!drawRect.intersects(QRectF(clipx, clipy, clipw, cliph)))
+		return;
+
+	painter->setFillMode(ScPainter::Solid);
+	painter->setBrush(QColor(128,128,128));
+	MarginStruct pageBleeds;
+	if (!m_doc->bleeds()->isNull() && m_doc->guidesPrefs().showBleed)
+		m_doc->getBleeds(currentPage, pageBleeds);
+	double px = currentPage->xOffset() - pageBleeds.left();
+	double py = currentPage->yOffset() - pageBleeds.top();
+	double pw = currentPage->width() + pageBleeds.left() + pageBleeds.right();
+	double ph = currentPage->height() + pageBleeds.bottom() + pageBleeds.top();
+	painter->setAntialiasing(false);
+	painter->setPen(Qt::black, 1 / m_viewMode.scale, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
+	if (PrefsManager::instance().appPrefs.displayPrefs.showPageShadow)
+		painter->drawRect(px + 5, py + 5, pw, ph);
+	painter->setBrush(m_doc->paperColor());
+	painter->drawRect(px, py, pw, ph);
+	painter->setAntialiasing(true);
+}
+
+
+
+/**
+  draws the page outlines on canvas, including bleed area
+ */
+void Canvas::drawBackgroundPageOutlines(ScPainter* painter, int clipx, int clipy, int clipw, int cliph)
+{
+	int docPagesCount = m_doc->Pages->count();
+	if (PrefsManager::instance().appPrefs.displayPrefs.showPageShadow)
+	{
+		painter->setBrush(QColor(128,128,128));
+		painter->setAntialiasing(false);
+		painter->setPen(Qt::black, 1.0 / m_viewMode.scale, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
+		ScPage *actPg;
+		MarginStruct pageBleeds;
+		for (int a = 0; a < static_cast<int>(docPagesCount); ++a)
+		{
+			actPg = m_doc->Pages->at(a);
+			m_doc->getBleeds(actPg, pageBleeds);
+			if (m_viewMode.viewAsPreview)
+				pageBleeds.resetToZero();
+			double blx = (actPg->xOffset() - pageBleeds.left()) * m_viewMode.scale;
+			double bly = (actPg->yOffset() - pageBleeds.top()) * m_viewMode.scale;
+			double blw = (actPg->width() + pageBleeds.left() + pageBleeds.right()) * m_viewMode.scale;
+			double blh = (actPg->height() + pageBleeds.bottom() + pageBleeds.top()) * m_viewMode.scale;
+			
+			QRectF drawRect(blx - 1, bly - 1, blw + 6, blh + 6);
+			drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
+			if (drawRect.intersects(QRectF(clipx, clipy, clipw, cliph)))
+			{
+				painter->setFillMode(ScPainter::Solid);
+				double blx2 = actPg->xOffset();
+				double bly2 = actPg->yOffset();
+				double blw2 = actPg->width();
+				double blh2 = actPg->height();
+				if (m_doc->guidesPrefs().showBleed)
+				{
+					blx2 -= pageBleeds.left();
+					bly2 -= pageBleeds.top();
+					blw2 += pageBleeds.left() + pageBleeds.right();
+					blh2 += pageBleeds.bottom() + pageBleeds.top();
+				}
+				painter->drawRect(blx2 + 5, bly2 + 5, blw2, blh2);
+				if (!m_doc->bleeds()->isNull() && m_doc->guidesPrefs().showBleed)
+				{
+					painter->setFillMode(ScPainter::None);
+					painter->setPen(Qt::black, 1.0 / m_viewMode.scale, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
+					painter->drawRect(blx2 - 1 / m_viewMode.scale, bly2 - 1 / m_viewMode.scale, blw2 + 2 / m_viewMode.scale, blh2 + 2 / m_viewMode.scale);
+				}
+			}
+		}
+		painter->setAntialiasing(true);
+	}
+	painter->setFillMode(ScPainter::Solid);
+	ScPage *actPg;
+	MarginStruct pageBleeds;
+	for (int a = 0; a < static_cast<int>(docPagesCount); ++a)
+	{
+		actPg = m_doc->Pages->at(a);
+		double x = actPg->xOffset();
+		double y = actPg->yOffset();
+		double w = actPg->width();
+		double h = actPg->height();
+		bool drawBleed = false;
+		if (!m_doc->bleeds()->isNull() && m_doc->guidesPrefs().showBleed)
+		{
+			drawBleed = true;
+			m_doc->getBleeds(a, pageBleeds);
+		}
+		else
+			pageBleeds.resetToZero();
+		double blx = (actPg->xOffset() - pageBleeds.left()) * m_viewMode.scale;
+		double bly = (actPg->yOffset() - pageBleeds.top()) * m_viewMode.scale;
+		double blw = (actPg->width() + pageBleeds.left() + pageBleeds.right()) * m_viewMode.scale;
+		double blh = (actPg->height() + pageBleeds.bottom() + pageBleeds.top()) * m_viewMode.scale;
+		
+		QRectF drawRect(blx, bly, blw+5, blh+5);
+		drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
+		if (drawRect.intersects(QRectF(clipx, clipy, clipw, cliph)))
+		{
+			painter->setFillMode(ScPainter::Solid);
+			painter->setPen(Qt::black, 0, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
+			painter->setAntialiasing(false);
+			painter->setLineWidth(0.0);
+			painter->setBrush(m_doc->paperColor());
+			if (!m_viewMode.viewAsPreview)
+			{
+				double blx2 = actPg->xOffset() - pageBleeds.left();
+				double bly2 = actPg->yOffset() - pageBleeds.top();
+				double blw2 = actPg->width() + pageBleeds.left() + pageBleeds.right();
+				double blh2 = actPg->height() + pageBleeds.bottom() + pageBleeds.top();
+				painter->drawRect(blx2, bly2, blw2, blh2);
+				if (drawBleed)
+					painter->drawRect(x, y, w, h);
+			}
+			else
+				painter->drawRect(x, y, w, h);
+			painter->setAntialiasing(true);
+		}
+	}
+}
+
+void Canvas::getLinkedFrames(PageItem* currItem)
+{
+	if (currItem->isGroup())
+	{
+		for (int em = 0; em < currItem->groupItemList.count(); ++em)
+		{
+			PageItem* embedded = currItem->groupItemList.at(em);
+			getLinkedFrames(embedded);
+		}
+
+	}
+	else if ((currItem->isTextFrame()) && ((currItem->nextInChain() != nullptr) || (currItem->prevInChain() != nullptr)))
+	{
+		PageItem *nextItem = currItem;
+		while (nextItem != nullptr)
+		{
+			if (nextItem->prevInChain() != nullptr)
+				nextItem = nextItem->prevInChain();
+			else
+				break;
+		}
+		if (!m_viewMode.linkedFramesToShow.contains(nextItem))
+			m_viewMode.linkedFramesToShow.append(nextItem);
+	}
+}
+
+/**
+ fills PoLine with a clippath for the doc pages
+ */
+void Canvas::getClipPathForPages(FPointArray* PoLine)
+{
+	PoLine->resize(0);
+	bool first = true;
+	ScPage *actPg;
+	
+	int firstPage = 0;
+	int lastPage  = m_doc->Pages->count();
+	if (m_doc->Pages == &m_doc->MasterPages)
+	{
+		firstPage = m_doc->currentPage()->pageNr();
+		lastPage  = firstPage + 1;
+	}
+
+	for (int i = firstPage; i < lastPage; ++i)
+	{
+		if (!first)
+			PoLine->setMarker();
+		first = false;
+		actPg = m_doc->Pages->at(i);
+		double x = actPg->xOffset();
+		double y = actPg->yOffset();
+		double w = actPg->width();
+		double h = actPg->height();
+		static double rect[] = {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0,
+			1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0,
+			0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0};
+		for (int j = 0; j < 29; j += 4)
+		{
+			PoLine->addPoint(x + w * rect[j], y + h * rect[j+1]);
+			PoLine->addPoint(x + w * rect[j+2], y + h * rect[j+3]);
+		}
+	}
+}
+
+/**
+  draws page border
+  */
+void Canvas::DrawPageBorderSub(ScPainter *p, ScPage *page)
+{
+	p->save();
+	p->setAntialiasing(false);
+	p->translate(page->xOffset(), page->yOffset());
+	double lineWidth = 1.0 / m_viewMode.scale;
+	double pageHeight = page->height();
+	double pageWidth = page->width();
+	p->setFillMode(ScPainter::None);
+	p->setStrokeMode(ScPainter::Solid);
+	p->setPen(Qt::black, lineWidth, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
+	p->drawRect(0, 0, pageWidth, pageHeight);
+	p->setAntialiasing(true);
+	p->restore();
+}
+
+void Canvas::DrawPageBorder(ScPainter *p, const QRectF& clip, bool master)
+{
+	if (master)
+	{
+		ScPage *page = m_doc->currentPage();
+		double x = m_doc->scratch()->left() * m_viewMode.scale;
+		double y = m_doc->scratch()->top() * m_viewMode.scale;
+		double w = page->width() * m_viewMode.scale;
+		double h = page->height() * m_viewMode.scale;
+		QRectF drawRect(x, y, w + 5, h + 5);
+		drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
+		if (drawRect.intersects(clip))
+			DrawPageBorderSub(p, page);
+	}
+	else
+	{
+		int docPagesCount = m_doc->Pages->count();
+		for (int a = 0; a < docPagesCount; ++a)
+		{
+			ScPage *page = m_doc->Pages->at(a);
+			QRectF drawRect(page->xOffset() * m_viewMode.scale, page->yOffset() * m_viewMode.scale, page->width() * m_viewMode.scale + 5, page->height() * m_viewMode.scale + 5);
+			drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
+			if (drawRect.intersects(clip))
+				DrawPageBorderSub(p, page);
+		}
+	}
+}
+
+/**
+  draws margins
+ */
+void Canvas::DrawPageMarginsGridSub(ScPainter *p, ScPage *page)
+{
+	p->save();
+	p->setAntialiasing(false);
+	p->translate(page->xOffset(), page->yOffset());
+	double lineWidth = 1.0 / m_viewMode.scale;
+	double pageHeight = page->height();
+	double pageWidth = page->width();
+	p->setFillMode(ScPainter::None);
+	p->setStrokeMode(ScPainter::Solid);
+	p->setPen(Qt::black, lineWidth, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
+	if (m_doc->guidesPrefs().marginsShown)
+	{
+		p->setPen(m_doc->guidesPrefs().marginColor);
+		if (m_doc->marginColored())
+		{
+			p->setFillMode(ScPainter::Solid);
+			p->setBrush(m_doc->guidesPrefs().marginColor);
+			p->drawRect(0, 0, pageWidth, page->Margins.top());
+			p->drawRect(0, page->Margins.top(), page->Margins.left(), pageHeight - page->Margins.top());
+			p->drawRect(page->Margins.left(), pageHeight - page->Margins.bottom(), pageWidth - page->Margins.right() - page->Margins.left(), page->Margins.bottom());
+			p->drawRect(pageWidth - page->Margins.right(), page->Margins.top(), page->Margins.right(), pageHeight-page->Margins.top());
+			p->setFillMode(ScPainter::None);
+		}
+		p->setFillMode(ScPainter::None);
+		p->drawRect(page->Margins.left(), page->Margins.top(), pageWidth - page->Margins.left() - page->Margins.right(), pageHeight - page->Margins.top() - page->Margins.bottom());
+	}
+	p->setAntialiasing(true);
+	p->restore();
+}
+
+void Canvas::DrawPageMargins(ScPainter *p, const QRectF& clip, bool master)
+{
+	if (master)
+	{
+		ScPage *page = m_doc->currentPage();
+		double x = m_doc->scratch()->left() * m_viewMode.scale;
+		double y = m_doc->scratch()->top() * m_viewMode.scale;
+		double w = page->width() * m_viewMode.scale;
+		double h = page->height() * m_viewMode.scale;
+		QRectF drawRect(x, y, w + 5, h + 5);
+		drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
+		if (drawRect.intersects(clip))
+			DrawPageMarginsGridSub(p, page);
+	}
+	else
+	{
+		int docPagesCount = m_doc->Pages->count();
+		for (int a = 0; a < docPagesCount; ++a)
+		{
+			ScPage *page = m_doc->Pages->at(a);
+			QRectF drawRect(page->xOffset() * m_viewMode.scale, page->yOffset() * m_viewMode.scale, page->width() * m_viewMode.scale + 5, page->height() * m_viewMode.scale + 5);
+			drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
+			if (drawRect.intersects(clip))
+				DrawPageMarginsGridSub(p, page);
+		}
+	}
+}
+
+/**
+  draws baseline grid
+ */
+void Canvas::DrawPageBaselineGridSub(ScPainter *p, ScPage *page)
+{
+	if (!m_doc->guidesPrefs().baselineGridShown)
+		return;
+
+	p->save();
+	p->setAntialiasing(false);
+	p->translate(page->xOffset(), page->yOffset());
+	double lineWidth = 1.0 / m_viewMode.scale;
+	double pageHeight = page->height();
+	double pageWidth = page->width();
+	p->setFillMode(ScPainter::None);
+	p->setStrokeMode(ScPainter::Solid);
+	p->setPen(m_doc->guidesPrefs().baselineGridColor, lineWidth, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
+	for (double yg = m_doc->guidesPrefs().offsetBaselineGrid; yg < pageHeight; yg += m_doc->guidesPrefs().valueBaselineGrid)
+		p->drawLine(FPoint(0, yg), FPoint(pageWidth, yg));
+	p->setAntialiasing(true);
+	p->restore();
+}
+
+void Canvas::DrawPageBaselineGrid(ScPainter *p, const QRectF& clip, bool master)
+{
+	if (!m_doc->guidesPrefs().baselineGridShown)
+		return;
+
+	if (master)
+	{
+		ScPage *page = m_doc->currentPage();
+		double x = m_doc->scratch()->left() * m_viewMode.scale;
+		double y = m_doc->scratch()->top() * m_viewMode.scale;
+		double w = page->width() * m_viewMode.scale;
+		double h = page->height() * m_viewMode.scale;
+		QRectF drawRect(x, y, w + 5, h + 5);
+		drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
+		if (drawRect.intersects(clip))
+			DrawPageBaselineGridSub(p, page);
+	}
+	else
+	{
+		int docPagesCount = m_doc->Pages->count();
+		for (int a = 0; a < docPagesCount; ++a)
+		{
+			ScPage *page = m_doc->Pages->at(a);
+			QRectF drawRect(page->xOffset() * m_viewMode.scale, page->yOffset() * m_viewMode.scale, page->width() * m_viewMode.scale + 5, page->height() * m_viewMode.scale + 5);
+			drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
+			if (drawRect.intersects(clip))
+				DrawPageBaselineGridSub(p, page);
+		}
+	}
+}
+
+/**
+  draws grid
+ */
+void Canvas::DrawPageGridSub(ScPainter *p, ScPage *page, const QRectF& clip)
+{
+	if (!m_doc->guidesPrefs().gridShown)
+		return;
+
+	p->save();
+	FPointArray PoLine;
+	getClipPathForPages(&PoLine);
+	p->beginLayer(1.0, 0, &PoLine);
+	p->setAntialiasing(false);
+	p->translate(page->xOffset(), page->yOffset());
+	double lineWidth = 1.0 / m_viewMode.scale;
+	double pageHeight = page->height();
+	double pageWidth = page->width();
+	p->setFillMode(ScPainter::None);
+	p->setStrokeMode(ScPainter::Solid);
+	p->setPen(Qt::black, lineWidth, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
+
+	double lowerBx = qMax(clip.x() / m_viewMode.scale + m_doc->minCanvasCoordinate.x() - page->xOffset(), 0.0);
+	double lowerBy = qMax(clip.y() / m_viewMode.scale + m_doc->minCanvasCoordinate.y() - page->yOffset(), 0.0);
+	double highBx = qMin(lowerBx + clip.width() / m_viewMode.scale, pageWidth);
+	double highBy = qMin(lowerBy + clip.height() / m_viewMode.scale, pageHeight);
+	if (m_viewMode.scale > 0.49)
+	{
+		if (m_doc->guidesPrefs().gridType == 0)
+		{
+			double i,start;
+			i = m_doc->guidesPrefs().majorGridSpacing;
+			p->setPen(m_doc->guidesPrefs().majorGridColor, lineWidth, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
+			start = floor(lowerBy / i);
+			start *= i;
+			for (double b = start; b <= highBy; b += i)
+			{
+				p->drawLine(FPoint(qMax(lowerBx, 0.0), b), FPoint(qMin(pageWidth, highBx), b));
+			}
+			start = floor(lowerBx / i);
+			start *= i;
+			for (double b = start; b <= highBx; b += i)
+			{
+				p->drawLine(FPoint(b, qMax(lowerBy, 0.0)), FPoint(b, qMin(pageHeight, highBy)));
+			}
+			i = m_doc->guidesPrefs().minorGridSpacing;
+			p->setPen(m_doc->guidesPrefs().minorGridColor, lineWidth, Qt::DotLine, Qt::FlatCap, Qt::MiterJoin);
+			start = floor(lowerBy / i);
+			start *= i;
+			for (double b = start; b <= highBy; b += i)
+			{
+				p->drawLine(FPoint(qMax(lowerBx, 0.0), b), FPoint(qMin(pageWidth, highBx), b));
+			}
+			start = floor(lowerBx / i);
+			start *= i;
+			for (double b = start; b <= highBx; b += i)
+			{
+				p->drawLine(FPoint(b, qMax(lowerBy, 0.0)), FPoint(b, qMin(pageHeight, highBy)));
+			}
+		}
+		else if (m_doc->guidesPrefs().gridType == 1)
+		{
+			double i, startX, startY;
+			i = m_doc->guidesPrefs().minorGridSpacing;
+			p->setPen(m_doc->guidesPrefs().minorGridColor, 3.0 / m_viewMode.scale, Qt::SolidLine, Qt::RoundCap, Qt::MiterJoin);
+			startY = floor(lowerBy / i);
+			startY *= i;
+			startX = floor(lowerBx / i);
+			startX *= i;
+			for (double b = startY; b <= highBy; b += i)
+			{
+				for (double bb = startX; bb <= highBx; bb += i)
+				{
+					p->drawLine(FPoint(bb, b), FPoint(bb, b));
+				}
+			}
+			i = m_doc->guidesPrefs().majorGridSpacing;
+			p->setPen(m_doc->guidesPrefs().majorGridColor, lineWidth * 2, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
+			startY = floor(lowerBy / i);
+			startY *= i;
+			startX = floor(lowerBx / i);
+			startX *= i;
+			for (double b = startY; b <= highBy; b += i)
+			{
+				for (double bb = startX; bb <= highBx; bb += i)
+				{
+					p->drawLine(FPoint(bb - 4, b), FPoint(bb + 4, b));
+					p->drawLine(FPoint(bb, b - 4), FPoint(bb, b + 4));
+				}
+			}
+		}
+	}
+
+	p->setAntialiasing(true);
+	p->endLayer();
+	p->restore();
+}
+
+void Canvas::DrawPageGrid(ScPainter *p, const QRectF& clip, bool master)
+{
+	if (!m_doc->guidesPrefs().gridShown)
+		return;
+
+	if (master)
+	{
+		ScPage *page = m_doc->currentPage();
+		double x = m_doc->scratch()->left() * m_viewMode.scale;
+		double y = m_doc->scratch()->top() * m_viewMode.scale;
+		double w = page->width() * m_viewMode.scale;
+		double h = page->height() * m_viewMode.scale;
+		QRectF drawRect(x, y, w + 5, h + 5);
+		drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
+		if (drawRect.intersects(clip))
+			DrawPageGridSub(p, page, clip);
+	}
+	else
+	{
+		int docPagesCount = m_doc->Pages->count();
+		for (int a = 0; a < docPagesCount; ++a)
+		{
+			ScPage *page = m_doc->Pages->at(a);
+			QRectF drawRect(page->xOffset() * m_viewMode.scale, page->yOffset() * m_viewMode.scale, page->width() * m_viewMode.scale + 5, page->height() * m_viewMode.scale + 5);
+			drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
+			if (drawRect.intersects(clip))
+				DrawPageGridSub(p, page, clip);
+		}
+	}
+}
+
+/**
+  draws guides
+ */
+void Canvas::DrawPageGuidesSub(ScPainter *p, ScPage *page)
+{
+	if (!m_doc->guidesPrefs().guidesShown)
+		return;
+
+	p->save();
+	p->setAntialiasing(false);
+	p->translate(page->xOffset(), page->yOffset());
+	double lineWidth = 1.0 / m_viewMode.scale;
+	p->setFillMode(ScPainter::None);
+	p->setStrokeMode(ScPainter::Solid);
+	p->setPen(Qt::black, lineWidth, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
+	page->guides.drawPage(p, m_doc, lineWidth);
+	p->setAntialiasing(true);
+	p->restore();
+}
+
+void Canvas::DrawPageGuides(ScPainter *p, const QRectF& clip, bool master)
+{
+	if (!m_doc->guidesPrefs().guidesShown)
+		return;
+
+	if (master)
+	{
+		ScPage *page = m_doc->currentPage();
+		double x = m_doc->scratch()->left() * m_viewMode.scale;
+		double y = m_doc->scratch()->top() * m_viewMode.scale;
+		double w = page->width() * m_viewMode.scale;
+		double h = page->height() * m_viewMode.scale;
+		QRectF drawRect(x, y, w + 5, h + 5);
+		drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
+		if (drawRect.intersects(clip))
+			DrawPageGuidesSub(p, page);
+	}
+	else
+	{
+		int docPagesCount = m_doc->Pages->count();
+		for (int a = 0; a < docPagesCount; ++a)
+		{
+			ScPage *page = m_doc->Pages->at(a);
+			QRectF drawRect(page->xOffset() * m_viewMode.scale, page->yOffset() * m_viewMode.scale, page->width() * m_viewMode.scale + 5, page->height() * m_viewMode.scale + 5);
+			drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
+			if (drawRect.intersects(clip))
+				DrawPageGuidesSub(p, page);
+		}
+	}
+}
+
+/**
+  draws actual page indicator frame
+ */
+void Canvas::DrawPageIndicatorSub(ScPainter *p, ScPage *page)
+{
+	p->save();
+	int fm = p->fillMode();
+	p->setAntialiasing(false);
+	p->translate(page->xOffset(), page->yOffset());
+	double lineWidth = 1.0 / m_viewMode.scale;
+	double pageHeight = page->height();
+	double pageWidth = page->width();
+	p->setFillMode(ScPainter::None);
+	p->setStrokeMode(ScPainter::Solid);
+	p->setPen(Qt::black, lineWidth, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
+	p->setPen(PrefsManager::instance().appPrefs.displayPrefs.pageBorderColor, 1 / m_viewMode.scale, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
+	p->drawRect(0, 0, pageWidth, pageHeight);
+	p->setAntialiasing(true);
+	p->setFillMode(fm);
+	p->restore();
+}
+
+void Canvas::DrawPageIndicator(ScPainter *p, const QRectF& clip, bool master)
+{
+	if (master)
+	{
+		ScPage *page = m_doc->currentPage();
+		double x = m_doc->scratch()->left() * m_viewMode.scale;
+		double y = m_doc->scratch()->top() * m_viewMode.scale;
+		double w = page->width() * m_viewMode.scale;
+		double h = page->height() * m_viewMode.scale;
+		QRectF drawRect(x, y, w + 5, h + 5);
+		drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
+		if (drawRect.intersects(clip))
+			DrawPageIndicatorSub(p, page);
+	}
+	else
+	{
+		int docPagesCount = m_doc->Pages->count();
+		for (int a = 0; a < docPagesCount; ++a)
+		{
+			ScPage *page = m_doc->Pages->at(a);
+			if (page == m_doc->currentPage())
+			{
+				QRectF drawRect(page->xOffset() * m_viewMode.scale, page->yOffset() * m_viewMode.scale, page->width() * m_viewMode.scale + 5, page->height() * m_viewMode.scale + 5);
+				drawRect.translate(-m_doc->minCanvasCoordinate.x() * m_viewMode.scale, -m_doc->minCanvasCoordinate.y() * m_viewMode.scale);
+				if (drawRect.intersects(clip))
+					DrawPageIndicatorSub(p, page);
+			}
+		}
+	}
+}
+
+/**
+  draws the links between textframe chains.
+  needs the list of visible textframes in m_viewMode.linkedFramesToShow
+ */
+void Canvas::drawFrameLinks(ScPainter* painter)
+{
+	PageItem *currItem = nullptr;
+	if ((m_doc->appMode == modeLinkFrames) || (m_doc->appMode == modeUnlinkFrames))
+	{
+		if (m_doc->m_Selection->count() > 0)
+			currItem = m_doc->m_Selection->itemAt(0);
+		else if (m_viewMode.linkedFramesToShow.count() > 0)
+			currItem = m_viewMode.linkedFramesToShow.at(0);
+		if (currItem && (currItem->itemType() != PageItem::TextFrame))
+			currItem = nullptr;
+	}
+
+	//Draw the frame links
+	painter->save();
+	if (m_doc->guidesPrefs().linkShown || m_viewMode.drawFramelinksWithContents)
+	{
+		for (int i = 0; i < m_viewMode.linkedFramesToShow.count(); ++i)
+		{
+			PageItem* nextItem = m_viewMode.linkedFramesToShow.at(i);
+			while (nextItem != nullptr)
+			{
+				if (nextItem->nextInChain() != nullptr)
+				{
+					FPoint start, end;
+					calculateFrameLinkPoints(nextItem, nextItem->nextInChain(), start, end);
+					drawLinkFrameLine(painter, start, end);
+				}
+				nextItem = nextItem->nextInChain();
+			}
+		}
+	}
+	else if ((((m_doc->appMode == modeLinkFrames) || (m_doc->appMode == modeUnlinkFrames)) && (currItem != nullptr)))
+	{
+		PageItem *nextItem = currItem->firstInChain();
+		while (nextItem != nullptr)
+		{
+			if (nextItem->nextInChain() != nullptr)
+			{
+				FPoint start, end;
+				calculateFrameLinkPoints(nextItem, nextItem->nextInChain(), start, end);
+				drawLinkFrameLine(painter, start, end);
+			}
+			nextItem = nextItem->nextInChain();
+		}
+	}
+	painter->setLineWidth(1);
+	painter->setPenOpacity(1.0);
+	painter->restore();
+}
+
+
+/**
+  draws one linkline between textframes
+  */
+void Canvas::drawLinkFrameLine(ScPainter* painter, FPoint &start, FPoint &end)
+{
+	//CB FIXME Add some checking that the painter is setup?
+	Q_ASSERT(painter != nullptr);
+	painter->setPen(Qt::black, 1.0 / m_viewMode.scale, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin);
+	painter->setPenOpacity(1.0);
+	painter->drawLine(start, end);
+	QTransform arrowTrans;
+	arrowTrans.translate(end.x(), end.y());
+	double r = atan2(end.y()-start.y(), end.x()-start.x())*(180.0/M_PI);
+	arrowTrans.rotate(r);
+	double sc = 0.8 / m_viewMode.scale;
+	arrowTrans.scale(sc, sc);
+	FPointArray arrow;
+	arrow.addQuadPoint(-12, 0, -12, 0, -12, 0, -12, 0);
+	arrow.addQuadPoint(-15, -5, -15, -5, -15, -5, -15, -5);
+	arrow.addQuadPoint(0, 0, 0, 0, 0, 0, 0, 0);
+	arrow.addQuadPoint(-15, 5, -15, 5, -15, 5, -15, 5);
+	arrow.addQuadPoint(-12, 0, -12, 0, -12, 0, -12, 0);
+	arrow.map(arrowTrans);
+	painter->setBrush(painter->pen());
+	painter->setBrushOpacity(1.0);
+	painter->setLineWidth(0);
+	painter->setFillMode(ScPainter::Solid);
+	painter->setupPolygon(&arrow);
+	painter->fillPath();
+}
+
+
+
+/**
+  this is a wrapper around repaint()
+ */
+void Canvas::PaintSizeRect(QRect newRect)
+{
+	static QRect oldRect;
+	if (!newRect.isNull())
+	{
+		if (!oldRect.isNull())
+			newRect = newRect.united(oldRect);
+		repaint(newRect.adjusted(-10, -10, 20, 20));
+	}
+	oldRect = newRect;
+}
+
+
+/// ???
+void Canvas::PaintSizeRect(QPolygon newRect)
+{
+	static QRect oldRect;
+	QRect newR = newRect.boundingRect();
+	if (!newR.isNull())
+	{
+		if (!oldRect.isNull())
+			newRect = newRect.united(oldRect);
+		m_viewMode.redrawPolygon = newRect;
+		repaint(newR.adjusted(-20, -20, 40, 40));
+	}
+	oldRect = newR;
+}
+
+void Canvas::getGroupRectScreen(double *x, double *y, double *w, double *h)
+{
+	double gx, gy, gh, gw;
+	m_doc->m_Selection->getGroupRect(&gx, &gy, &gw, &gh);
+	QPoint in(qRound(gx* m_viewMode.scale), qRound(gy* m_viewMode.scale));
+//	in -= QPoint(qRound(m_doc->minCanvasCoordinate.x() * m_viewMode.scale), qRound(m_doc->minCanvasCoordinate.y() * m_viewMode.scale));
+	QPoint out = contentsToViewport(in);
+	*x = static_cast<double>(out.x());
+	*y = static_cast<double>(out.y());
+	*w = gw* m_viewMode.scale;
+	*h = gh* m_viewMode.scale;
+}
+
+
+void Canvas::Transform(PageItem *currItem, QPainter *p)
+{
+	p->translate(currItem->xPos()*m_viewMode.scale, currItem->yPos()*m_viewMode.scale);
+	p->scale(m_viewMode.scale, m_viewMode.scale);
+	p->rotate(currItem->rotation());
+}
+
+void Canvas::Transform(PageItem *currItem, QTransform& m)
+{
+	m.translate(currItem->xPos()*m_viewMode.scale, currItem->yPos()*m_viewMode.scale);
+	m.scale(m_viewMode.scale, m_viewMode.scale);
+	m.rotate(currItem->rotation());
+}
+
+void Canvas::TransformM(PageItem *currItem, QPainter *p)
+{
+	if (currItem->imageFlippedH())
+	{
+		p->translate(currItem->width(), 0);
+		p->scale(-1, 1);
+	}
+	if (currItem->imageFlippedV())
+	{
+		p->translate(0, currItem->height());
+		p->scale(1, -1);
+	}
+}
+
+void Canvas::calculateFrameLinkPoints(PageItem *pi1, PageItem *pi2, FPoint & start, FPoint & end)
+{
+	if (pi1 == nullptr || pi2 == nullptr)
+		return;
+	//Calculate the link points of the frames
+	double x11 = pi1->xPos();
+	double y11 = pi1->yPos();
+	double x12 = x11 + pi1->width();
+	double y12 = y11 + pi1->height();
+	if (pi1->isGroupChild())
+	{
+		QTransform itemTrans = pi1->getTransform();
+		QPointF itPos = itemTrans.map(QPointF(0, 0));
+		x11 = itPos.x();
+		y11 = itPos.y();
+		double grScXi = 1.0;
+		double grScYi = 1.0;
+		getScaleFromMatrix(itemTrans, grScXi, grScYi);
+		if (itemTrans.m11() < 0)
+			x11 -= pi1->width() * grScXi;
+		if (itemTrans.m22() < 0)
+			y11 -= pi1->height() * grScYi;
+		x12 = x11 + pi1->width() * grScXi;
+		y12 = y11 + pi1->height() * grScYi;
+	}
+	double x1mid = x11 + (x12 - x11) / 2.0;
+	double y1mid = y11 + (y12 - y11) / 2.0;
+					
+	if (pi1->rotation()!=0.000)
+	{
+		FPoint tempPoint(0,0, x11, y11, pi1->rotation(), 1, 1);
+		x11 = tempPoint.x();
+		y11 = tempPoint.y();
+		FPoint tempPoint2(0, 0, x12, y12, pi1->rotation(), 1, 1);
+		x12 = tempPoint2.x();
+		y12 = tempPoint2.y();
+		FPoint tempPoint3(0, 0, x1mid, y1mid, pi1->rotation(), 1, 1);
+		x1mid = tempPoint3.x();
+		y1mid = tempPoint3.y();
+	}
+					
+					
+	double a1, b1, a2, b2;
+	a1 = a2 = b1 = b2 = 0;
+	double x21 = pi2->xPos();
+	double y21 = pi2->yPos();
+	double x22 = x21 + pi2->width();
+	double y22 = y21 + pi2->height();
+	if (pi2->isGroupChild())
+	{
+		QTransform itemTrans = pi2->getTransform();
+		QPointF itPos = itemTrans.map(QPointF(0, 0));
+		x21 = itPos.x();
+		y21 = itPos.y();
+		double grScXi = 1.0;
+		double grScYi = 1.0;
+		getScaleFromMatrix(itemTrans, grScXi, grScYi);
+		if (itemTrans.m11() < 0)
+			x21 -= pi2->width() * grScXi;
+		if (itemTrans.m22() < 0)
+			y11 -= pi2->height() * grScYi;
+		x22 = x21 + pi2->width() * grScXi;
+		y22 = y21 + pi2->height() * grScYi;
+	}
+
+	double x2mid = x21 + (x22 - x21) / 2.0;
+	double y2mid = y21 + (y22 - y21) / 2.0;
+					
+	if (pi2->rotation()!=0.000)
+	{
+		FPoint tempPoint(0,0, x21, y21, pi2->rotation(), 1, 1);
+		x21 = tempPoint.x();
+		y21 = tempPoint.y();
+		FPoint tempPoint2(0, 0, x22, y22, pi2->rotation(), 1, 1);
+		x22 = tempPoint2.x();
+		y22 = tempPoint2.y();
+		FPoint tempPoint3(0, 0, x2mid, y2mid, pi2->rotation(), 1, 1);
+		x2mid = tempPoint3.x();
+		y2mid = tempPoint3.y();
+	}
+					
+	if (x22 < x11) { a1 = x11; a2 = x22; }
+	if (x21 > x12) { a1 = x12; a2 = x21; }
+	if (y22 < y11) { b1 = y11; b2 = y22; }
+	if (y21 > y12) { b1 = y12; b2 = y21; }
+
+	if (x21 < x12 && x21 > x11) { a1 = x1mid; a2 = x2mid; }
+	if (x21 < x11 && x22 > x11) { a1 = x1mid; a2 = x2mid; }
+
+	if (y21 < y12 && y21 > y11) { b1 = y1mid; b2 = y2mid; }
+	if (y21 < y11 && y22 > y11) { b1 = y1mid; b2 = y2mid; }
+	
+	//When our points (in pt) are exactly the same, cover this too. #3634
+	if (x11 == x21) { a1 = x1mid; a2 = x2mid; }
+	if (y11 == y21) { b1 = y1mid; b2 = y2mid; }
+	
+	//Set the link frame lines' endpoints
+	start.setXY(a1-pi1->xPos(), b1-pi1->yPos());
+	start.transform(pi1->xPos(), pi1->yPos(), pi1->rotation(), 1, 1, false);
+	end.setXY(a2-pi2->xPos(), b2-pi2->yPos());
+	end.transform(pi2->xPos(), pi2->yPos(), pi2->rotation(), 1, 1, false);
+}
+
+QPixmap Canvas::createPixmap(double w, double h)
+{
+	QPixmap p(w * devicePixelRatioF(), h * devicePixelRatioF());
+	p.setDevicePixelRatio(devicePixelRatioF());
+	return p;
+}
+
+void Canvas::drawPixmap(QPainter& painter, double x, double y, const QPixmap& pixmap, double sx, double sy, double sw, double sh)
+{
+	sx *= devicePixelRatioF();
+	sy *= devicePixelRatioF();
+	sw *= devicePixelRatioF();
+	sh *= devicePixelRatioF();
+	painter.drawPixmap(x, y, pixmap, sx, sy, sw, sh);
+}
+
+void Canvas::displayXYHUD(QPoint m)
+{
+	if (!PrefsManager::instance().appPrefs.displayPrefs.showMouseCoordinates)
+		return;
+	double gx, gy, gh, gw, r;
+	if (m_doc->m_Selection->isMultipleSelection())
+	{
+		m_doc->m_Selection->getGroupRect(&gx, &gy, &gw, &gh);
+		r = 0.0;
+	}
+	else
+	{
+		PageItem* currItem = m_doc->m_Selection->itemAt(0);
+		gx = currItem->xPos();
+		gy = currItem->yPos();
+		gw = currItem->width();
+		gh = currItem->height();
+		r = currItem->rotation();
+	}
+	QTransform ma;
+	ma.translate(gx, gy);
+	ma.rotate(r);
+	FPoint n;
+	if (m_doc->rotationMode() == 0)
+		n = FPoint(0.0, 0.0);
+	else if (m_doc->rotationMode() == 1)
+		n = FPoint(gw, 0.0);
+	else if (m_doc->rotationMode() == 2)
+		n = FPoint(gw / 2.0, gh / 2.0);
+	else if (m_doc->rotationMode() == 3)
+		n = FPoint(0.0, gh);
+	else if (m_doc->rotationMode() == 4)
+		n = FPoint(gw, gh);
+	gx = ma.m11() * n.x() + ma.m21() * n.y() + ma.dx();
+	gy = ma.m22() * n.y() + ma.m12() * n.x() + ma.dy();
+	if (m_doc->guidesPrefs().rulerMode)
+	{
+		gx -= m_doc->currentPage()->xOffset();
+		gy -= m_doc->currentPage()->yOffset();
+	}
+	gx -= m_doc->rulerXoffset;
+	gy -= m_doc->rulerYoffset;
+	displayXYHUD(m, gx, gy);
+}
+
+void Canvas::displayCorrectedXYHUD(QPoint m, double x, double y)
+{
+	if (!PrefsManager::instance().appPrefs.displayPrefs.showMouseCoordinates)
+		return;
+	double gx = x;
+	double gy = y;
+	if (m_doc->guidesPrefs().rulerMode)
+	{
+		gx -= m_doc->currentPage()->xOffset();
+		gy -= m_doc->currentPage()->yOffset();
+	}
+	gx -= m_doc->rulerXoffset;
+	gy -= m_doc->rulerYoffset;
+	QToolTip::showText(m + QPoint(5, 5), tr("X: %1\nY: %2").arg(value2String(gx, m_doc->unitIndex(), true, true), value2String(gy, m_doc->unitIndex(), true, true)), this);
+}
+
+void Canvas::displayCorrectedSingleHUD(QPoint m, double val, bool isX)
+{
+	if (!PrefsManager::instance().appPrefs.displayPrefs.showMouseCoordinates)
+		return;
+	double gx = val;
+	if (isX)
+	{
+		if (m_doc->guidesPrefs().rulerMode)
+			gx -= m_doc->currentPage()->xOffset();
+		gx -= m_doc->rulerXoffset;
+		QToolTip::showText(m + QPoint(5, 5), tr("X: %1").arg(value2String(gx, m_doc->unitIndex(), true, true)), this);
+	}
+	else
+	{
+		if (m_doc->guidesPrefs().rulerMode)
+			gx -= m_doc->currentPage()->yOffset();
+		gx -= m_doc->rulerYoffset;
+		QToolTip::showText(m + QPoint(5, 5), tr("Y: %1").arg(value2String(gx, m_doc->unitIndex(), true, true)), this);
+	}
+}
+
+void Canvas::displayXYHUD(QPoint m, double x, double y)
+{
+	if (!PrefsManager::instance().appPrefs.displayPrefs.showMouseCoordinates)
+		return;
+	QToolTip::showText(m + QPoint(5, 5), tr("X: %1\nY: %2").arg(value2String(x, m_doc->unitIndex(), true, true), value2String(y, m_doc->unitIndex(), true, true)), this);
+}
+
+void Canvas::displaySizeHUD(QPoint m, double x, double y, bool isLine)
+{
+	if (!PrefsManager::instance().appPrefs.displayPrefs.showMouseCoordinates)
+		return;
+	if (isLine)
+		QToolTip::showText(m + QPoint(5, 5), tr("Length: %1\nAngle: %2").arg(value2String(x, m_doc->unitIndex(), true, true), value2String(y, SC_DEGREES, true, true)), this);
+	else
+		QToolTip::showText(m + QPoint(5, 5), tr("Width: %1\nHeight: %2").arg(value2String(x, m_doc->unitIndex(), true, true), value2String(y, m_doc->unitIndex(), true, true)), this);
+}
+
+void Canvas::displayRotHUD(QPoint m, double rot)
+{
+	if (!PrefsManager::instance().appPrefs.displayPrefs.showMouseCoordinates)
+		return;
+	double r;
+	if (rot < 0.0)
+		r = rot * -1.0;
+	else
+		r = 360.0 - rot;
+	QToolTip::showText(m + QPoint(5, 5), tr("Angle: %1").arg(value2String(r, SC_DEGREES, true, true)), this);
+}
+
+void Canvas::displayRealRotHUD(QPoint m, double rot)
+{
+	if (!PrefsManager::instance().appPrefs.displayPrefs.showMouseCoordinates)
+		return;
+	QToolTip::showText(m + QPoint(5, 5), tr("Angle: %1").arg(value2String(rot, SC_DEGREES, true, true)), this);
+}
+
+void Canvas::displayDoubleHUD(QPoint point, const QString& label, double value)
+{
+	if (!PrefsManager::instance().appPrefs.displayPrefs.showMouseCoordinates)
+		return;
+	QToolTip::showText(point + QPoint(5, 5), QString("%1: %2").arg(label, value2String(value, m_doc->unitIndex(), true, true)), this);
+}
+
+void Canvas::setupEditHRuler(PageItem * item, bool forceAndReset)
+{
+	static QString rulerItemRef;
+	static double rulerDumbHash(0.0);
+	
+	if ((rulerItemRef != item->itemName()) 
+		   || forceAndReset )
+	{
+		rulerItemRef = item->itemName();
+		rulerDumbHash = 0.0;
+	}
+	
+	double controlHash(0.0);
+	controlHash = item->xPos() 
+			+ item->yPos()				* 1.0
+			+ item->m_columnGap 				* 2.0
+			+ item->m_columns 				* 3.0
+			+ item->textToFrameDistLeft()		* 4.0 
+			+ item->textToFrameDistRight()		* 5.0
+			+ item->currentStyle().firstIndent()	* 6.0
+			+ item->currentStyle().leftMargin()	* 7.0
+			+ item->width()				* 8.0
+			+ item->currentStyle().rightMargin()	* 9.0
+			+ (item->imageFlippedH() ? 32.32 : 13.13);
+	
+	const ParagraphStyle& currParaStyle = item->currentStyle();
+	for (const ParagraphStyle::TabRecord& tabrec : currParaStyle.tabValues())
+	{
+		controlHash += tabrec.tabPosition;
+	}
+// 	qDebug()<<"Canvas::setupEditHRuler"<<rulerItemRef<<controlHash<<rulerDumbHash;
+	if (controlHash == rulerDumbHash)
+		return;
+	
+	rulerDumbHash = controlHash;
+	m_view->horizRuler->setItem(item);
+	m_view->horizRuler->update();
+}
diff -Napur a/scribus/canvasgesture_resize.cpp f/scribus/canvasgesture_resize.cpp
--- a/scribus/canvasgesture_resize.cpp	2025-01-08 21:31:43.000000000 +0100
+++ f/scribus/canvasgesture_resize.cpp	2025-02-07 13:56:48.343894981 +0100
@@ -505,7 +505,7 @@ void ResizeGesture::adjustBounds(QMouseE
 		rotation.rotate(m_rotation);
 		rotation.translate(-normalizedBounds.x(), -normalizedBounds.y());
 //		qDebug() << "resize rotated" << m_rotation << "°" << m_bounds << rotation << ":" << point-globalBounds.topLeft() << "-->" << rotation.map(point)-globalBounds.topLeft();
-		QPointF qp = QPointF(docPoint.x(), docPoint.y());
+		QPointF qp(docPoint.x(), docPoint.y());
 		qp = rotation.inverted().map(qp);
 		docPoint = FPoint(qp.x(), qp.y());
 	}
diff -Napur a/scribus/canvasmode.cpp f/scribus/canvasmode.cpp
--- a/scribus/canvasmode.cpp	2025-01-08 21:31:41.000000000 +0100
+++ f/scribus/canvasmode.cpp	2025-02-07 13:56:48.345894945 +0100
@@ -227,7 +227,7 @@ void CanvasMode::drawSelectionHandles(QP
 	double markWidth = 4.0 / m_canvas->scale();
 	if (insideGroup)
 		markWidth /= qMax(sx, sy);
-	QRectF handleRect = QRectF(0, 0, markWidth, markWidth);
+	QRectF handleRect(0, 0, markWidth, markWidth);
 	double x = selectionRect.x();
 	double y = selectionRect.y();
 	double w = selectionRect.width();
@@ -430,7 +430,7 @@ void CanvasMode::drawSelection(QPainter*
 					if (currItem->isLine())
 					{
 						const double markWidth = 4.0 / m_canvas->scale();
-						QRectF handleRect = QRectF(0, 0, markWidth, markWidth);
+						QRectF handleRect(0, 0, markWidth, markWidth);
 						psx->setRenderHint(QPainter::Antialiasing);
 						psx->setBrush(Qt::white);
 						psx->setPen(m_pen["handle"]);
diff -Napur a/scribus/canvasmode_edit.cpp f/scribus/canvasmode_edit.cpp
--- a/scribus/canvasmode_edit.cpp	2025-01-08 21:31:43.000000000 +0100
+++ f/scribus/canvasmode_edit.cpp	2025-02-07 13:56:48.345894945 +0100
@@ -80,7 +80,7 @@ void CanvasMode_Edit::blinkTextCursor()
 	PageItem* currItem;
 	if (m_doc->appMode == modeEdit && GetItem(&currItem))
 	{
-		QRectF brect = QRectF(0, 0, currItem->width(), currItem->height());
+		QRectF brect(0, 0, currItem->width(), currItem->height());
 		QTransform m = currItem->getTransform();
 		brect = m.mapRect(brect);
 		m_canvas->update(QRectF(m_canvas->canvasToLocal(brect.topLeft()), QSizeF(brect.width(),brect.height())*m_canvas->scale()).toRect());
diff -Napur a/scribus/canvasmode_editarc.cpp f/scribus/canvasmode_editarc.cpp
--- a/scribus/canvasmode_editarc.cpp	2025-01-08 21:31:45.000000000 +0100
+++ f/scribus/canvasmode_editarc.cpp	2025-02-07 13:56:48.344894963 +0100
@@ -170,8 +170,8 @@ void CanvasMode_EditArc::activate(bool f
 	m_heightPoint = QPointF(m_centerPoint.x(), m_centerPoint.y() - item->arcHeight / 2.0);
 	m_startAngle = item->arcStartAngle;
 	m_endAngle = m_startAngle + item->arcSweepAngle;
-	QLineF res = QLineF(m_centerPoint, m_startPoint);
-	QLineF swe = QLineF(m_centerPoint, m_endPoint);
+	QLineF res(m_centerPoint, m_startPoint);
+	QLineF swe(m_centerPoint, m_endPoint);
 	vectorDialog->setValues(res.angle(), swe.angle(), item->arcHeight, item->arcWidth);
 	vectorDialog->unitChange(m_doc->unitIndex());
 	vectorDialog->show();
@@ -212,8 +212,8 @@ void CanvasMode_EditArc::updateFromItem(
 	m_heightPoint = QPointF(m_centerPoint.x(), m_centerPoint.y() - item->arcHeight / 2.0);
 	m_startAngle = item->arcStartAngle;
 	m_endAngle = m_startAngle + item->arcSweepAngle;
-	QLineF res = QLineF(m_centerPoint, m_startPoint);
-	QLineF swe = QLineF(m_centerPoint, m_endPoint);
+	QLineF res(m_centerPoint, m_startPoint);
+	QLineF swe(m_centerPoint, m_endPoint);
 	vectorDialog->setValues(res.angle(), swe.angle(), item->arcHeight, item->arcWidth);
 	m_view->update();
 }
@@ -236,7 +236,7 @@ void CanvasMode_EditArc::applyValues(dou
 	PageItem_Arc *item = currItem->asArc();
 	QTransform bb;
 	bb.scale(height / width, 1.0);
-	QLineF inp = QLineF(QPointF(width / 2.0, height / 2.0), QPointF(width, height / 2.0));
+	QLineF inp(QPointF(width / 2.0, height / 2.0), QPointF(width, height / 2.0));
 	inp.setAngle(start);
 	QLineF res = bb.map(inp);
 	inp.setAngle(end);
@@ -328,8 +328,8 @@ void CanvasMode_EditArc::mouseMoveEvent(
 		QTransform itemMatrix = currItem->getTransform();
 		QPointF sPoint = currItem->PoLine.pointQF(0);
 		QPointF smPoint = itemMatrix.map(sPoint);
-		QLineF stLinA = QLineF(smPoint, QPointF(m_Mxp, m_Myp));
-		QLineF stLinM = QLineF(smPoint, QPointF(newX, newY));
+		QLineF stLinA(smPoint, QPointF(m_Mxp, m_Myp));
+		QLineF stLinM(smPoint, QPointF(newX, newY));
 		double deltaAngle = stLinM.angle() - stLinA.angle();
 		QPainterPath pp;
 		if (m_arcPoint == useControlStart)
@@ -355,17 +355,17 @@ void CanvasMode_EditArc::mouseMoveEvent(
 			if (m_arcPoint == useControlStart)
 			{
 				m_startPoint = ar.pointQF(2);
-				QLineF stLinA = QLineF(smPoint, itemMatrix.map(m_startPoint));
+				QLineF stLinA(smPoint, itemMatrix.map(m_startPoint));
 				m_canvas->displayRotHUD(m->globalPos(), 360.0 - stLinA.angle());
 			}
 			else if (m_arcPoint == useControlSweep)
 			{
 				m_endPoint = ar.pointQF(ar.size() - 4);
-				QLineF stLinA = QLineF(smPoint, itemMatrix.map(m_endPoint));
+				QLineF stLinA(smPoint, itemMatrix.map(m_endPoint));
 				m_canvas->displayRotHUD(m->globalPos(), 360.0 - stLinA.angle());
 			}
-			QLineF res = QLineF(m_centerPoint, m_startPoint);
-			QLineF swe = QLineF(m_centerPoint, m_endPoint);
+			QLineF res(m_centerPoint, m_startPoint);
+			QLineF swe(m_centerPoint, m_endPoint);
 			vectorDialog->setValues(res.angle(), swe.angle(), nHeight * 2, nWidth * 2);
 			blockUpdateFromItem(true);
 			currItem->update();
@@ -435,7 +435,7 @@ void CanvasMode_EditArc::mouseReleaseEve
 	{
 		QTransform bb;
 		bb.scale(item->arcHeight / item->arcWidth, 1.0);
-		QLineF inp = QLineF(QPointF(item->arcWidth / 2.0, item->arcHeight / 2.0), QPointF(item->arcWidth, item->arcHeight / 2.0));
+		QLineF inp(QPointF(item->arcWidth / 2.0, item->arcHeight / 2.0), QPointF(item->arcWidth, item->arcHeight / 2.0));
 		double start = inp.angleTo(QLineF(QPointF(item->arcWidth / 2.0, item->arcHeight / 2.0),m_startPoint));
 		inp.setAngle(start);
 		double end = inp.angleTo(QLineF(QPointF(item->arcWidth / 2.0, item->arcHeight / 2.0),m_endPoint));
diff -Napur a/scribus/canvasmode_editgradient.cpp f/scribus/canvasmode_editgradient.cpp
--- a/scribus/canvasmode_editgradient.cpp	2025-01-08 21:31:39.000000000 +0100
+++ f/scribus/canvasmode_editgradient.cpp	2025-02-07 13:56:48.344894963 +0100
@@ -327,7 +327,7 @@ void CanvasMode_EditGradient::mouseMoveE
 		double newX = mousePointDoc.x(); //m->x();
 		double newY = mousePointDoc.y(); //m->y();
 		FPoint npx(m_Mxp - newX, m_Myp - newY, 0, 0, currItem->rotation(), 1, 1, true);
-		QPointF np = QPointF(npx.x(), npx.y());
+		QPointF np(npx.x(), npx.y());
 		if (m_view->editStrokeGradient == 1)
 		{
 			if (m_gradientPoint == useGradientStart)
@@ -399,7 +399,7 @@ void CanvasMode_EditGradient::mouseMoveE
 				m.rotate(currItem->GrStrokeSkew);
 				m.translate(radEnd * currItem->GrStrokeScale, 0);
 				QPointF shP = m.map(QPointF(0,0));
-				QPointF shR = QPointF(shP.x() -np.x(), shP.y() - np.y());
+				QPointF shR(shP.x() -np.x(), shP.y() - np.y());
 				double radNew = distance(shR.x() - currItem->GrStrokeStartX, shR.y() - currItem->GrStrokeStartY);
 				double rotNew = xy2Deg(shR.x() - currItem->GrStrokeStartX, shR.y() - currItem->GrStrokeStartY) + 90;
 				currItem->GrStrokeSkew = rotNew - rotEnd;
@@ -494,7 +494,7 @@ void CanvasMode_EditGradient::mouseMoveE
 				m.rotate(currItem->GrMaskSkew);
 				m.translate(radEnd * currItem->GrMaskScale, 0);
 				QPointF shP = m.map(QPointF(0,0));
-				QPointF shR = QPointF(shP.x() -np.x(), shP.y() - np.y());
+				QPointF shR(shP.x() -np.x(), shP.y() - np.y());
 				double radNew = distance(shR.x() - currItem->GrMaskStartX, shR.y() - currItem->GrMaskStartY);
 				double rotNew = xy2Deg(shR.x() - currItem->GrMaskStartX, shR.y() - currItem->GrMaskStartY) + 90;
 				currItem->GrMaskSkew = rotNew - rotEnd;
@@ -593,7 +593,7 @@ void CanvasMode_EditGradient::mouseMoveE
 					m.rotate(currItem->GrSkew);
 				m.translate(radEnd * currItem->GrScale, 0);
 				QPointF shP = m.map(QPointF(0,0));
-				QPointF shR = QPointF(shP.x() -np.x(), shP.y() - np.y());
+				QPointF shR(shP.x() -np.x(), shP.y() - np.y());
 				double radNew = distance(shR.x() - currItem->GrStartX, shR.y() - currItem->GrStartY);
 				double rotNew = xy2Deg(shR.x() - currItem->GrStartX, shR.y() - currItem->GrStartY) + 90;
 				if (currItem->GrType != Gradient_Conical)
diff -Napur a/scribus/canvasmode_editmeshgradient.cpp f/scribus/canvasmode_editmeshgradient.cpp
--- a/scribus/canvasmode_editmeshgradient.cpp	2025-01-08 21:31:43.000000000 +0100
+++ f/scribus/canvasmode_editmeshgradient.cpp	2025-02-07 13:56:48.344894963 +0100
@@ -662,7 +662,7 @@ void CanvasMode_EditMeshGradient::mouseP
 			for (int gcol = 0; gcol < currItem->meshGradientArray[grow].count(); gcol++)
 			{
 				MeshPoint mp = currItem->meshGradientArray[grow][gcol];
-				QPointF gradientPoint = QPointF(mp.gridPoint.x(), mp.gridPoint.y());
+				QPointF gradientPoint(mp.gridPoint.x(), mp.gridPoint.y());
 				gradientPoint = itemMatrix.map(gradientPoint);
 				if (m_canvas->hitsCanvasPoint(mousePointDoc, gradientPoint))
 				{
@@ -686,9 +686,9 @@ void CanvasMode_EditMeshGradient::mouseP
 			for (int gcol = 0; gcol < currItem->meshGradientArray[grow].count(); gcol++)
 			{
 				MeshPoint mp = currItem->meshGradientArray[grow][gcol];
-				QPointF gradientPoint = QPointF(mp.gridPoint.x(), mp.gridPoint.y());
+				QPointF gradientPoint(mp.gridPoint.x(), mp.gridPoint.y());
 				gradientPoint = itemMatrix.map(gradientPoint);
-				QPointF gradientColorPoint = QPointF(mp.controlColor.x(), mp.controlColor.y());
+				QPointF gradientColorPoint(mp.controlColor.x(), mp.controlColor.y());
 				gradientColorPoint = itemMatrix.map(gradientColorPoint);
 				if (m_canvas->hitsCanvasPoint(mousePointDoc, gradientPoint) || m_canvas->hitsCanvasPoint(mousePointDoc, gradientColorPoint))
 				{
@@ -911,7 +911,7 @@ void CanvasMode_EditMeshGradient::mouseP
 				for (int gcol = 0; gcol < currItem->meshGradientArray[grow].count(); gcol++)
 				{
 					MeshPoint mp = currItem->meshGradientArray[grow][gcol];
-					QPointF gradientPoint = QPointF(mp.gridPoint.x(), mp.gridPoint.y());
+					QPointF gradientPoint(mp.gridPoint.x(), mp.gridPoint.y());
 					gradientPoint = itemMatrix.map(gradientPoint);
 					if (m_canvas->hitsCanvasPoint(mousePointDoc, gradientPoint))
 					{
diff -Napur a/scribus/canvasmode_editmeshpatch.cpp f/scribus/canvasmode_editmeshpatch.cpp
--- a/scribus/canvasmode_editmeshpatch.cpp	2025-01-08 21:31:43.000000000 +0100
+++ f/scribus/canvasmode_editmeshpatch.cpp	2025-02-07 13:56:48.344894963 +0100
@@ -1032,10 +1032,10 @@ void CanvasMode_EditMeshPatch::snapToOth
 		if (col != m_currItem->selectedMeshPointX)
 		{
 			meshGradientPatch patch = m_currItem->meshGradientPatches[col];
-			QPointF mp1 = QPointF(patch.TL.gridPoint.x(), patch.TL.gridPoint.y());
-			QPointF mp2 = QPointF(patch.TR.gridPoint.x(), patch.TR.gridPoint.y());
-			QPointF mp3 = QPointF(patch.BR.gridPoint.x(), patch.BR.gridPoint.y());
-			QPointF mp4 = QPointF(patch.BL.gridPoint.x(), patch.BL.gridPoint.y());
+			QPointF mp1(patch.TL.gridPoint.x(), patch.TL.gridPoint.y());
+			QPointF mp2(patch.TR.gridPoint.x(), patch.TR.gridPoint.y());
+			QPointF mp3(patch.BR.gridPoint.x(), patch.BR.gridPoint.y());
+			QPointF mp4(patch.BL.gridPoint.x(), patch.BL.gridPoint.y());
 			if (qAbs(mp1.x() - x) < radius && qAbs(mp1.y() - y) < radius)
 			{
 				x = mp1.x();
diff -Napur a/scribus/canvasmode_editpolygon.cpp f/scribus/canvasmode_editpolygon.cpp
--- a/scribus/canvasmode_editpolygon.cpp	2025-01-08 21:31:45.000000000 +0100
+++ f/scribus/canvasmode_editpolygon.cpp	2025-02-07 13:56:48.344894963 +0100
@@ -162,11 +162,11 @@ void CanvasMode_EditPolygon::updateFromI
 	uint cx = m_polyUseFactor ? m_polyCorners * 2 : m_polyCorners;
 	double seg = 360.0 / cx;
 	double trueLength = sqrt(pow(sin(seg / 180.0 * M_PI) * (item->width() / 2.0), 2) + pow(cos(seg / 180.0 * M_PI) * (item->height() / 2.0) + (item->height()/2.0) - item->height(), 2));
-	QLineF innerLine = QLineF(m_endPoint, m_centerPoint);
+	QLineF innerLine(m_endPoint, m_centerPoint);
 	innerLine.setAngle(innerLine.angle() + 90);
 	innerLine.setLength(trueLength * m_polyCurvature);
 	m_innerCPoint = innerLine.p2();
-	QLineF outerLine = QLineF(m_startPoint, currItem->PoLine.pointQF(6));
+	QLineF outerLine(m_startPoint, currItem->PoLine.pointQF(6));
 	outerLine.setLength(outerLine.length() * m_polyOuterCurvature);
 	m_outerCPoint = outerLine.p2();
 	m_view->update();
@@ -202,11 +202,11 @@ void CanvasMode_EditPolygon::activate(bo
 	uint cx = m_polyUseFactor ? m_polyCorners * 2 : m_polyCorners;
 	double seg = 360.0 / cx;
 	double trueLength = sqrt(pow(sin(seg / 180.0 * M_PI) * (item->width() / 2.0), 2) + pow(cos(seg / 180.0 * M_PI) * (item->height() / 2.0) + (item->height()/2.0) - item->height(), 2));
-	QLineF innerLine = QLineF(m_endPoint, m_centerPoint);
+	QLineF innerLine(m_endPoint, m_centerPoint);
 	innerLine.setAngle(innerLine.angle() + 90);
 	innerLine.setLength(trueLength * m_polyCurvature);
 	m_innerCPoint = innerLine.p2();
-	QLineF outerLine = QLineF(m_startPoint, currItem->PoLine.pointQF(6));
+	QLineF outerLine(m_startPoint, currItem->PoLine.pointQF(6));
 	outerLine.setLength(outerLine.length() * m_polyOuterCurvature);
 	m_outerCPoint = outerLine.p2();
 	setModeCursor();
@@ -345,7 +345,7 @@ void CanvasMode_EditPolygon::mouseMoveEv
 		PageItem *currItem = m_doc->m_Selection->itemAt(0);
 		QTransform itemMatrix = currItem->getTransform();
 		QPointF cPoint = itemMatrix.map(m_centerPoint);
-		QLineF stLinA = QLineF(cPoint, QPointF(newX, newY));
+		QLineF stLinA(cPoint, QPointF(newX, newY));
 		
 		uint cx = m_polyUseFactor ? m_polyCorners * 2 : m_polyCorners;
 		double seg = 360.0 / cx;
@@ -370,15 +370,15 @@ void CanvasMode_EditPolygon::mouseMoveEv
 		if (m_polygonPoint == useControlInnerCurve)
 		{
 			QPointF ePoint = itemMatrix.map(m_endPoint);
-			QLineF stLinC = QLineF(ePoint, QPointF(newX, newY));
+			QLineF stLinC(ePoint, QPointF(newX, newY));
 			m_polyCurvature = stLinC.length() / trueLength;
 		}
 		if (m_polygonPoint == useControlOuterCurve)
 		{
 			QPointF sPoint = itemMatrix.map(m_startPoint);
 			QPointF sPoint2 = itemMatrix.map(currItem->PoLine.pointQF(6));
-			QLineF stLinCo = QLineF(sPoint, QPointF(newX, newY));
-			QLineF stLinCo2 = QLineF(sPoint, sPoint2);
+			QLineF stLinCo(sPoint, QPointF(newX, newY));
+			QLineF stLinCo2(sPoint, sPoint2);
 			m_polyOuterCurvature = stLinCo.length() / stLinCo2.length();
 		}
 		QPainterPath path = regularPolygonPath(currItem->width(), currItem->height(), m_polyCorners, m_polyUseFactor, m_polyFactor, m_polyRotation, m_polyCurvature, m_polyInnerRot, m_polyOuterCurvature);
@@ -386,11 +386,11 @@ void CanvasMode_EditPolygon::mouseMoveEv
 		ar.fromQPainterPath(path);
 		m_endPoint = ar.pointQF(2);
 		m_startPoint = ar.pointQF(0);
-		QLineF innerLine = QLineF(m_endPoint, m_centerPoint);
+		QLineF innerLine(m_endPoint, m_centerPoint);
 		innerLine.setAngle(innerLine.angle() + 90);
 		innerLine.setLength(trueLength * m_polyCurvature);
 		m_innerCPoint = innerLine.p2();
-		QLineF outerLine = QLineF(m_startPoint, ar.pointQF(6));
+		QLineF outerLine(m_startPoint, ar.pointQF(6));
 		outerLine.setLength(outerLine.length() * m_polyOuterCurvature);
 		m_outerCPoint = outerLine.p2();
 		m_VectorDialog->setValues(m_polyCorners, m_polyFactor, m_polyUseFactor, m_polyRotation, m_polyCurvature, m_polyInnerRot, m_polyOuterCurvature);
@@ -490,7 +490,7 @@ void CanvasMode_EditPolygon::mouseReleas
 		double newX = mousePointDoc.x();
 		double newY = mousePointDoc.y();
 		QPointF cPoint = itemMatrix.map(m_centerPoint);
-		QLineF stLinA = QLineF(cPoint, QPointF(newX, newY));
+		QLineF stLinA(cPoint, QPointF(newX, newY));
 		uint cx = m_polyUseFactor ? m_polyCorners * 2 : m_polyCorners;
 		double seg = 360.0 / cx;
 		double trueLength = sqrt(pow(sin(seg / 180.0 * M_PI) * (currItem->width() / 2.0), 2) + pow(cos(seg / 180.0 * M_PI) * (currItem->height() / 2.0) + (currItem->height()/2.0) - currItem->height(), 2));
@@ -504,15 +504,15 @@ void CanvasMode_EditPolygon::mouseReleas
 		if (m_polygonPoint == useControlInnerCurve)
 		{
 			QPointF ePoint = itemMatrix.map(m_endPoint);
-			QLineF stLinC = QLineF(ePoint, QPointF(newX, newY));
+			QLineF stLinC(ePoint, QPointF(newX, newY));
 			m_polyCurvature = stLinC.length() / trueLength;
 		}
 		if (m_polygonPoint == useControlOuterCurve)
 		{
 			QPointF sPoint = itemMatrix.map(m_startPoint);
 			QPointF sPoint2 = itemMatrix.map(currItem->PoLine.pointQF(6));
-			QLineF stLinCo = QLineF(sPoint, QPointF(newX, newY));
-			QLineF stLinCo2 = QLineF(sPoint, sPoint2);
+			QLineF stLinCo(sPoint, QPointF(newX, newY));
+			QLineF stLinCo2(sPoint, sPoint2);
 			m_polyOuterCurvature = stLinCo.length() / stLinCo2.length();
 		}
 		item->polyFactor = m_polyFactor;
diff -Napur a/scribus/canvasmode_editspiral.cpp f/scribus/canvasmode_editspiral.cpp
--- a/scribus/canvasmode_editspiral.cpp	2025-01-08 21:31:45.000000000 +0100
+++ f/scribus/canvasmode_editspiral.cpp	2025-02-07 13:56:48.344894963 +0100
@@ -187,12 +187,12 @@ QPointF CanvasMode_EditSpiral::getSegmen
 	double segStart = 0.0;
 	double segEnd = 180;
 	bool segPart = true;
-	QPointF ret = QPointF(item->width() / 2.0, item->height() / 2.0);
+	QPointF ret(item->width() / 2.0, item->height() / 2.0);
 	if (angle < 0)
 		return ret;
 	while (true)
 	{
-		QLineF lin = QLineF(QPointF(wws, hh), QPointF(wwn, hh));
+		QLineF lin(QPointF(wws, hh), QPointF(wwn, hh));
 		if ((angle <= segEnd) && (angle >= segStart))
 		{
 			ret = lin.pointAt(0.5);
@@ -219,7 +219,7 @@ double CanvasMode_EditSpiral::computeRea
 	double part = angle - (rev * 360);
 	QTransform bb;
 	bb.scale(currItem->width() / currItem->height(), 1.0);
-	QLineF inp = QLineF(QPointF(currItem->width() / 2.0, currItem->height() / 2.0), QPointF(currItem->width(), currItem->height() / 2.0));
+	QLineF inp(QPointF(currItem->width() / 2.0, currItem->height() / 2.0), QPointF(currItem->width(), currItem->height() / 2.0));
 	inp.setAngle(part);
 	if (fromDia)
 	{
@@ -296,8 +296,8 @@ void CanvasMode_EditSpiral::mouseMoveEve
 		else if (m_arcPoint == useControlEnd)
 			sPoint = getSegment(m_endAngle);
 		QPointF smPoint = itemMatrix.map(sPoint);
-		QLineF stLinA = QLineF(smPoint, QPointF(m_Mxp, m_Myp));
-		QLineF stLinM = QLineF(smPoint, QPointF(newX, newY));
+		QLineF stLinA(smPoint, QPointF(m_Mxp, m_Myp));
+		QLineF stLinM(smPoint, QPointF(newX, newY));
 		double deltaAngle = stLinM.angle() - stLinA.angle();
 		if (deltaAngle < -180)
 			deltaAngle = deltaAngle + 360;
diff -Napur a/scribus/canvasmode_normal.cpp f/scribus/canvasmode_normal.cpp
--- a/scribus/canvasmode_normal.cpp	2025-01-08 21:31:43.000000000 +0100
+++ f/scribus/canvasmode_normal.cpp	2025-02-07 13:56:48.345894945 +0100
@@ -756,7 +756,7 @@ void CanvasMode_Normal::mouseMoveEvent(Q
 					break;
 				QTransform p;
 				m_canvas->Transform(currItem, p);
-				QRect mpo = QRect(m->x() - m_doc->guidesPrefs().grabRadius, m->y() - m_doc->guidesPrefs().grabRadius, m_doc->guidesPrefs().grabRadius * 2, m_doc->guidesPrefs().grabRadius * 2);
+				QRect mpo(m->x() - m_doc->guidesPrefs().grabRadius, m->y() - m_doc->guidesPrefs().grabRadius, m_doc->guidesPrefs().grabRadius * 2, m_doc->guidesPrefs().grabRadius * 2);
 				if (QRegion(p.map(QPolygon(QRect(-3, -3, static_cast<int>(currItem->width() + 6), static_cast<int>(currItem->height() + 6))))).contains(mpo))
 				{
 					QRect tx = p.mapRect(QRect(0, 0, static_cast<int>(currItem->width()), static_cast<int>(currItem->height())));
diff -Napur a/scribus/canvasmode_rotate.cpp f/scribus/canvasmode_rotate.cpp
--- a/scribus/canvasmode_rotate.cpp	2025-01-08 21:31:45.000000000 +0100
+++ f/scribus/canvasmode_rotate.cpp	2025-02-07 13:56:48.345894945 +0100
@@ -416,7 +416,7 @@ void CanvasMode_Rotate::mouseMoveEvent(Q
 					break;
 				QTransform p;
 				m_canvas->Transform(currItem, p);
-				QRect mpo = QRect(m->x() - m_doc->guidesPrefs().grabRadius, m->y() - m_doc->guidesPrefs().grabRadius, m_doc->guidesPrefs().grabRadius * 2, m_doc->guidesPrefs().grabRadius * 2);
+				QRect mpo(m->x() - m_doc->guidesPrefs().grabRadius, m->y() - m_doc->guidesPrefs().grabRadius, m_doc->guidesPrefs().grabRadius * 2, m_doc->guidesPrefs().grabRadius * 2);
 				if ((QRegion(p.map(QPolygon(QRect(-3, -3, static_cast<int>(currItem->width() + 6), static_cast<int>(currItem->height() + 6))))).contains(mpo)))
 				{
 					QRect tx = p.mapRect(QRect(0, 0, static_cast<int>(currItem->width()), static_cast<int>(currItem->height())));
diff -Napur a/scribus/collect4output.cpp f/scribus/collect4output.cpp
--- a/scribus/collect4output.cpp	2025-01-08 21:31:45.000000000 +0100
+++ f/scribus/collect4output.cpp	2025-02-07 13:56:48.346894927 +0100
@@ -290,7 +290,7 @@ void CollectForOutput::processItem(PageI
 	{
 		PageItem_OSGFrame *osgframe = ite->asOSGFrame();
 		QString ofName(osgframe->modelFile);
-		QFileInfo itf = QFileInfo(ofName);
+		QFileInfo itf(ofName);
 		if (!itf.exists())
 		{
 			ofName = QDir::toNativeSeparators(PrefsManager::instance().documentDir() + "/" + ofName);
diff -Napur a/scribus/documentchecker.cpp f/scribus/documentchecker.cpp
--- a/scribus/documentchecker.cpp	2025-01-08 21:31:43.000000000 +0100
+++ f/scribus/documentchecker.cpp	2025-02-07 13:56:48.346894927 +0100
@@ -305,7 +305,7 @@ void DocumentChecker::checkItems(Scribus
 					if  (((qRound(72.0 / currItem->imageXScale()) > checkerSettings.maxResolution) || (qRound(72.0 / currItem->imageYScale()) > checkerSettings.maxResolution))
 							&& (currItem->isRaster) && (checkerSettings.checkResolution))
 						itemError.insert(ImageDPITooHigh, 0);
-					QFileInfo fi = QFileInfo(currItem->Pfile);
+					QFileInfo fi(currItem->Pfile);
 					QString ext = fi.suffix().toLower();
 					if (extensionIndicatesPDF(ext) && (checkerSettings.checkRasterPDF))
 						itemError.insert(PlacedPDF, 0);
@@ -569,7 +569,7 @@ void DocumentChecker::checkItems(Scribus
 					if  (((qRound(72.0 / currItem->imageXScale()) > checkerSettings.maxResolution) || (qRound(72.0 / currItem->imageYScale()) > checkerSettings.maxResolution))
 							&& (currItem->isRaster) && (checkerSettings.checkResolution))
 						itemError.insert(ImageDPITooHigh, 0);
-					QFileInfo fi = QFileInfo(currItem->Pfile);
+					QFileInfo fi(currItem->Pfile);
 					QString ext = fi.suffix().toLower();
 					if (extensionIndicatesPDF(ext) && (checkerSettings.checkRasterPDF))
 						itemError.insert(PlacedPDF, 0);
diff -Napur a/scribus/fileloader.cpp f/scribus/fileloader.cpp
--- a/scribus/fileloader.cpp	2025-01-08 21:31:39.000000000 +0100
+++ f/scribus/fileloader.cpp	2025-02-07 13:56:48.341895016 +0100
@@ -20,7 +20,6 @@ for which a new license (GPL+exception)
 #include <QProgressBar>
 #include <QRegExp>
 #include <QtAlgorithms>
-#include <QTextCodec>
 #include <QTextStream>
 
 #include "commonstrings.h"
@@ -106,7 +105,7 @@ const QString FileLoader::getLoadFilterS
  */
 int FileLoader::testFile()
 {
-	QFileInfo fi = QFileInfo(m_fileName);
+	QFileInfo fi(m_fileName);
 	int ret = -1;
 	if (!fi.exists())
 		ret = -1;
diff -Napur a/scribus/gtaction.h f/scribus/gtaction.h
--- a/scribus/gtaction.h	2025-01-08 21:31:40.000000000 +0100
+++ f/scribus/gtaction.h	2025-02-07 13:56:48.341895016 +0100
@@ -28,7 +28,6 @@ for which a new license (GPL+exception)
 #define GTACTION_H
 
 #include <QColor>
-#include <QTextCodec>
 #include <QMap>
 #include <QString>
 
diff -Napur a/scribus/hyphenator.cpp f/scribus/hyphenator.cpp
--- a/scribus/hyphenator.cpp	2025-01-08 00:06:53.000000000 +0100
+++ f/scribus/hyphenator.cpp	2025-02-07 13:56:48.342894998 +0100
@@ -26,9 +26,11 @@ for which a new license (GPL+exception)
 #include "scconfig.h"
 
 #include <QApplication>
-#include <QCursor>
-#include <QCheckBox>
 #include <QByteArray>
+#include <QCheckBox>
+#include <QCursor>
+#include <QTextCodec>
+
 #include <unicode/brkiter.h>
 
 #include "langmgr.h"
diff -Napur a/scribus/hyphenator.h f/scribus/hyphenator.h
--- a/scribus/hyphenator.h	2025-01-08 21:31:45.000000000 +0100
+++ f/scribus/hyphenator.h	2025-02-07 13:56:48.342894998 +0100
@@ -8,7 +8,6 @@ for which a new license (GPL+exception)
 #define HYPLUG_H
 
 #include <QObject>
-#include <QTextCodec>
 #include <QHash>
 #include <QSet>
 
@@ -18,6 +17,7 @@ for which a new license (GPL+exception)
 class ScribusDoc;
 class ScribusMainWindow;
 class PageItem;
+class QTextCodec;
 
 /*!
 This class is the core of the Scribus hyphenation system.
diff -Napur a/scribus/imagedataloaders/scimgdataloader_qt.cpp f/scribus/imagedataloaders/scimgdataloader_qt.cpp
diff -Napur a/scribus/pageitem_line.cpp f/scribus/pageitem_line.cpp
--- a/scribus/pageitem_line.cpp	2025-01-08 21:31:43.000000000 +0100
+++ f/scribus/pageitem_line.cpp	2025-02-07 13:56:48.345894945 +0100
@@ -221,7 +221,7 @@ void PageItem_Line::getBoundingRect(doub
 		*y2 = m_yPos + qMax(1.0, m_lineWidth) / 2.0;
 	}
 
-	QRectF totalRect = QRectF(QPointF(*x1, *y1), QPointF(*x2, *y2));
+	QRectF totalRect(QPointF(*x1, *y1), QPointF(*x2, *y2));
 	if (m_startArrowIndex != 0)
 	{
 		QRectF arrowRect = getStartArrowBoundingRect();
@@ -269,7 +269,7 @@ void PageItem_Line::getOldBoundingRect(d
 		*y2 = oldYpos + qMax(1.0, m_oldLineWidth) / 2.0;
 	}
 
-	QRectF totalRect = QRectF(QPointF(*x1, *y1), QPointF(*x2, *y2));
+	QRectF totalRect(QPointF(*x1, *y1), QPointF(*x2, *y2));
 	if (m_startArrowIndex != 0)
 	{
 		QRectF arrowRect = getStartArrowOldBoundingRect();
diff -Napur a/scribus/pageitem_textframe.cpp f/scribus/pageitem_textframe.cpp
--- a/scribus/pageitem_textframe.cpp	2025-01-08 21:31:39.000000000 +0100
+++ f/scribus/pageitem_textframe.cpp	2025-02-07 13:56:48.346894927 +0100
@@ -1436,7 +1436,7 @@ void PageItem_TextFrame::layout()
 			int a = current.glyphs[currentIndex].firstChar();
 			bool HasObject = itemText.hasObject(a);
 			PageItem* currentObject = itemText.object(a).getPageItem(m_Doc);
-			QRectF currentObjectBox = QRectF();
+			QRectF currentObjectBox;
 			if (HasObject)
 				currentObjectBox = currentObject->getVisualBoundingRect();
 
@@ -3375,7 +3375,7 @@ void PageItem_TextFrame::DrawObj_Item(Sc
 					mm.scale(fontSize / 10.0, fontSize / 10.0);
 					chkPath = mm.map(chkPath);
 					QRectF bb = chkPath.boundingRect();
-					QRectF bi = QRectF(0.0, 0.0, m_width, m_height);
+					QRectF bi(0.0, 0.0, m_width, m_height);
 					double dx = bi.center().x() - (bb.width() / 2.0);
 					double dy = bi.center().y() - (bb.height() / 2.0);
 					p->translate(dx, dy);
diff -Napur a/scribus/plugins/export/svgexplugin/svgexplugin.cpp f/scribus/plugins/export/svgexplugin/svgexplugin.cpp
--- a/scribus/plugins/export/svgexplugin/svgexplugin.cpp	2025-01-08 21:31:37.000000000 +0100
+++ f/scribus/plugins/export/svgexplugin/svgexplugin.cpp	2025-02-07 13:56:47.962901797 +0100
@@ -1077,13 +1077,13 @@ QDomElement SVGExPlug::processImageItem(
 		}
 		else
 		{
-			QFileInfo fi = QFileInfo(item->Pfile);
+			QFileInfo fi(item->Pfile);
 			QString imgFileName = m_baseDir + "/" + fi.baseName() + ".png";
-			QFileInfo im = QFileInfo(imgFileName);
+			QFileInfo im(imgFileName);
 			if (im.exists())
 				imgFileName = m_baseDir + "/" + fi.baseName() + "_copy.png";
 			img.qImage().save(imgFileName, "PNG");
-			QFileInfo fi2 = QFileInfo(imgFileName);
+			QFileInfo fi2(imgFileName);
 			ob3.setAttribute("xlink:href", fi2.baseName() + ".png");
 		}
 		ob3.setAttribute("x", FToStr(item->imageXOffset() * item->imageXScale()));
diff -Napur a/scribus/plugins/export/xpsexport/xpsexplugin.cpp f/scribus/plugins/export/xpsexport/xpsexplugin.cpp
--- a/scribus/plugins/export/xpsexport/xpsexplugin.cpp	2025-01-08 21:31:37.000000000 +0100
+++ f/scribus/plugins/export/xpsexport/xpsexplugin.cpp	2025-02-07 13:56:47.960901832 +0100
@@ -648,7 +648,7 @@ void XPSExPlug::processLineItem(double x
 		double y1 = yOffset * conversionFactor;
 		double x2 = (item->width() + xOffset) * conversionFactor;
 		double y2 = yOffset * conversionFactor;
-		QLineF line = QLineF(x1, y1, x2, y2);
+		QLineF line(x1, y1, x2, y2);
 		line.setAngle(-item->rotation());
 		if (item->NamedLStyle.isEmpty())
 		{
diff -Napur a/scribus/plugins/gettext/csvim/csvim.cpp f/scribus/plugins/gettext/csvim/csvim.cpp
--- a/scribus/plugins/gettext/csvim/csvim.cpp	2025-01-08 21:31:34.000000000 +0100
+++ f/scribus/plugins/gettext/csvim/csvim.cpp	2025-02-07 13:56:47.922902512 +0100
@@ -4,6 +4,9 @@ to the COPYING file provided with the pr
 a copyright and/or license notice that predates the release of Scribus 1.3.2
 for which a new license (GPL+exception) is in place.
 */
+
+#include <QTextCodec>
+
 #include "csvim.h"
 #include "gtwriter.h"
 #include "gtparagraphstyle.h"
diff -Napur a/scribus/plugins/gettext/csvim/csvim.h f/scribus/plugins/gettext/csvim/csvim.h
--- a/scribus/plugins/gettext/csvim/csvim.h	2025-01-08 21:31:34.000000000 +0100
+++ f/scribus/plugins/gettext/csvim/csvim.h	2025-02-07 13:56:47.922902512 +0100
@@ -14,7 +14,6 @@ for which a new license (GPL+exception)
 #include <QFileInfo>
 #include <QString>
 #include <QStringList>
-#include <QTextCodec>
 
 class gtParagraphStyle;
 class gtWriter;
diff -Napur a/scribus/plugins/import/ai/importai.cpp f/scribus/plugins/import/ai/importai.cpp
--- a/scribus/plugins/import/ai/importai.cpp	2025-01-08 00:06:55.000000000 +0100
+++ f/scribus/plugins/import/ai/importai.cpp	2025-02-07 13:56:47.905902816 +0100
@@ -299,7 +299,7 @@ bool AIPlug::import(const QString& fName
 	importedGradients.clear();
 	importedPatterns.clear();
 	QFileInfo fi(fName);
-	if ( !ScCore->usingGUI() )
+	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
@@ -334,7 +334,7 @@ bool AIPlug::import(const QString& fName
 		if (tempBuf.startsWith("%AI12_CompressedData"))
 			decompressAIData(fName);
 	}
-	if ( showProgress )
+	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
diff -Napur a/scribus/plugins/import/cdr/importcdr.cpp f/scribus/plugins/import/cdr/importcdr.cpp
--- a/scribus/plugins/import/cdr/importcdr.cpp	2025-01-08 00:06:55.000000000 +0100
+++ f/scribus/plugins/import/cdr/importcdr.cpp	2025-02-07 13:56:47.875903353 +0100
@@ -119,15 +119,14 @@ bool CdrPlug::import(const QString& fNam
 	interactive = (flags & LoadSavePlugin::lfInteractive);
 	importerFlags = flags;
 	cancel = false;
-	double b, h;
 	bool ret = false;
 	QFileInfo fi(fNameIn);
-	if ( !ScCore->usingGUI() )
+	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	if ( showProgress )
+	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
@@ -147,8 +146,8 @@ bool CdrPlug::import(const QString& fNam
 	else
 		progressDialog = nullptr;
 /* Set default Page to size defined in Preferences */
-	b = 0.0;
-	h = 0.0;
+	double b = 0.0;
+	double h = 0.0;
 	if (progressDialog)
 	{
 		progressDialog->setOverallProgress(1);
diff -Napur a/scribus/plugins/import/cgm/importcgm.cpp f/scribus/plugins/import/cgm/importcgm.cpp
--- a/scribus/plugins/import/cgm/importcgm.cpp	2025-01-08 00:06:56.000000000 +0100
+++ f/scribus/plugins/import/cgm/importcgm.cpp	2025-02-07 13:56:47.856903693 +0100
@@ -107,11 +107,10 @@ CgmPlug::CgmPlug(ScribusDoc* doc, int fl
 
 QImage CgmPlug::readThumbnail(const QString& fName)
 {
-	QFileInfo fi = QFileInfo(fName);
-	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
-	double b, h;
-	b = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
-	h = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
+	QFileInfo fi(fName);
+	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
+	double b = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
+	double h = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
 	docWidth = b;
 	docHeight = h;
 	progressDialog = nullptr;
@@ -169,16 +168,15 @@ bool CgmPlug::import(const QString& fNam
 	interactive = (flags & LoadSavePlugin::lfInteractive);
 	importerFlags = flags;
 	cancel = false;
-	double b, h;
 	bool ret = false;
 	CustColors.clear();
-	QFileInfo fi = QFileInfo(fNameIn);
+	QFileInfo fi(fNameIn);
 	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
+	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
 	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
@@ -199,15 +197,13 @@ bool CgmPlug::import(const QString& fNam
 	else
 		progressDialog = nullptr;
 /* Set default Page to size defined in Preferences */
-	b = 0.0;
-	h = 0.0;
 	if (progressDialog)
 	{
 		progressDialog->setOverallProgress(1);
 		qApp->processEvents();
 	}
-	b = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
-	h = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
+	double b = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
+	double h = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
 	docWidth = b;
 	docHeight = h;
 	baseX = 0;
@@ -953,7 +949,7 @@ void CgmPlug::decodeClass2(QDataStream &
 		QPointF max, min;
 		max = getBinaryCoords(ts, true);
 		min = getBinaryCoords(ts, true);
-		QRectF vd = QRectF(max, min);
+		QRectF vd(max, min);
 		vcdFlippedV = (vd.height() > 0);
 		vcdFlippedH = (vd.width() < 0);
 		vd = vd.normalized();
@@ -1087,7 +1083,7 @@ void CgmPlug::decodeClass3(QDataStream &
 		QPointF max, min;
 		max = getBinaryCoords(ts);
 		min = getBinaryCoords(ts);
-		QRectF vd = QRectF(max, min);
+		QRectF vd(max, min);
 		vd = vd.normalized();
 		double w = convertCoords(vd.width());
 		double h = convertCoords(vd.height());
@@ -1429,8 +1425,8 @@ void CgmPlug::decodeClass4(QDataStream &
 		}
 		ts >> mode;
 		int bytesRead = ts.device()->pos() - pos;
-		QLineF pr = QLineF(p, r);
-		QLineF rq = QLineF(r, q);
+		QLineF pr(p, r);
+		QLineF rq(r, q);
 		double originX = p.x();
 		double originY = p.y();
 		bool flipX = false;
@@ -1586,10 +1582,9 @@ void CgmPlug::decodeClass4(QDataStream &
 	}
 	else if (elemID == 11)
 	{
-		QPointF max, min;
-		max = getBinaryCoords(ts);
-		min = getBinaryCoords(ts);
-		QRectF vd = QRectF(max, min);
+		QPointF max = getBinaryCoords(ts);
+		QPointF min = getBinaryCoords(ts);
+		QRectF vd(max, min);
 		vd = vd.normalized();
 		double w = convertCoords(vd.width());
 		double h = convertCoords(vd.height());
@@ -1632,17 +1627,17 @@ void CgmPlug::decodeClass4(QDataStream &
 		QPointF pStart = convertCoords(getBinaryCoords(ts));
 		QPointF pInter = convertCoords(getBinaryCoords(ts));
 		QPointF pEnd = convertCoords(getBinaryCoords(ts));
-		QLineF s_e = QLineF(pStart, pEnd);
+		QLineF s_e(pStart, pEnd);
 		QLineF n_s = s_e.normalVector();
 		n_s.translate(s_e.pointAt(0.5) - s_e.p1());
-		QLineF s_i = QLineF(pStart, pInter);
+		QLineF s_i(pStart, pInter);
 		QLineF n_i = s_i.normalVector();
 		n_i.translate(s_i.pointAt(0.5) - s_i.p1());
 		QPointF center;
 		if (n_s.intersects(n_i, &center) != QLineF::NoIntersection)
 		{
-			QLineF rad1 = QLineF(center, pStart);
-			QLineF rad3 = QLineF(center, pInter);
+			QLineF rad1(center, pStart);
+			QLineF rad3(center, pInter);
 			double radius = rad1.length();
 			Coords.resize(0);
 			Coords.svgInit();
@@ -1680,17 +1675,17 @@ void CgmPlug::decodeClass4(QDataStream &
 		QPointF pEnd = convertCoords(getBinaryCoords(ts));
 		quint16 mode;
 		ts >> mode;
-		QLineF s_e = QLineF(pStart, pEnd);
+		QLineF s_e(pStart, pEnd);
 		QLineF n_s = s_e.normalVector();
 		n_s.translate(s_e.pointAt(0.5) - s_e.p1());
-		QLineF s_i = QLineF(pStart, pInter);
+		QLineF s_i(pStart, pInter);
 		QLineF n_i = s_i.normalVector();
 		n_i.translate(s_i.pointAt(0.5) - s_i.p1());
 		QPointF center;
 		if (n_s.intersects(n_i, &center) != QLineF::NoIntersection)
 		{
-			QLineF rad1 = QLineF(center, pStart);
-			QLineF rad3 = QLineF(center, pInter);
+			QLineF rad1(center, pStart);
+			QLineF rad3(center, pInter);
 			double radius = rad1.length();
 			Coords.resize(0);
 			Coords.svgInit();
@@ -1742,8 +1737,8 @@ void CgmPlug::decodeClass4(QDataStream &
 			sx *= -1;
 			ex *= -1;
 		}
-		QLineF stv = QLineF(cx, cy, cx + sx, cy + sy);
-		QLineF env = QLineF(cx, cy, cx + ex, cy + ey);
+		QLineF stv(cx, cy, cx + sx, cy + sy);
+		QLineF env(cx, cy, cx + ex, cy + ey);
 		QPainterPath ell;
 		if (qFuzzyCompare(sx, ex) && qFuzzyCompare(sy, ey))
 		{
@@ -1799,8 +1794,8 @@ void CgmPlug::decodeClass4(QDataStream &
 			sx *= -1;
 			ex *= -1;
 		}
-		QLineF stv = QLineF(cx, cy, cx + sx, cy + sy);
-		QLineF env = QLineF(cx, cy, cx + ex, cy + ey);
+		QLineF stv(cx, cy, cx + sx, cy + sy);
+		QLineF env(cx, cy, cx + ex, cy + ey);
 		QPainterPath ell;
 		if (qFuzzyCompare(sx, ex) && qFuzzyCompare(sy, ey))
 		{
@@ -1886,8 +1881,8 @@ void CgmPlug::decodeClass4(QDataStream &
 		QPointF r2 = getBinaryCoords(ts);
 		double r2x = convertCoords(r2.x());
 		double r2y = convertCoords(r2.y());
-		QLineF dstX = QLineF(cx, cy, r1x, r1y);
-		QLineF dstY = QLineF(cx, cy, r2x, r2y);
+		QLineF dstX(cx, cy, r1x, r1y);
+		QLineF dstY(cx, cy, r2x, r2y);
 		double distX = dstX.length();
 		double distY = dstY.length();
 		double rotB = dstX.angle();
@@ -1905,8 +1900,8 @@ void CgmPlug::decodeClass4(QDataStream &
 			sx *= -1;
 			ex *= -1;
 		}
-		QLineF stv = QLineF(cx, cy, cx + sx, cy + sy);
-		QLineF env = QLineF(cx, cy, cx + ex, cy + ey);
+		QLineF stv(cx, cy, cx + sx, cy + sy);
+		QLineF env(cx, cy, cx + ex, cy + ey);
 		QPainterPath ell;
 		ell.addEllipse(QPointF(cx, cy), distX, distY);
 		ell.translate(-cx, -cy);
@@ -1990,8 +1985,8 @@ void CgmPlug::decodeClass4(QDataStream &
 		QPointF r2 = getBinaryCoords(ts);
 		double r2x = convertCoords(r2.x());
 		double r2y = convertCoords(r2.y());
-		QLineF dstX = QLineF(cx, cy, r1x, r1y);
-		QLineF dstY = QLineF(cx, cy, r2x, r2y);
+		QLineF dstX(cx, cy, r1x, r1y);
+		QLineF dstY(cx, cy, r2x, r2y);
 		double distX = dstX.length();
 		double distY = dstY.length();
 		double rotB = dstX.angle();
@@ -2010,8 +2005,8 @@ void CgmPlug::decodeClass4(QDataStream &
 			sx *= -1;
 			ex *= -1;
 		}
-		QLineF stv = QLineF(cx, cy, cx + sx, cy + sy);
-		QLineF env = QLineF(cx, cy, cx + ex, cy + ey);
+		QLineF stv(cx, cy, cx + sx, cy + sy);
+		QLineF env(cx, cy, cx + ex, cy + ey);
 		QPainterPath ell;
 		ell.addEllipse(QPointF(cx, cy), distX, distY);
 		ell.translate(-cx, -cy);
@@ -2440,8 +2435,8 @@ void CgmPlug::decodeClass5(QDataStream &
 		double phy = convertCoords(getBinaryDistance(ts));
 		double pwx = convertCoords(getBinaryDistance(ts));
 		double pwy = convertCoords(getBinaryDistance(ts));
-		QLineF hp = QLineF(0, 0, phx, phy);
-		QLineF wp = QLineF(0, 0, pwx, pwy);
+		QLineF hp(0, 0, phx, phy);
+		QLineF wp(0, 0, pwx, pwy);
 		patternScaleX = wp.length();
 		patternScaleY = hp.length();
 	//	qDebug() << "PATTERN SIZE" << wp.length() << hp.length();
diff -Napur a/scribus/plugins/import/cvg/importcvg.cpp f/scribus/plugins/import/cvg/importcvg.cpp
--- a/scribus/plugins/import/cvg/importcvg.cpp	2025-01-08 00:06:56.000000000 +0100
+++ f/scribus/plugins/import/cvg/importcvg.cpp	2025-02-07 13:56:47.877903317 +0100
@@ -58,8 +58,8 @@ CvgPlug::CvgPlug(ScribusDoc* doc, int fl
 
 QImage CvgPlug::readThumbnail(const QString& fName)
 {
-	QFileInfo fi = QFileInfo(fName);
-	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
+	QFileInfo fi(fName);
+	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
 	double b, h;
 	parseHeader(fName, b, h);
 	if (b == 0.0)
@@ -123,17 +123,16 @@ bool CvgPlug::import(const QString& fNam
 	interactive = (flags & LoadSavePlugin::lfInteractive);
 	importerFlags = flags;
 	cancel = false;
-	double b, h;
 	bool ret = false;
 	CustColors.clear();
-	QFileInfo fi = QFileInfo(fNameIn);
-	if ( !ScCore->usingGUI() )
+	QFileInfo fi(fNameIn);
+	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
-	if ( showProgress )
+	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
+	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
@@ -153,8 +152,8 @@ bool CvgPlug::import(const QString& fNam
 	else
 		progressDialog = nullptr;
 /* Set default Page to size defined in Preferences */
-	b = 0.0;
-	h = 0.0;
+	double b = 0.0;
+	double h = 0.0;
 	if (progressDialog)
 	{
 		progressDialog->setOverallProgress(1);
diff -Napur a/scribus/plugins/import/drw/importdrw.cpp f/scribus/plugins/import/drw/importdrw.cpp
--- a/scribus/plugins/import/drw/importdrw.cpp	2025-01-08 00:06:56.000000000 +0100
+++ f/scribus/plugins/import/drw/importdrw.cpp	2025-02-07 13:56:47.880903264 +0100
@@ -67,8 +67,8 @@ DrwPlug::DrwPlug(ScribusDoc* doc, int fl
 
 QImage DrwPlug::readThumbnail(const QString& fName)
 {
-	QFileInfo fi = QFileInfo(fName);
-	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
+	QFileInfo fi(fName);
+	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
 	double b = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
 	double h = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
 	docWidth = b;
@@ -140,16 +140,15 @@ bool DrwPlug::import(const QString& fNam
 	interactive = (flags & LoadSavePlugin::lfInteractive);
 	importerFlags = flags;
 	cancel = false;
-	double b, h;
 	bool ret = false;
-	QFileInfo fi = QFileInfo(fNameIn);
-	if ( !ScCore->usingGUI() )
+	QFileInfo fi(fNameIn);
+	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
-	if ( showProgress )
+	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
+	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
@@ -169,15 +168,13 @@ bool DrwPlug::import(const QString& fNam
 	else
 		progressDialog = nullptr;
 /* Set default Page to size defined in Preferences */
-	b = 0.0;
-	h = 0.0;
 	if (progressDialog)
 	{
 		progressDialog->setOverallProgress(1);
 		qApp->processEvents();
 	}
-	b = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
-	h = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
+	double b = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
+	double h = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
 	docWidth = b;
 	docHeight = h;
 	baseX = 0;
diff -Napur a/scribus/plugins/import/emf/importemf.cpp f/scribus/plugins/import/emf/importemf.cpp
--- a/scribus/plugins/import/emf/importemf.cpp	2025-01-08 00:06:56.000000000 +0100
+++ f/scribus/plugins/import/emf/importemf.cpp	2025-02-07 13:56:47.834904087 +0100
@@ -21,7 +21,6 @@ for which a new license (GPL+exception)
 #include <QRawFont>
 #include <QRegExp>
 #include <QScopedPointer>
-#include <QTextCodec>
 #include <QUuid>
 
 #include <cstdlib>
@@ -540,13 +539,13 @@ bool EmfPlug::import(const QString& fNam
 	double x, y, b, h;
 	bool ret = false;
 	QFileInfo fi(fNameIn);
-	if ( !ScCore->usingGUI() )
+	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
-	if ( showProgress )
+	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
+	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
@@ -3935,7 +3934,7 @@ quint32 EmfPlug::handleEMPBrush(QDataStr
 		{
 			float m11, m12, m21, m22, dx, dy;
 			ds >> m11 >> m12 >> m21 >> m22 >> dx >> dy;
-			QLineF lin = QLineF(rect[0], rect[2]);
+			QLineF lin(rect[0], rect[2]);
 			lin = QTransform(m11, m12, m21, m22, dx, dy).map(lin);
 			sty.gradientAngle = lin.angle() + 45;
 		}
diff -Napur a/scribus/plugins/import/fh/importfh.cpp f/scribus/plugins/import/fh/importfh.cpp
--- a/scribus/plugins/import/fh/importfh.cpp	2025-01-08 00:06:55.000000000 +0100
+++ f/scribus/plugins/import/fh/importfh.cpp	2025-02-07 13:56:47.882903228 +0100
@@ -66,10 +66,9 @@ FhPlug::FhPlug(ScribusDoc* doc, int flag
 
 QImage FhPlug::readThumbnail(const QString& fName)
 {
-	QFileInfo fi = QFileInfo(fName);
-	double b, h;
-	b = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
-	h = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
+	QFileInfo fi(fName);
+	double b = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
+	double h = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
 	docWidth = b;
 	docHeight = h;
 	progressDialog = nullptr;
@@ -127,15 +126,14 @@ bool FhPlug::import(const QString& fName
 	interactive = (flags & LoadSavePlugin::lfInteractive);
 	importerFlags = flags;
 	cancel = false;
-	double b, h;
 	bool ret = false;
-	QFileInfo fi = QFileInfo(fNameIn);
-	if ( !ScCore->usingGUI() )
+	QFileInfo fi(fNameIn);
+	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	if ( showProgress )
+	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
@@ -155,8 +153,8 @@ bool FhPlug::import(const QString& fName
 	else
 		progressDialog = nullptr;
 /* Set default Page to size defined in Preferences */
-	b = 0.0;
-	h = 0.0;
+	double b = 0.0;
+	double h = 0.0;
 	if (progressDialog)
 	{
 		progressDialog->setOverallProgress(1);
diff -Napur a/scribus/plugins/import/idml/importidml.cpp f/scribus/plugins/import/idml/importidml.cpp
--- a/scribus/plugins/import/idml/importidml.cpp	2025-01-08 00:06:56.000000000 +0100
+++ f/scribus/plugins/import/idml/importidml.cpp	2025-02-07 13:56:47.859903639 +0100
@@ -104,9 +104,9 @@ QImage IdmlPlug::readThumbnail(const QSt
 {
 	QImage tmp;
 	QByteArray f;
-	if ( !QFile::exists(fName) )
+	if (!QFile::exists(fName))
 		return QImage();
-	QFileInfo fi = QFileInfo(fName);
+	QFileInfo fi(fName);
 	QString ext = fi.suffix().toLower();
 	if (ext == "idml")
 	{
@@ -160,8 +160,8 @@ QImage IdmlPlug::readThumbnail(const QSt
 	if (!found)
 	{
 		progressDialog = nullptr;
-		QFileInfo fi = QFileInfo(fName);
-		baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
+		QFileInfo fi(fName);
+		baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
 		docWidth = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
 		docHeight = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
 		m_Doc = new ScribusDoc();
@@ -219,7 +219,7 @@ bool IdmlPlug::readColors(const QString&
 	importedColors.clear();
 
 	QByteArray f;
-	QFileInfo fi = QFileInfo(fileName);
+	QFileInfo fi(fileName);
 	QString ext = fi.suffix().toLower();
 	if (ext == "idml")
 	{
@@ -303,13 +303,13 @@ bool IdmlPlug::import(const QString& fNa
 	firstPage = true;
 	pagecount = 1;
 	mpagecount = 0;
-	QFileInfo fi = QFileInfo(fNameIn);
+	QFileInfo fi(fNameIn);
 	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
+	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
 	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
@@ -534,7 +534,7 @@ bool IdmlPlug::convert(const QString& fn
 	bool firstSpread = true;
 
 	QByteArray f;
-	QFileInfo fi = QFileInfo(fn);
+	QFileInfo fi(fn);
 	QString ext = fi.suffix().toLower();
 	if (ext == "idml")
 	{
@@ -1954,13 +1954,13 @@ QList<PageItem*> IdmlPlug::parseItemXML(
 							QString rDir = itpo.attribute("RightDirection");
 							ScTextStream an(&anchor, QIODevice::ReadOnly);
 							an >> x1 >> y1;
-							QPointF aP = QPointF(x1, y1);
+							QPointF aP(x1, y1);
 							ScTextStream lr(&lDir, QIODevice::ReadOnly);
 							lr >> x2 >> y2;
-							QPointF lP = QPointF(x2, y2);
+							QPointF lP(x2, y2);
 							ScTextStream rr(&rDir, QIODevice::ReadOnly);
 							rr >> x3 >> y3;
-							QPointF rP = QPointF(x3, y3);
+							QPointF rP(x3, y3);
 
 							if (firstPoint)
 							{
@@ -2165,7 +2165,7 @@ QList<PageItem*> IdmlPlug::parseItemXML(
 		getTransformValuesFromMatrix(finalMat, scX, scY, rot, dx, dy);
 		if ((finalMat.m11() < 0) && (finalMat.m12() == 0) && (finalMat.m21() == 0))
 		{
-			QLineF line = QLineF(0.0, 0.0, 1.0, 0.0);
+			QLineF line(0.0, 0.0, 1.0, 0.0);
 			line.setAngle(rot);
 			QTransform matrix;
 			matrix.scale(-1, 0);
@@ -2253,7 +2253,7 @@ QList<PageItem*> IdmlPlug::parseItemXML(
 				item->setFillEvenOdd(false);
 				if (!fillGradient.isEmpty())
 				{
-					QLineF gradientVector = QLineF(gstX, gstY, gstX + 1, gstY);
+					QLineF gradientVector(gstX, gstY, gstX + 1, gstY);
 					gradientVector.setLength(gLen);
 					gradientVector.setAngle(gAngle);
 					gradientVector.translate(-grOffset.x(), -grOffset.y());
@@ -2264,7 +2264,7 @@ QList<PageItem*> IdmlPlug::parseItemXML(
 				}
 				if (!strokeGradient.isEmpty())
 				{
-					QLineF gradientVector = QLineF(gstSX, gstSY, gstSX + 1, gstSY);
+					QLineF gradientVector(gstSX, gstSY, gstSX + 1, gstSY);
 					gradientVector.setLength(gSLen);
 					gradientVector.setAngle(gSAngle);
 					gradientVector.translate(-grOffset.x(), -grOffset.y());
@@ -2489,7 +2489,7 @@ QList<PageItem*> IdmlPlug::parseItemXML(
 			item->setFillEvenOdd(false);
 			if (!fillGradient.isEmpty())
 			{
-				QLineF gradientVector = QLineF(gstX, gstY, gstX + 1, gstY);
+				QLineF gradientVector(gstX, gstY, gstX + 1, gstY);
 				gradientVector.setLength(gLen);
 				gradientVector.setAngle(gAngle);
 				gradientVector.translate(-grOffset.x(), -grOffset.y());
@@ -2500,7 +2500,7 @@ QList<PageItem*> IdmlPlug::parseItemXML(
 			}
 			if (!strokeGradient.isEmpty())
 			{
-				QLineF gradientVector = QLineF(gstSX, gstSY, gstSX + 1, gstSY);
+				QLineF gradientVector(gstSX, gstSY, gstSX + 1, gstSY);
 				gradientVector.setLength(gSLen);
 				gradientVector.setAngle(gSAngle);
 				gradientVector.translate(-grOffset.x(), -grOffset.y());
@@ -2537,7 +2537,7 @@ QList<PageItem*> IdmlPlug::parseItemXML(
 					}
 				}
 			}
-			QRectF br = QRectF(0, 0, item->width(), item->height());
+			QRectF br(0, 0, item->width(), item->height());
 			QTransform ma;
 			ma.rotate(-rot);
 			QRectF br2 = ma.mapRect(br);
diff -Napur a/scribus/plugins/import/odg/importodg.cpp f/scribus/plugins/import/odg/importodg.cpp
--- a/scribus/plugins/import/odg/importodg.cpp	2025-01-08 00:06:55.000000000 +0100
+++ f/scribus/plugins/import/odg/importodg.cpp	2025-02-07 13:56:47.863903568 +0100
@@ -3695,18 +3695,18 @@ void OdgPlug::finishItem(PageItem* item,
 			P5 = pPoints[4];
 			P6 = pPoints[5];
 /*
-			QPointF cpL = QPointF(item->width() * gStyle.gradientCenterX, item->height()* gStyle.gradientCenterY);
+			QPointF cpL(item->width() * gStyle.gradientCenterX, item->height()* gStyle.gradientCenterY);
 			double lineLen = sqrt(gLenW * gLenW + gLenH * gLenH) * 2.0;
-			QLineF iLineP1 = QLineF(cpL, P1);
+			QLineF iLineP1(cpL, P1);
 			iLineP1.setLength(lineLen);
 			P1 = intersectBoundingRect(item, iLineP1);
-			QLineF iLineP2 = QLineF(cpL, P2);
+			QLineF iLineP2(cpL, P2);
 			iLineP2.setLength(lineLen);
 			P2 = intersectBoundingRect(item, iLineP2);
-			QLineF iLineP3 = QLineF(cpL, P3);
+			QLineF iLineP3(cpL, P3);
 			iLineP3.setLength(lineLen);
 			P3 = intersectBoundingRect(item, iLineP3);
-			QLineF iLineP4 = QLineF(cpL, P4);
+			QLineF iLineP4(cpL, P4);
 			iLineP4.setLength(lineLen);
 			P4 = intersectBoundingRect(item, iLineP4);
 			item->setDiamondGeometry(FPoint(P1.x(), P1.y()), FPoint(P2.x(), P2.y()), FPoint(P3.x(), P3.y()), FPoint(P4.x(), P4.y()), cp);
diff -Napur a/scribus/plugins/import/pages/importpages.cpp f/scribus/plugins/import/pages/importpages.cpp
--- a/scribus/plugins/import/pages/importpages.cpp	2025-01-08 00:06:55.000000000 +0100
+++ f/scribus/plugins/import/pages/importpages.cpp	2025-02-07 13:56:47.885903174 +0100
@@ -118,8 +118,8 @@ QImage PagesPlug::readThumbnail(const QS
 	}
 /*	else
 	{
-		QFileInfo fi = QFileInfo(fName);
-		baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
+		QFileInfo fi(fName);
+		baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
 		docWidth = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
 		docHeight = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
 		m_Doc = new ScribusDoc();
@@ -195,12 +195,12 @@ bool PagesPlug::import(const QString& fN
 	pagecount = 1;
 	mpagecount = 0;
 	QFileInfo fi(fNameIn);
-	if ( !ScCore->usingGUI() )
+	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	if ( showProgress )
+	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
diff -Napur a/scribus/plugins/import/pct/importpct.cpp f/scribus/plugins/import/pct/importpct.cpp
--- a/scribus/plugins/import/pct/importpct.cpp	2025-01-08 00:06:56.000000000 +0100
+++ f/scribus/plugins/import/pct/importpct.cpp	2025-02-07 13:56:47.866903514 +0100
@@ -61,8 +61,8 @@ PctPlug::PctPlug(ScribusDoc* doc, int fl
 
 QImage PctPlug::readThumbnail(const QString& fName)
 {
-	QFileInfo fi = QFileInfo(fName);
-	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
+	QFileInfo fi(fName);
+	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
 	double b {0.0};
 	double h {0.0};
 	double x {0.0};
@@ -131,14 +131,14 @@ bool PctPlug::import(const QString& fNam
 	cancel = false;
 	bool ret = false;
 	CustColors.clear();
-	QFileInfo fi = QFileInfo(fNameIn);
-	if ( !ScCore->usingGUI() )
+	QFileInfo fi(fNameIn);
+	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
-	if ( showProgress )
+	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
+	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
@@ -1598,7 +1598,7 @@ void PctPlug::handleShortLine(QDataStrea
 		currentPoint = QPoint(x * resX, y * resY);
 		return;
 	}
-	QPoint s = QPoint(x * resX, y * resY);
+	QPoint s(x * resX, y * resY);
 	if (currentPoint != s)
 	{
 		handleLineModeEnd();
@@ -1630,7 +1630,7 @@ void PctPlug::handleLine(QDataStream &ts
 	qint16 x1, x2, y1, y2;
 	ts >> y1 >> x1;
 	ts >> y2 >> x2;
-	QPoint s = QPoint(x1 * resX, y1 * resY);
+	QPoint s(x1 * resX, y1 * resY);
 	if (currentPoint != s)
 	{
 		handleLineModeEnd();
diff -Napur a/scribus/plugins/import/pdf/importpdf.cpp f/scribus/plugins/import/pdf/importpdf.cpp
--- a/scribus/plugins/import/pdf/importpdf.cpp	2025-01-08 00:06:55.000000000 +0100
+++ f/scribus/plugins/import/pdf/importpdf.cpp	2025-02-07 13:56:47.829904176 +0100
@@ -148,13 +148,13 @@ bool PdfPlug::import(const QString& fNam
 	m_cancel = false;
 	bool ret = false;
 	QFileInfo fi(fNameIn);
-	if ( !ScCore->usingGUI() )
+	if (!ScCore->usingGUI())
 	{
 		m_interactive = false;
 		showProgress = false;
 	}
-	m_baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
-	if ( showProgress )
+	m_baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
+	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		m_progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
@@ -462,11 +462,11 @@ bool PdfPlug::convert(const QString& fn)
 
 			if (dev->isOk())
 			{
-				OCGs* ocg = pdfDoc->getOptContentConfig();
+				POPPLER_CONST_25_02 OCGs* ocg = pdfDoc->getOptContentConfig();
 				if (ocg && ocg->hasOCGs())
 				{
 					QStringList ocgNames;
-					Array *order = ocg->getOrderArray();
+					POPPLER_CONST_25_02 Array *order = ocg->getOrderArray();
 					if (order)
 					{
 						for (int i = 0; i < order->getLength (); ++i)
@@ -928,7 +928,7 @@ QRectF PdfPlug::getCBox(int box, int pgN
 
 QString PdfPlug::UnicodeParsedString(const GooString *s1)
 {
-	if ( !s1 || s1->getLength() == 0 )
+	if (!s1 || s1->getLength() == 0)
 		return QString();
 	bool isUnicode;
 	int i;
diff -Napur a/scribus/plugins/import/pdf/importpdfconfig.h f/scribus/plugins/import/pdf/importpdfconfig.h
--- a/scribus/plugins/import/pdf/importpdfconfig.h	2025-01-08 00:06:55.000000000 +0100
+++ f/scribus/plugins/import/pdf/importpdfconfig.h	2025-02-07 13:56:47.829904176 +0100
@@ -27,4 +27,10 @@ for which a new license (GPL+exception)
 #define POPPLER_CONST_083
 #endif
 
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)
+#define POPPLER_CONST_25_02 const
+#else
+#define POPPLER_CONST_25_02
+#endif
+
 #endif
diff -Napur a/scribus/plugins/import/pdf/pdftextrecognition.cpp f/scribus/plugins/import/pdf/pdftextrecognition.cpp
--- a/scribus/plugins/import/pdf/pdftextrecognition.cpp	2025-01-08 00:06:55.000000000 +0100
+++ f/scribus/plugins/import/pdf/pdftextrecognition.cpp	2025-02-07 13:56:47.829904176 +0100
@@ -14,7 +14,7 @@ constexpr double PdfTextRegion::bounding
 */
 PdfTextRecognition::PdfTextRecognition()
 {
-	m_pdfTextRegions.push_back(PdfTextRegion());
+	m_pdfTextRegions.emplace_back();
 	activePdfTextRegion = &(m_pdfTextRegions.back());
 	setCharMode(AddCharMode::ADDFIRSTCHAR);
 }
@@ -31,7 +31,7 @@ PdfTextRecognition::~PdfTextRecognition(
 */
 void PdfTextRecognition::addPdfTextRegion()
 {
-	m_pdfTextRegions.push_back(PdfTextRegion());
+	m_pdfTextRegions.emplace_back();
 	activePdfTextRegion = &(m_pdfTextRegions.back());
 	setCharMode(PdfTextRecognition::AddCharMode::ADDFIRSTCHAR);
 }
@@ -66,12 +66,12 @@ void PdfTextRecognition::addChar(GfxStat
 /*
 *	basic test to see if the point lies in a new line or region
 */
-bool PdfTextRecognition::isNewLineOrRegion(QPointF newPosition)
+bool PdfTextRecognition::isNewLineOrRegion(const QPointF& newPosition)
 {
-	return (activePdfTextRegion->collinear(activePdfTextRegion->lastXY.y(), activePdfTextRegion->pdfTextRegionLines.back().baseOrigin.y()) &&
-		!activePdfTextRegion->collinear(newPosition.y(), activePdfTextRegion->lastXY.y()))
-		|| (activePdfTextRegion->collinear(newPosition.y(), activePdfTextRegion->lastXY.y())
-			&& !activePdfTextRegion->isCloseToX(newPosition.x(), activePdfTextRegion->lastXY.x()));
+	return (PdfTextRegion::collinear(activePdfTextRegion->lastXY.y(), activePdfTextRegion->pdfTextRegionLines.back().baseOrigin.y()) &&
+	           !PdfTextRegion::collinear(newPosition.y(), activePdfTextRegion->lastXY.y()))
+	        || (PdfTextRegion::collinear(newPosition.y(), activePdfTextRegion->lastXY.y())
+	            && !activePdfTextRegion->isCloseToX(newPosition.x(), activePdfTextRegion->lastXY.x()));
 }
 
 
@@ -188,7 +188,7 @@ bool PdfTextRegion::collinear(qreal a, q
 *	like collinear but we allow a deviation of 6 text widths from between positions or 1 text width from the textregion's x origin
 *   FIXME: This should use the char width not linespacing which is y
 */
-bool PdfTextRegion::isCloseToX(qreal x1, qreal x2)
+bool PdfTextRegion::isCloseToX(qreal x1, qreal x2) const
 {
 	return (abs(x2 - x1) <= lineSpacing * 6) || (abs(x1 - this->pdfTextRegionBasenOrigin.x()) <= lineSpacing);
 }
@@ -196,7 +196,7 @@ bool PdfTextRegion::isCloseToX(qreal x1,
 /*
 *	like collinear but we allow a deviation of 3 text heights downwards but none upwards
 */
-bool PdfTextRegion::isCloseToY(qreal y1, qreal y2)
+bool PdfTextRegion::isCloseToY(qreal y1, qreal y2) const
 {
 	return (y2 - y1) >= 0 && y2 - y1 <= lineSpacing * 3;
 }
@@ -204,7 +204,7 @@ bool PdfTextRegion::isCloseToY(qreal y1,
 /*
 *	less than, page upwards, the last y value but bot more than the line spacing less, could also use the base line of the last line to be more accurate
 */
-bool PdfTextRegion::adjunctLesser(qreal testY, qreal lastY, qreal baseY)
+bool PdfTextRegion::adjunctLesser(qreal testY, qreal lastY, qreal baseY) const
 {
 	return (testY > lastY
 		&& testY <= baseY + lineSpacing
@@ -214,7 +214,7 @@ bool PdfTextRegion::adjunctLesser(qreal
 /*
 *	greater, page downwards, than the last y value but not more than 3/4 of a line space below baseline
 */
-bool PdfTextRegion::adjunctGreater(qreal testY, qreal lastY, qreal baseY)
+bool PdfTextRegion::adjunctGreater(qreal testY, qreal lastY, qreal baseY) const
 {
 	return (testY <= lastY
 		&& testY >= baseY - lineSpacing * 0.75
@@ -232,7 +232,7 @@ bool PdfTextRegion::adjunctGreater(qreal
 *	TODO: support NEWLINE new paragraphs with multiple linespaces and indented x insteads of just ignoring the relative x position
 *	TODO: I don't know if the invariant qDebug cases should always report an error or only do so when DEBUG_TEXT_IMPORT is defined. My feeling is they should always report because it meanms something has happened that shouldn't have and it's useful feedback.
 */
-PdfTextRegion::LineType PdfTextRegion::linearTest(QPointF point, bool xInLimits, bool yInLimits)
+PdfTextRegion::LineType PdfTextRegion::linearTest(const QPointF& point, bool xInLimits, bool yInLimits) const
 {
 	if (collinear(point.y(), lastXY.y()))
 	{
@@ -282,7 +282,7 @@ PdfTextRegion::LineType PdfTextRegion::l
 *	Perform some fuzzy checks to see if newPoint can reasonably be ascribed to the current textframe.
 *	FIXME: It may be that move and addGlyph need different versions of isCloseToX and isCloseToY but keep them the same just for now
 */
-PdfTextRegion::LineType PdfTextRegion::isRegionConcurrent(QPointF newPoint)
+PdfTextRegion::LineType PdfTextRegion::isRegionConcurrent(const QPointF& newPoint)
 {
 	if (glyphs.empty())
 	{
@@ -306,7 +306,7 @@ PdfTextRegion::LineType PdfTextRegion::i
 *		Also needs to have support for rotated text, but I expect I'll add this by removing the text rotation
 *		from calls to movepoint and addGlyph and instead rotating the whole text region as a block
 */
-PdfTextRegion::LineType PdfTextRegion::moveToPoint(QPointF newPoint)
+PdfTextRegion::LineType PdfTextRegion::moveToPoint(const QPointF& newPoint)
 {
 	//qDebug() << "moveToPoint: " << newPoint;
 
@@ -323,7 +323,7 @@ PdfTextRegion::LineType PdfTextRegion::m
 	if (mode == LineType::NEWLINE || mode == LineType::FIRSTPOINT)
 	{
 		if (mode != LineType::FIRSTPOINT || pdfTextRegionLines.empty())
-			pdfTextRegionLines.push_back(PdfTextRegionLine());
+			pdfTextRegionLines.emplace_back();
 
 		pdfTextRegionLine = &pdfTextRegionLines.back();
 		pdfTextRegionLine->baseOrigin = newPoint;
@@ -340,7 +340,7 @@ PdfTextRegion::LineType PdfTextRegion::m
 		|| mode == LineType::NEWLINE
 		|| (mode != LineType::FIRSTPOINT && pdfTextRegionLine->segments[0].glyphIndex != pdfTextRegionLine->glyphIndex))
 	{
-		PdfTextRegionLine newSegment = PdfTextRegionLine();
+		PdfTextRegionLine newSegment;
 		pdfTextRegionLine->segments.push_back(newSegment);
 	}
 	PdfTextRegionLine* segment = &pdfTextRegionLine->segments.back();
@@ -373,9 +373,9 @@ PdfTextRegion::LineType PdfTextRegion::m
 *		Approximated heights and widths and linespaces need to use the correct font data when font support has been added,
 *		but for now just use the x advance value. using font data should also allow for the support of rotated text that may use a mixture of x and y advance
 */
-PdfTextRegion::LineType PdfTextRegion::addGlyphAtPoint(QPointF newGlyphPoint, PdfGlyph newGlyph)
+PdfTextRegion::LineType PdfTextRegion::addGlyphAtPoint(const QPointF& newGlyphPoint, const PdfGlyph& newGlyph)
 {
-	QPointF movedGlyphPoint = QPointF(newGlyphPoint.x() + newGlyph.dx, newGlyphPoint.y() + newGlyph.dy);
+	QPointF movedGlyphPoint(newGlyphPoint.x() + newGlyph.dx, newGlyphPoint.y() + newGlyph.dy);
 	if (glyphs.size() == 1)
 	{
 		lineSpacing = newGlyph.dx * 3;
@@ -436,7 +436,7 @@ void PdfTextRegion::renderToTextFrame(Pa
 /*
 *	Quick test to see if this is a virgin textregion
 */
-bool PdfTextRegion::isNew()
+bool PdfTextRegion::isNew() const
 {
 	return pdfTextRegionLines.empty() ||
 		glyphs.empty();
diff -Napur a/scribus/plugins/import/pdf/pdftextrecognition.h f/scribus/plugins/import/pdf/pdftextrecognition.h
--- a/scribus/plugins/import/pdf/pdftextrecognition.h	2025-01-08 00:06:55.000000000 +0100
+++ f/scribus/plugins/import/pdf/pdftextrecognition.h	2025-02-07 13:56:47.829904176 +0100
@@ -24,9 +24,9 @@ for which a new license (GPL+exception)
 */
 struct PdfGlyph
 {
-	double dx;  // X advance value
-	double dy;  // Y advance value
-	double rise;    // Text rise parameter
+	double dx { 0.0 };  // X advance value
+	double dy { 0.0 };  // Y advance value
+	double rise { 0.0 };    // Text rise parameter
 	QChar code;   // UTF-16 coded character
 };
 
@@ -89,16 +89,16 @@ public:
 	std::vector<PdfGlyph> glyphs;
 
 	static bool collinear(qreal a, qreal b);
-	bool isCloseToX(qreal x1, qreal x2);
-	bool isCloseToY(qreal y1, qreal y2);
-	bool adjunctLesser(qreal testY, qreal lastY, qreal baseY);
-	bool adjunctGreater(qreal testY, qreal lastY, qreal baseY);
-	PdfTextRegion::LineType linearTest(QPointF point, bool xInLimits, bool yInLimits);
-	PdfTextRegion::LineType isRegionConcurrent(QPointF newPoint);
-	PdfTextRegion::LineType moveToPoint(QPointF newPoint);
-	PdfTextRegion::LineType addGlyphAtPoint(QPointF newGlyphPoint, PdfGlyph new_glyph);
+	bool isCloseToX(qreal x1, qreal x2) const;
+	bool isCloseToY(qreal y1, qreal y2) const;
+	bool adjunctLesser(qreal testY, qreal lastY, qreal baseY) const;
+	bool adjunctGreater(qreal testY, qreal lastY, qreal baseY) const;
+	PdfTextRegion::LineType linearTest(const QPointF& point, bool xInLimits, bool yInLimits) const;
+	PdfTextRegion::LineType isRegionConcurrent(const QPointF& newPoint);
+	PdfTextRegion::LineType moveToPoint(const QPointF& newPoint);
+	PdfTextRegion::LineType addGlyphAtPoint(const QPointF& newGlyphPoint, const PdfGlyph& new_glyph);
 	void renderToTextFrame(PageItem* textNode);
-	bool isNew();
+	bool isNew() const;
 };
 
 class PdfTextRecognition
@@ -125,7 +125,7 @@ public:
 
 	void addPdfTextRegion();
 	void addChar(GfxState* state, double x, double y, double dx, double dy, double originX, double originY, CharCode code, int nBytes, POPPLER_CONST_082 Unicode* u, int uLen);
-	bool isNewLineOrRegion(QPointF newPosition);
+	bool isNewLineOrRegion(const QPointF& newPosition);
 
 private:
 	std::vector<PdfTextRegion> m_pdfTextRegions = std::vector<PdfTextRegion>();
diff -Napur a/scribus/plugins/import/pdf/slaoutput.cpp f/scribus/plugins/import/pdf/slaoutput.cpp
--- a/scribus/plugins/import/pdf/slaoutput.cpp	2025-01-08 00:06:55.000000000 +0100
+++ f/scribus/plugins/import/pdf/slaoutput.cpp	2025-02-07 13:56:47.829904176 +0100
@@ -1685,7 +1685,7 @@ void SlaOutputDev::stroke(GfxState *stat
 
 	auto& graphicState = m_graphicStack.top();
 	graphicState.strokeColor = getColor(state->getStrokeColorSpace(), state->getStrokeColor(), &graphicState.strokeShade);
-	
+
 	QString output = convertPath(state->getPath());
 	if ((m_Elements->count() != 0) && (output == m_coords))			// Path is the same as in last fill
 	{
@@ -2393,8 +2393,9 @@ bool SlaOutputDev::tilingPatternFill(Gfx
 #endif
 	m_graphicStack.top().clipPath = savedClip;
 	m_inPattern--;
-	gElements = m_groupStack.pop();
 	m_doc->m_Selection->clear();
+
+	gElements = m_groupStack.pop();
 	if (gElements.Items.count() > 0)
 	{
 		for (int dre = 0; dre < gElements.Items.count(); ++dre)
@@ -2693,7 +2694,7 @@ void SlaOutputDev::drawMaskedImage(GfxSt
 		}
 	}
 
-	createImageFrame(res, state, colorMap->getNumPixelComps());
+	createImageFrame(res, state, 3);
 
 	delete[] buffer;
 	delete[] mbuffer;
@@ -2932,7 +2933,7 @@ void SlaOutputDev::beginMarkedContent(co
 	{
 		if (dictRef->isNull())
 			return;
-		OCGs *contentConfig = m_catalog->getOptContentConfig();
+		POPPLER_CONST_25_02 OCGs *contentConfig = m_catalog->getOptContentConfig();
 		OptionalContentGroup *oc;
 		if (dictRef->isRef())
 		{
@@ -3084,7 +3085,11 @@ void SlaOutputDev::updateFont(GfxState *
 #if POPPLER_ENCODED_VERSION < POPPLER_VERSION_ENCODE(22, 4, 0)
 	int tmpBufLen = 0;
 #endif
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)
+	std::vector<int> codeToGID;
+#else
 	int *codeToGID = nullptr;
+#endif
 	const double *textMat = nullptr;
 	double m11, m12, m21, m22, fontSize;
 	SplashCoord mat[4] = { 1.0, 0.0, 0.0, 1.0 };
@@ -3244,10 +3249,20 @@ void SlaOutputDev::updateFont(GfxState *
 			}
 			else
 			{
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)
+				codeToGID.clear();
+#else
 				codeToGID = nullptr;
+#endif
 				n = 0;
 			}
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)
+			if (!(fontFile = m_fontEngine->loadTrueTypeFont(std::move(id), fontsrc, std::move(codeToGID), fontLoc->fontNum)))
+			{
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
+				goto err2;
+			}
+#elif POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)
 			if (!(fontFile = m_fontEngine->loadTrueTypeFont(std::move(id), fontsrc, codeToGID, n, fontLoc->fontNum)))
 			{
 				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
@@ -3278,6 +3293,18 @@ void SlaOutputDev::updateFont(GfxState *
 #endif
 			break;
 		case fontCIDType0COT:
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)
+			if (((GfxCIDFont*) gfxFont)->getCIDToGIDLen() > 0)
+			{
+				codeToGID = ((GfxCIDFont*) gfxFont)->getCIDToGID();
+				n = codeToGID.size();
+			}
+			else
+			{
+				codeToGID.clear();
+				n = 0;
+			}
+#else
 			if (((GfxCIDFont *) gfxFont)->getCIDToGID())
 			{
 				n = ((GfxCIDFont *) gfxFont)->getCIDToGIDLen();
@@ -3289,7 +3316,15 @@ void SlaOutputDev::updateFont(GfxState *
 				codeToGID = nullptr;
 				n = 0;
 			}
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)
+#endif
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)
+			if (!(fontFile = m_fontEngine->loadOpenTypeCFFFont(std::move(id), fontsrc, std::move(codeToGID), fontLoc->fontNum)))
+			{
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'",
+					gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
+				goto err2;
+			}
+#elif POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)
 			if (!(fontFile = m_fontEngine->loadOpenTypeCFFFont(std::move(id), fontsrc, codeToGID, n, fontLoc->fontNum)))
 			{
 				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'",
@@ -3307,6 +3342,15 @@ void SlaOutputDev::updateFont(GfxState *
 			break;
 		case fontCIDType2:
 		case fontCIDType2OT:
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)
+			codeToGID.clear();
+			n = 0;
+			if (((GfxCIDFont*) gfxFont)->getCIDToGIDLen() > 0)
+			{
+				codeToGID = ((GfxCIDFont*) gfxFont)->getCIDToGID();
+				n = codeToGID.size();
+			}
+#else
 			codeToGID = nullptr;
 			n = 0;
 			if (((GfxCIDFont *) gfxFont)->getCIDToGID())
@@ -3318,6 +3362,7 @@ void SlaOutputDev::updateFont(GfxState *
 					memcpy(codeToGID, ((GfxCIDFont *)gfxFont)->getCIDToGID(), n * sizeof(*codeToGID));
 				}
 			}
+#endif
 			else
 			{
 #if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)
@@ -3338,7 +3383,9 @@ void SlaOutputDev::updateFont(GfxState *
 #endif
 				if (! ff)
 					goto err2;
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 2, 0)
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)
+				codeToGID = ((GfxCIDFont*) gfxFont)->getCodeToGIDMap(ff.get());
+#elif POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 2, 0)
 				codeToGID = ((GfxCIDFont*) gfxFont)->getCodeToGIDMap(ff.get(), &n);
 				ff.reset();
 #else
@@ -3346,7 +3393,13 @@ void SlaOutputDev::updateFont(GfxState *
 				delete ff;
 #endif
 			}
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)
+			if (!(fontFile = m_fontEngine->loadTrueTypeFont(std::move(id), fontsrc, std::move(codeToGID), fontLoc->fontNum)))
+			{
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
+				goto err2;
+			}
+#elif POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)
 			if (!(fontFile = m_fontEngine->loadTrueTypeFont(std::move(id), fontsrc, codeToGID, n, fontLoc->fontNum)))
 			{
 				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
@@ -3959,7 +4012,7 @@ void SlaOutputDev::pushGroup(const QStri
 
 QString SlaOutputDev::UnicodeParsedString(const GooString *s1) const
 {
-	if ( !s1 || s1->getLength() == 0 )
+	if (!s1 || s1->getLength() == 0)
 		return QString();
 	bool isUnicode;
 	int i;
diff -Napur a/scribus/plugins/import/pm/importpm.cpp f/scribus/plugins/import/pm/importpm.cpp
--- a/scribus/plugins/import/pm/importpm.cpp	2025-01-08 00:06:55.000000000 +0100
+++ f/scribus/plugins/import/pm/importpm.cpp	2025-02-07 13:56:47.887903138 +0100
@@ -66,7 +66,7 @@ PmPlug::PmPlug(ScribusDoc* doc, int flag
 
 QImage PmPlug::readThumbnail(const QString& fName)
 {
-	QFileInfo fi = QFileInfo(fName);
+	QFileInfo fi(fName);
 	docWidth = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
 	docHeight = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
 	progressDialog = nullptr;
@@ -125,13 +125,13 @@ bool PmPlug::import(const QString& fName
 	importerFlags = flags;
 	cancel = false;
 	bool ret = false;
-	QFileInfo fi = QFileInfo(fNameIn);
-	if ( !ScCore->usingGUI() )
+	QFileInfo fi(fNameIn);
+	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	if ( showProgress )
+	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
diff -Napur a/scribus/plugins/import/pub/importpub.cpp f/scribus/plugins/import/pub/importpub.cpp
--- a/scribus/plugins/import/pub/importpub.cpp	2025-01-08 00:06:55.000000000 +0100
+++ f/scribus/plugins/import/pub/importpub.cpp	2025-02-07 13:56:47.890903085 +0100
@@ -69,7 +69,7 @@ PubPlug::PubPlug(ScribusDoc* doc, int fl
 
 QImage PubPlug::readThumbnail(const QString& fName)
 {
-	QFileInfo fi = QFileInfo(fName);
+	QFileInfo fi(fName);
 	docWidth = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
 	docHeight = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
 	progressDialog = nullptr;
@@ -128,13 +128,13 @@ bool PubPlug::import(const QString& fNam
 	importerFlags = flags;
 	cancel = false;
 	bool ret = false;
-	QFileInfo fi = QFileInfo(fNameIn);
-	if ( !ScCore->usingGUI() )
+	QFileInfo fi(fNameIn);
+	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	if ( showProgress )
+	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
diff -Napur a/scribus/plugins/import/qxp/importqxp.cpp f/scribus/plugins/import/qxp/importqxp.cpp
--- a/scribus/plugins/import/qxp/importqxp.cpp	2025-01-08 00:06:55.000000000 +0100
+++ f/scribus/plugins/import/qxp/importqxp.cpp	2025-02-07 13:56:47.892903049 +0100
@@ -68,10 +68,9 @@ QxpPlug::QxpPlug(ScribusDoc* doc, int fl
 
 QImage QxpPlug::readThumbnail(QString fName)
 {
-	QFileInfo fi = QFileInfo(fName);
-	double b, h;
-	b = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
-	h = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
+	QFileInfo fi(fName);
+	double b = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
+	double h = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
 	docWidth = b;
 	docHeight = h;
 	progressDialog = nullptr;
@@ -133,15 +132,14 @@ bool QxpPlug::import(QString fNameIn, co
 	interactive = (flags & LoadSavePlugin::lfInteractive);
 	importerFlags = flags;
 	cancel = false;
-	double b, h;
 	bool ret = false;
-	QFileInfo fi = QFileInfo(fName);
-	if ( !ScCore->usingGUI() )
+	QFileInfo fi(fName);
+	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	if ( showProgress )
+	if (showProgress)
 	{
 		ScribusMainWindow* mw=(m_Doc==0) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
@@ -161,8 +159,8 @@ bool QxpPlug::import(QString fNameIn, co
 	else
 		progressDialog = nullptr;
 /* Set default Page to size defined in Preferences */
-	b = 0.0;
-	h = 0.0;
+	double b = 0.0;
+	double h = 0.0;
 	if (progressDialog)
 	{
 		progressDialog->setOverallProgress(1);
diff -Napur a/scribus/plugins/import/revenge/rawpainter.cpp f/scribus/plugins/import/revenge/rawpainter.cpp
--- a/scribus/plugins/import/revenge/rawpainter.cpp	2025-01-08 00:06:56.000000000 +0100
+++ f/scribus/plugins/import/revenge/rawpainter.cpp	2025-02-07 13:56:47.848903836 +0100
@@ -1278,7 +1278,7 @@ void RawPainter::drawGraphicObject(const
 									rot = m_style["librevenge:rotate"]->getDouble();
 								QPainterPath ba;
 								ba.addRect(QRectF(x, y, w, h));
-								QRectF baR = QRectF(x, y, w, h);
+								QRectF baR(x, y, w, h);
 								if (rot != 0)
 								{
 									QTransform mm;
@@ -1860,7 +1860,7 @@ void RawPainter::applyFill(PageItem* ite
 				cx = m_style["svg:cx"]->getDouble();
 			if (m_style["svg:cy"])
 				cy = m_style["svg:cy"]->getDouble();
-			FPoint cp = FPoint(cx, cy);
+			FPoint cp(cx, cy);
 			ite->setDiamondGeometry(FPoint(0, 0), FPoint(ite->width(), 0), FPoint(ite->width(), ite->height()), FPoint(0, ite->height()), cp);
 			ite->fill_gradient.clearStops();
 			QList<VColorStop*> colorStops = m_currentGradient.colorStops();
@@ -1873,7 +1873,7 @@ void RawPainter::applyFill(PageItem* ite
 		else if (gradMode == "center")
 		{
 			QString center = "top-left";
-			FPoint cp = FPoint(0, 0);
+			FPoint cp(0, 0);
 			if (m_style["libmspub:shade-ref-point"])
 				center = QString(m_style["libmspub:shade-ref-point"]->getStr().cstr());
 			if (center == "top-left")
@@ -1943,7 +1943,7 @@ void RawPainter::applyFill(PageItem* ite
 				gpath = points;
 			}
 			ite->meshGradientPatches.clear();
-			FPoint center = FPoint(ite->width() / 2.0, ite->height() / 2.0);
+			FPoint center(ite->width() / 2.0, ite->height() / 2.0);
 			QList<VColorStop*> colorStops = m_currentGradient.colorStops();
 			if (colorStops.count() == 2)
 			{
@@ -3248,7 +3248,7 @@ void RawPainter::applyFill(PageItem* ite
 				cx = m_style["svg:cx"]->getDouble();
 			if (m_style["svg:cy"])
 				cy = m_style["svg:cy"]->getDouble();
-			FPoint cp = FPoint(cx, cy);
+			FPoint cp(cx, cy);
 			ite->setDiamondGeometry(FPoint(0, 0), FPoint(ite->width(), 0), FPoint(ite->width(), ite->height()), FPoint(0, ite->height()), cp);
 			ite->fill_gradient.clearStops();
 			QList<VColorStop*> colorStops = m_currentGradient.colorStops();
@@ -3261,7 +3261,7 @@ void RawPainter::applyFill(PageItem* ite
 		else if (gradMode == "center")
 		{
 			QString center = "top-left";
-			FPoint cp = FPoint(0, 0);
+			FPoint cp(0, 0);
 			if (m_style["libmspub:shade-ref-point"])
 				center = QString(m_style["libmspub:shade-ref-point"]->getStr().cstr());
 			if (center == "top-left")
@@ -3284,7 +3284,7 @@ void RawPainter::applyFill(PageItem* ite
 		else if (gradMode == "shape")
 		{
 			ite->meshGradientPatches.clear();
-			FPoint center = FPoint(ite->width() / 2.0, ite->height() / 2.0);
+			FPoint center(ite->width() / 2.0, ite->height() / 2.0);
 			MeshPoint cP;
 			cP.resetTo(center);
 			cP.transparency = m_gradColor2Trans;
@@ -3675,7 +3675,7 @@ void RawPainter::applyStartArrow(PageIte
 			continue;
 
 		double r = atan2(startPoint.y() - point.y(), startPoint.x() - point.x()) * (180.0 / M_PI);
-		QPointF refP = QPointF(br.width() / 2.0, 0);
+		QPointF refP(br.width() / 2.0, 0);
 		QTransform m;
 		m.translate(br.width() / 2.0, br.height() / 2.0);
 		m.rotate(r + 90);
@@ -3728,7 +3728,7 @@ void RawPainter::applyEndArrow(PageItem*
 			return;
 
 		double r = atan2(endPoint.y() - point.y(), endPoint.x() - point.x()) * (180.0 / M_PI);
-		QPointF refP = QPointF(br.width() / 2.0, 0);
+		QPointF refP(br.width() / 2.0, 0);
 		QTransform m;
 		m.translate(br.width() / 2.0, br.height() / 2.0);
 		m.rotate(r + 90);
diff -Napur a/scribus/plugins/import/shape/importshape.cpp f/scribus/plugins/import/shape/importshape.cpp
--- a/scribus/plugins/import/shape/importshape.cpp	2025-01-08 00:06:56.000000000 +0100
+++ f/scribus/plugins/import/shape/importshape.cpp	2025-02-07 13:56:47.850903800 +0100
@@ -61,8 +61,8 @@ ShapePlug::ShapePlug(ScribusDoc* doc, in
 
 QImage ShapePlug::readThumbnail(const QString& fName)
 {
-	QFileInfo fi = QFileInfo(fName);
-	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
+	QFileInfo fi(fName);
+	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
 	double b = 0.0, h = 0.0;
 	parseHeader(fName, b, h);
 	if (b == 0.0)
@@ -126,17 +126,15 @@ bool ShapePlug::import(const QString& fN
 	interactive = (flags & LoadSavePlugin::lfInteractive);
 	importerFlags = flags;
 	cancel = false;
-//	double x, y, b, h;
-	double b, h;
 	bool ret = false;
-	QFileInfo fi = QFileInfo(fNameIn);
-	if ( !ScCore->usingGUI() )
+	QFileInfo fi(fNameIn);
+	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
-	if ( showProgress )
+	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
+	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
@@ -156,10 +154,8 @@ bool ShapePlug::import(const QString& fN
 	else
 		progressDialog = nullptr;
 /* Set default Page to size defined in Preferences */
-//	x = 0.0;
-//	y = 0.0;
-	b = 0.0;
-	h = 0.0;
+	double b = 0.0;
+	double h = 0.0;
 	if (progressDialog)
 	{
 		progressDialog->setOverallProgress(1);
@@ -1173,8 +1169,8 @@ void ShapePlug::svgLineTo(FPointArray *i
 		const FPoint& b2 = i->point(i->size()-3);
 		const FPoint& b3 = i->point(i->size()-2);
 		const FPoint& b4 = i->point(i->size()-1);
-		FPoint n1 = FPoint(CurrX, CurrY);
-		FPoint n2 = FPoint(x1, y1);
+		FPoint n1(CurrX, CurrY);
+		FPoint n2(x1, y1);
 		if ((b1 == n1) && (b2 == n1) && (b3 == n2) && (b4 == n2))
 			return;
 	}
@@ -1202,10 +1198,10 @@ void ShapePlug::svgCurveToCubic(FPointAr
 		const FPoint& b2 = i->point(i->size()-3);
 		const FPoint& b3 = i->point(i->size()-2);
 		const FPoint& b4 = i->point(i->size()-1);
-		FPoint n1 = FPoint(CurrX, CurrY);
-		FPoint n2 = FPoint(x1, y1);
-		FPoint n3 = FPoint(x3, y3);
-		FPoint n4 = FPoint(x2, y2);
+		FPoint n1(CurrX, CurrY);
+		FPoint n2(x1, y1);
+		FPoint n3(x3, y3);
+		FPoint n4(x2, y2);
 		if ((b1 == n1) && (b2 == n2) && (b3 == n3) && (b4 == n4))
 			return;
 	}
diff -Napur a/scribus/plugins/import/sml/importsml.cpp f/scribus/plugins/import/sml/importsml.cpp
--- a/scribus/plugins/import/sml/importsml.cpp	2025-01-08 00:06:56.000000000 +0100
+++ f/scribus/plugins/import/sml/importsml.cpp	2025-02-07 13:56:47.894903013 +0100
@@ -59,9 +59,10 @@ SmlPlug::SmlPlug(ScribusDoc* doc, int fl
 
 QImage SmlPlug::readThumbnail(const QString& fName)
 {
-	QFileInfo fi = QFileInfo(fName);
-	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
-	double b, h;
+	QFileInfo fi(fName);
+	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
+	double b = 0.0;
+	double h = 0.0;
 	parseHeader(fName, b, h);
 	if (b == 0.0)
 		b = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
@@ -124,16 +125,15 @@ bool SmlPlug::import(const QString& fNam
 	interactive = (flags & LoadSavePlugin::lfInteractive);
 	importerFlags = flags;
 	cancel = false;
-	double b, h;
 	bool ret = false;
-	QFileInfo fi = QFileInfo(fNameIn);
-	if ( !ScCore->usingGUI() )
+	QFileInfo fi(fNameIn);
+	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
-	if ( showProgress )
+	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
+	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
@@ -153,8 +153,8 @@ bool SmlPlug::import(const QString& fNam
 	else
 		progressDialog = nullptr;
 /* Set default Page to size defined in Preferences */
-	b = 0.0;
-	h = 0.0;
+	double b = 0.0;
+	double h = 0.0;
 	if (progressDialog)
 	{
 		progressDialog->setOverallProgress(1);
diff -Napur a/scribus/plugins/import/svm/importsvm.cpp f/scribus/plugins/import/svm/importsvm.cpp
--- a/scribus/plugins/import/svm/importsvm.cpp	2025-01-08 00:06:55.000000000 +0100
+++ f/scribus/plugins/import/svm/importsvm.cpp	2025-02-07 13:56:47.837904033 +0100
@@ -19,7 +19,6 @@ for which a new license (GPL+exception)
 #include <QMimeData>
 #include <QRawFont>
 #include <QRegExp>
-#include <QTextCodec>
 #include <QUuid>
 #include <QDebug>
 
@@ -292,8 +291,8 @@ SvmPlug::SvmPlug(ScribusDoc* doc, int fl
 
 QImage SvmPlug::readThumbnail(const QString& fName)
 {
-	QFileInfo fi = QFileInfo(fName);
-	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
+	QFileInfo fi(fName);
+	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
 	double b = 0;
 	double h = 0;
 	double x = 0;
@@ -395,14 +394,14 @@ bool SvmPlug::import(const QString& fNam
 	cancel = false;
 	double x, y, b, h;
 	bool ret = false;
-	QFileInfo fi = QFileInfo(fNameIn);
-	if ( !ScCore->usingGUI() )
+	QFileInfo fi(fNameIn);
+	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
-	if ( showProgress )
+	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
+	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
@@ -1330,7 +1329,7 @@ void SvmPlug::finishItem(PageItem* ite,
 					gpath = points;
 				}
 				ite->meshGradientPatches.clear();
-				FPoint center = FPoint(cx.x(), cx.y());
+				FPoint center(cx.x(), cx.y());
 				QList<VColorStop*> colorStops = currentDC.gradient.colorStops();
 				if (colorStops.count() == 2)
 				{
@@ -1544,7 +1543,7 @@ void SvmPlug::handleEllipse(QDataStream
 {
 	QPointF p1 = getPoint(ds);
 	QPointF p2 = getPoint(ds);
-	QRectF box = QRectF(p1, p2);
+	QRectF box(p1, p2);
 	int z = m_Doc->itemAdd(PageItem::Polygon, PageItem::Ellipse, baseX, baseY, box.width(), box.height(), 0, currentDC.CurrColorFill, CommonStrings::None);
 	PageItem* ite = m_Doc->Items->at(z);
 	QTransform mm(1.0, 0.0, 0.0, 1.0, box.x(), box.y());
@@ -1556,7 +1555,7 @@ void SvmPlug::handleRectangle(QDataStrea
 {
 	QPointF p1 = getPoint(ds);
 	QPointF p2 = getPoint(ds);
-	QRectF box = QRectF(p1, p2);
+	QRectF box(p1, p2);
 	int z = m_Doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, baseX, baseY, box.width(), box.height(), 0, currentDC.CurrColorFill, CommonStrings::None);
 	PageItem* ite = m_Doc->Items->at(z);
 	QTransform mm(1.0, 0.0, 0.0, 1.0, box.x(), box.y());
@@ -1571,10 +1570,10 @@ void SvmPlug::handleRoundRect(QDataStrea
 	qint32 x1, y1;
 	ds >> x1 >> y1;
 	QPointF p3 = convertLogical2Pts(QPointF(x1, y1));
-	QRectF BoxDev = QRectF(p1, p2);
-	int z = m_Doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, baseX, baseY, BoxDev.width(), BoxDev.height(), 0, currentDC.CurrColorFill, CommonStrings::None);
+	QRectF boxDev(p1, p2);
+	int z = m_Doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, baseX, baseY, boxDev.width(), boxDev.height(), 0, currentDC.CurrColorFill, CommonStrings::None);
 	PageItem* ite = m_Doc->Items->at(z);
-	QTransform mm(1.0, 0.0, 0.0, 1.0, BoxDev.x(), BoxDev.y());
+	QTransform mm(1.0, 0.0, 0.0, 1.0, boxDev.x(), boxDev.y());
 	ite->PoLine.map(mm);
 	finishItem(ite);
 	if ((p3.x() != 0.0) || (p3.y() != 0.0))
@@ -1635,18 +1634,18 @@ void SvmPlug::handleArc(QDataStream &ds)
 {
 	QPointF p1 = getPoint(ds);
 	QPointF p2 = getPoint(ds);
-	QRectF BoxDev = QRectF(p1, p2);
+	QRectF boxDev(p1, p2);
 	QPointF st = getPoint(ds);
 	QPointF en = getPoint(ds);
-	QLineF stlin = QLineF(BoxDev.center(), st);
-	QLineF enlin = QLineF(BoxDev.center(), en);
+	QLineF stlin(boxDev.center(), st);
+	QLineF enlin(boxDev.center(), en);
 	FPointArray  pointArray;
 	QPainterPath painterPath;
-	painterPath.arcMoveTo(BoxDev, stlin.angle());
+	painterPath.arcMoveTo(boxDev, stlin.angle());
 	if (currentDC.arcDirection)
-		painterPath.arcTo(BoxDev, stlin.angle(), enlin.angle() - stlin.angle());
+		painterPath.arcTo(boxDev, stlin.angle(), enlin.angle() - stlin.angle());
 	else
-		painterPath.arcTo(BoxDev, stlin.angle(), stlin.angle() - enlin.angle());
+		painterPath.arcTo(boxDev, stlin.angle(), stlin.angle() - enlin.angle());
 	pointArray.fromQPainterPath(painterPath);
 	if (pointArray.count() != 0)
 	{
@@ -1657,7 +1656,7 @@ void SvmPlug::handleArc(QDataStream &ds)
 		}
 		else
 		{
-			int z = m_Doc->itemAdd(PageItem::PolyLine, PageItem::Unspecified, baseX, baseY, BoxDev.width(), BoxDev.height(), currentDC.LineW, CommonStrings::None, currentDC.CurrColorStroke);
+			int z = m_Doc->itemAdd(PageItem::PolyLine, PageItem::Unspecified, baseX, baseY, boxDev.width(), boxDev.height(), currentDC.LineW, CommonStrings::None, currentDC.CurrColorStroke);
 			PageItem* ite = m_Doc->Items->at(z);
 			ite->PoLine = pointArray.copy();
 			finishItem(ite, false);
@@ -1669,22 +1668,22 @@ void SvmPlug::handleArcTo(QDataStream &d
 {
 	QPointF p1 = getPoint(ds);
 	QPointF p2 = getPoint(ds);
-	QRectF BoxDev = QRectF(p1, p2);
+	QRectF boxDev(p1, p2);
 	QPointF st = getPoint(ds);
 	QPointF en = getPoint(ds);
-	QLineF stlin = QLineF(BoxDev.center(), st);
-	QLineF enlin = QLineF(BoxDev.center(), en);
+	QLineF stlin(boxDev.center(), st);
+	QLineF enlin(boxDev.center(), en);
 	if (inPath)
 	{
 		if (enlin.angleTo(stlin) > 180)
 		{
 		//	currentDC.Coords.svgMoveTo(st.x(), st.y());
-			currentDC.Coords.svgArcTo(BoxDev.width() / 2.0, BoxDev.height() / 2.0, 0, enlin.angleTo(stlin) < 180, stlin.angleTo(enlin) > 180, en.x(), en.y());
+			currentDC.Coords.svgArcTo(boxDev.width() / 2.0, boxDev.height() / 2.0, 0, enlin.angleTo(stlin) < 180, stlin.angleTo(enlin) > 180, en.x(), en.y());
 		}
 		else
 		{
 		//	currentDC.Coords.svgMoveTo(st.x(), st.y());
-			currentDC.Coords.svgArcTo(BoxDev.width() / 2.0, BoxDev.height() / 2.0, 0, enlin.angleTo(stlin) > 180, stlin.angleTo(enlin) > 180, en.x(), en.y());
+			currentDC.Coords.svgArcTo(boxDev.width() / 2.0, boxDev.height() / 2.0, 0, enlin.angleTo(stlin) > 180, stlin.angleTo(enlin) > 180, en.x(), en.y());
 		}
 		currentDC.currentPoint = en;
 	}
@@ -1695,18 +1694,18 @@ void SvmPlug::handleArcTo(QDataStream &d
 		double ang1 = stlin.angleTo(enlin);
 		if (currentDC.arcDirection)
 		{
-			painterPath.arcMoveTo(BoxDev, stlin.angle());
-			painterPath.arcTo(BoxDev, stlin.angle(), ang1);
+			painterPath.arcMoveTo(boxDev, stlin.angle());
+			painterPath.arcTo(boxDev, stlin.angle(), ang1);
 		}
 		else
 		{
-			painterPath.arcMoveTo(BoxDev, stlin.angle());
-			painterPath.arcTo(BoxDev, stlin.angle(), -(360 - ang1));
+			painterPath.arcMoveTo(boxDev, stlin.angle());
+			painterPath.arcTo(boxDev, stlin.angle(), -(360 - ang1));
 		}
 		pointArray.fromQPainterPath(painterPath);
 		if (pointArray.count() != 0)
 		{
-			int z = m_Doc->itemAdd(PageItem::PolyLine, PageItem::Unspecified, baseX, baseY, BoxDev.width(), BoxDev.height(), currentDC.LineW, CommonStrings::None, currentDC.CurrColorStroke);
+			int z = m_Doc->itemAdd(PageItem::PolyLine, PageItem::Unspecified, baseX, baseY, boxDev.width(), boxDev.height(), currentDC.LineW, CommonStrings::None, currentDC.CurrColorStroke);
 			PageItem* ite = m_Doc->Items->at(z);
 			ite->PoLine = pointArray.copy();
 			finishItem(ite, false);
@@ -1718,26 +1717,26 @@ void SvmPlug::handleChord(QDataStream &d
 {
 	QPointF p1 = getPoint(ds);
 	QPointF p2 = getPoint(ds);
-	QRectF BoxDev = QRectF(p1, p2);
+	QRectF boxDev(p1, p2);
 	QPointF st = getPoint(ds);
 	QPointF en = getPoint(ds);
-	QLineF stlin = QLineF(BoxDev.center(), st);
-	QLineF enlin = QLineF(BoxDev.center(), en);
+	QLineF stlin(boxDev.center(), st);
+	QLineF enlin(boxDev.center(), en);
 	FPointArray  pointArray;
 	QPainterPath painterPath;
 	QPointF firstPoint;
 	double ang1 = stlin.angleTo(enlin);
 	if (currentDC.arcDirection)
 	{
-		painterPath.arcMoveTo(BoxDev, stlin.angle());
+		painterPath.arcMoveTo(boxDev, stlin.angle());
 		firstPoint = painterPath.currentPosition();
-		painterPath.arcTo(BoxDev, stlin.angle(), ang1);
+		painterPath.arcTo(boxDev, stlin.angle(), ang1);
 	}
 	else
 	{
-		painterPath.arcMoveTo(BoxDev, stlin.angle());
+		painterPath.arcMoveTo(boxDev, stlin.angle());
 		firstPoint = painterPath.currentPosition();
-		painterPath.arcTo(BoxDev, stlin.angle(), -(360 - ang1));
+		painterPath.arcTo(boxDev, stlin.angle(), -(360 - ang1));
 	}
 	painterPath.lineTo(firstPoint);
 	pointArray.fromQPainterPath(painterPath);
@@ -1750,7 +1749,7 @@ void SvmPlug::handleChord(QDataStream &d
 		}
 		else
 		{
-			int z = m_Doc->itemAdd(PageItem::PolyLine, PageItem::Unspecified, baseX, baseY, BoxDev.width(), BoxDev.height(), currentDC.LineW, currentDC.CurrColorFill, currentDC.CurrColorStroke);
+			int z = m_Doc->itemAdd(PageItem::PolyLine, PageItem::Unspecified, baseX, baseY, boxDev.width(), boxDev.height(), currentDC.LineW, currentDC.CurrColorFill, currentDC.CurrColorStroke);
 			PageItem* ite = m_Doc->Items->at(z);
 			ite->PoLine = pointArray.copy();
 			finishItem(ite);
@@ -1762,28 +1761,28 @@ void SvmPlug::handlePie(QDataStream &ds)
 {
 	QPointF p1 = getPoint(ds);
 	QPointF p2 = getPoint(ds);
-	QRectF BoxDev = QRectF(p1, p2);
+	QRectF boxDev(p1, p2);
 	QPointF st = getPoint(ds);
 	QPointF en = getPoint(ds);
-	QLineF stlin = QLineF(BoxDev.center(), st);
-	QLineF enlin = QLineF(BoxDev.center(), en);
+	QLineF stlin(boxDev.center(), st);
+	QLineF enlin(boxDev.center(), en);
 	FPointArray  pointArray;
 	QPainterPath painterPath;
 	QPointF firstPoint;
 	double ang1 = stlin.angleTo(enlin);
 	if (currentDC.arcDirection)
 	{
-		painterPath.arcMoveTo(BoxDev, stlin.angle());
+		painterPath.arcMoveTo(boxDev, stlin.angle());
 		firstPoint = painterPath.currentPosition();
-		painterPath.arcTo(BoxDev, stlin.angle(), ang1);
+		painterPath.arcTo(boxDev, stlin.angle(), ang1);
 	}
 	else
 	{
-		painterPath.arcMoveTo(BoxDev, stlin.angle());
+		painterPath.arcMoveTo(boxDev, stlin.angle());
 		firstPoint = painterPath.currentPosition();
-		painterPath.arcTo(BoxDev, stlin.angle(), -(360 - ang1));
+		painterPath.arcTo(boxDev, stlin.angle(), -(360 - ang1));
 	}
-	painterPath.lineTo(BoxDev.center());
+	painterPath.lineTo(boxDev.center());
 	painterPath.lineTo(firstPoint);
 	pointArray.fromQPainterPath(painterPath);
 	if (pointArray.count() != 0)
@@ -1795,7 +1794,7 @@ void SvmPlug::handlePie(QDataStream &ds)
 		}
 		else
 		{
-			int z = m_Doc->itemAdd(PageItem::PolyLine, PageItem::Unspecified, baseX, baseY, BoxDev.width(), BoxDev.height(), currentDC.LineW, currentDC.CurrColorFill, currentDC.CurrColorStroke);
+			int z = m_Doc->itemAdd(PageItem::PolyLine, PageItem::Unspecified, baseX, baseY, boxDev.width(), boxDev.height(), currentDC.LineW, currentDC.CurrColorFill, currentDC.CurrColorStroke);
 			PageItem* ite = m_Doc->Items->at(z);
 			ite->PoLine = pointArray.copy();
 			finishItem(ite);
@@ -2208,7 +2207,7 @@ void SvmPlug::handleGradient(QDataStream
 {
 	QPointF p1 = getPoint(ds);
 	QPointF p2 = getPoint(ds);
-	QRectF box = QRectF(p1, p2);
+	QRectF box(p1, p2);
 	int z = m_Doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, baseX, baseY, box.width(), box.height(), 0, currentDC.CurrColorFill, CommonStrings::None);
 	PageItem* ite = m_Doc->Items->at(z);
 	QTransform mm(1.0, 0.0, 0.0, 1.0, box.x(), box.y());
@@ -2338,7 +2337,7 @@ void SvmPlug::commonGradient(QDataStream
 			ite->GrEndX = ite->width() / 2.0;
 			ite->GrEndY = ite->height();
 		}
-		QLineF gradientVectorE = QLineF(ite->GrStartX, ite->GrStartY, ite->GrEndX, ite->GrEndY);
+		QLineF gradientVectorE(ite->GrStartX, ite->GrStartY, ite->GrEndX, ite->GrEndY);
 		gradientVectorE.setAngle(gradientAngle);
 		ite->GrEndX = gradientVectorE.p2().x();
 		ite->GrEndY = gradientVectorE.p2().y();
@@ -2353,15 +2352,15 @@ void SvmPlug::commonGradient(QDataStream
 		ite->fill_gradient.addStop(colS, 1.0 - (mnBorder / 100.0), 0.5, 1.0, gradientStartColor, gradientStartShade);
 		if (mnBorder != 0)
 			ite->fill_gradient.addStop(colS, 1.0, 0.5, 1.0, gradientStartColor, gradientStartShade);
-		FPoint cp = FPoint(ite->width() * gradientCenterX, ite->height()* gradientCenterY);
+		FPoint cp(ite->width() * gradientCenterX, ite->height()* gradientCenterY);
 		double gLen = qMin(ite->width(), ite->height()) / 2.0;
-		QLineF p1 = QLineF(cp.x(), cp.y(), cp.x() - gLen, cp.y() - gLen);
+		QLineF p1(cp.x(), cp.y(), cp.x() - gLen, cp.y() - gLen);
 		p1.setAngle(p1.angle() + gradientAngle);
-		QLineF p2 = QLineF(cp.x(), cp.y(), cp.x() + gLen, cp.y() - gLen);
+		QLineF p2(cp.x(), cp.y(), cp.x() + gLen, cp.y() - gLen);
 		p2.setAngle(p2.angle() + gradientAngle);
-		QLineF p3 = QLineF(cp.x(), cp.y(), cp.x() + gLen, cp.y() + gLen);
+		QLineF p3(cp.x(), cp.y(), cp.x() + gLen, cp.y() + gLen);
 		p3.setAngle(p3.angle() + gradientAngle);
-		QLineF p4 = QLineF(cp.x(), cp.y(), cp.x() - gLen, cp.y() + gLen);
+		QLineF p4(cp.x(), cp.y(), cp.x() - gLen, cp.y() + gLen);
 		p4.setAngle(p4.angle() + gradientAngle);
 		ite->setDiamondGeometry(FPoint(p1.p2().x(), p1.p2().y()), FPoint(p2.p2().x(), p2.p2().y()), FPoint(p3.p2().x(), p3.p2().y()), FPoint(p4.p2().x(), p4.p2().y()), cp);
 		ite->GrType = Gradient_Diamond;
@@ -2375,19 +2374,19 @@ void SvmPlug::commonGradient(QDataStream
 		ite->fill_gradient.addStop(colS, 1.0 - (mnBorder / 100.0), 0.5, 1.0, gradientStartColor, gradientStartShade);
 		if (mnBorder != 0)
 			ite->fill_gradient.addStop(colS, 1.0, 0.5, 1.0, gradientStartColor, gradientStartShade);
-		FPoint cp = FPoint(ite->width() * gradientCenterX, ite->height()* gradientCenterY);
+		FPoint cp(ite->width() * gradientCenterX, ite->height()* gradientCenterY);
 		double gLenW = ite->width() / 2.0;
 		double gLenH = ite->height() / 2.0;
-		QPointF P1 = QPointF(0.0, 0.0);
-		QPointF P2 = QPointF(ite->width(), 0.0);
-		QPointF P3 = QPointF(ite->width(), ite->height());
-		QPointF P4 = QPointF(0.0, ite->height());
-		QLineF L1 = QLineF(0.0, 0.0, ite->width(), 0.0);
+		QPointF P1(0.0, 0.0);
+		QPointF P2(ite->width(), 0.0);
+		QPointF P3(ite->width(), ite->height());
+		QPointF P4(0.0, ite->height());
+		QLineF L1(0.0, 0.0, ite->width(), 0.0);
 		L1.setAngle(-45);
-		QLineF LCW = QLineF(0.0, ite->height() / 2.0, ite->width(), ite->height() / 2.0);
+		QLineF LCW(0.0, ite->height() / 2.0, ite->width(), ite->height() / 2.0);
 		QPointF P5;
 		LCW.intersects(L1, &P5);
-		QPointF P6 = QPointF(ite->width() - P5.x(), P5.y());
+		QPointF P6(ite->width() - P5.x(), P5.y());
 		QPolygonF pPoints;
 		pPoints << P1 << P2 << P3 << P4 << P5 << P6;
 		QTransform mat;
@@ -2402,13 +2401,13 @@ void SvmPlug::commonGradient(QDataStream
 		P4 = pPoints[3];
 		P5 = pPoints[4];
 		P6 = pPoints[5];
-		QLineF p1 = QLineF(cp.x(), cp.y(), cp.x() - gLenW, cp.y() - gLenH);
+		QLineF p1(cp.x(), cp.y(), cp.x() - gLenW, cp.y() - gLenH);
 		p1.setAngle(p1.angle() + gradientAngle);
-		QLineF p2 = QLineF(cp.x(), cp.y(), cp.x() + gLenW, cp.y() - gLenH);
+		QLineF p2(cp.x(), cp.y(), cp.x() + gLenW, cp.y() - gLenH);
 		p2.setAngle(p2.angle() + gradientAngle);
-		QLineF p3 = QLineF(cp.x(), cp.y(), cp.x() + gLenW, cp.y() + gLenH);
+		QLineF p3(cp.x(), cp.y(), cp.x() + gLenW, cp.y() + gLenH);
 		p3.setAngle(p3.angle() + gradientAngle);
-		QLineF p4 = QLineF(cp.x(), cp.y(), cp.x() - gLenW, cp.y() + gLenH);
+		QLineF p4(cp.x(), cp.y(), cp.x() - gLenW, cp.y() + gLenH);
 		p4.setAngle(p4.angle() + gradientAngle);
 		ite->setDiamondGeometry(FPoint(p1.p2().x(), p1.p2().y()), FPoint(p2.p2().x(), p2.p2().y()), FPoint(p3.p2().x(), p3.p2().y()), FPoint(p4.p2().x(), p4.p2().y()), cp);
 		ite->GrType = Gradient_Diamond;
@@ -2798,7 +2797,7 @@ quint32 SvmPlug::handleEMPBrush(QDataStr
 				lenS += 24;
 				float m11, m12, m21, m22, dx, dy;
 				ds >> m11 >> m12 >> m21 >> m22 >> dx >> dy;
-				QLineF lin = QLineF(0, 0, 1, 0);
+				QLineF lin(0, 0, 1, 0);
 				lin = QTransform(m11, m12, m21, m22, dx, dy).map(lin);
 				sty.gradientAngle = lin.angle();
 			}
@@ -2848,7 +2847,7 @@ quint32 SvmPlug::handleEMPBrush(QDataStr
 		{
 			float m11, m12, m21, m22, dx, dy;
 			ds >> m11 >> m12 >> m21 >> m22 >> dx >> dy;
-			QLineF lin = QLineF(0, 0, 1, 0);
+			QLineF lin(0, 0, 1, 0);
 			lin = QTransform(m11, m12, m21, m22, dx, dy).map(lin);
 			sty.gradientAngle = lin.angle() + 45;
 		}
@@ -2928,7 +2927,7 @@ quint32 SvmPlug::handleEMPBrush(QDataStr
 		{
 			float m11, m12, m21, m22, dx, dy;
 			ds >> m11 >> m12 >> m21 >> m22 >> dx >> dy;
-			QLineF lin = QLineF(rect[0], rect[2]);
+			QLineF lin(rect[0], rect[2]);
 			lin = QTransform(m11, m12, m21, m22, dx, dy).map(lin);
 			sty.gradientAngle = lin.angle() + 45;
 		}
@@ -4472,7 +4471,7 @@ QPointF SvmPlug::convertEMFPLogical2Pts(
 
 double SvmPlug::convertEMFPLogical2Pts(double in, quint16 unit)
 {
-	QLineF dist = QLineF(0, 0, in, 0);
+	QLineF dist(0, 0, in, 0);
 	dist = currentDC.m_WorldMapEMFP.map(dist);
 	double out = dist.length();
 	switch (unit)
diff -Napur a/scribus/plugins/import/viva/importviva.cpp f/scribus/plugins/import/viva/importviva.cpp
--- a/scribus/plugins/import/viva/importviva.cpp	2025-01-08 21:31:33.000000000 +0100
+++ f/scribus/plugins/import/viva/importviva.cpp	2025-02-07 13:56:47.853903747 +0100
@@ -108,11 +108,11 @@ double VivaPlug::parseUnit(const QString
 QImage VivaPlug::readThumbnail(const QString& fName)
 {
 	QImage tmp;
-	if ( !QFile::exists(fName) )
+	if (!QFile::exists(fName))
 		return QImage();
 	progressDialog = nullptr;
-	QFileInfo fi = QFileInfo(fName);
-	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
+	QFileInfo fi(fName);
+	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
 	docWidth = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
 	docHeight = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
 	m_Doc = new ScribusDoc();
@@ -205,14 +205,14 @@ bool VivaPlug::import(const QString& fNa
 	firstPage = true;
 	pagecount = 1;
 	mpagecount = 0;
-	QFileInfo fi = QFileInfo(fNameIn);
-	if ( !ScCore->usingGUI() )
+	QFileInfo fi(fNameIn);
+	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
-	if ( showProgress )
+	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
+	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
@@ -1197,7 +1197,7 @@ PageItem* VivaPlug::parseObjectDetailsXM
 						QDomElement eo = spo.toElement();
 						if (eo.tagName() == "vo:point")
 						{
-							FPoint pp = FPoint(parseUnit(eo.attribute("vo:x", "0")), parseUnit(eo.attribute("vo:y", "0")));
+							FPoint pp(parseUnit(eo.attribute("vo:x", "0")), parseUnit(eo.attribute("vo:y", "0")));
 							if (eo.hasAttribute("vo:control"))
 							{
 								if ((eo.attribute("vo:control") == "constraint-before") || (eo.attribute("vo:control") == "before"))
@@ -1304,7 +1304,7 @@ PageItem* VivaPlug::parseObjectDetailsXM
 						else if (spo.tagName() == "uni:applyElementOpacity")
 							shadowObjTrans = (spo.text() == "true");
 					}
-					QLineF oLine = QLineF(0, 0, shadowOffset, 0);
+					QLineF oLine(0, 0, shadowOffset, 0);
 					oLine.setAngle(shadowAngle - 180.0);
 					shadowX = oLine.p2().x();
 					shadowY = oLine.p2().y();
@@ -1536,7 +1536,7 @@ PageItem* VivaPlug::parseObjectDetailsXM
 				QString gradColor1Str = colorStops[1]->name;
 				QColor gradColor1 = colorStops[1]->color;
 				item->meshGradientPatches.clear();
-				FPoint center = FPoint(item->width() / 2.0, item->height() / 2.0);
+				FPoint center(item->width() / 2.0, item->height() / 2.0);
 				MeshPoint cP;
 				cP.resetTo(center);
 				cP.transparency = 1.0;
@@ -1578,7 +1578,7 @@ PageItem* VivaPlug::parseObjectDetailsXM
 				item->GrControl4 = FPoint(0, item->height());
 				if (gradientAngle != 0)
 				{
-					QLineF gradientVector = QLineF(item->width() / 2.0, item->height() / 2.0, 0, 0);
+					QLineF gradientVector(item->width() / 2.0, item->height() / 2.0, 0, 0);
 					gradientVector.setLength(gradientVector.length() + 1);
 					gradientVector.setAngle(gradientVector.angle() + gradientAngle);
 					QPointF g1 = intersectBoundingRect(item, gradientVector);
diff -Napur a/scribus/plugins/import/vsd/importvsd.cpp f/scribus/plugins/import/vsd/importvsd.cpp
--- a/scribus/plugins/import/vsd/importvsd.cpp	2025-01-08 00:06:55.000000000 +0100
+++ f/scribus/plugins/import/vsd/importvsd.cpp	2025-02-07 13:56:47.897902959 +0100
@@ -69,10 +69,9 @@ VsdPlug::VsdPlug(ScribusDoc* doc, int fl
 
 QImage VsdPlug::readThumbnail(const QString& fName)
 {
-	QFileInfo fi = QFileInfo(fName);
-	double b, h;
-	b = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
-	h = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
+	QFileInfo fi(fName);
+	double b = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
+	double h = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
 	docWidth = b;
 	docHeight = h;
 	progressDialog = nullptr;
@@ -130,15 +129,14 @@ bool VsdPlug::import(const QString& fNam
 	interactive = (flags & LoadSavePlugin::lfInteractive);
 	importerFlags = flags;
 	cancel = false;
-	double b, h;
 	bool ret = false;
-	QFileInfo fi = QFileInfo(fNameIn);
-	if ( !ScCore->usingGUI() )
+	QFileInfo fi(fNameIn);
+	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	if ( showProgress )
+	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
@@ -158,8 +156,8 @@ bool VsdPlug::import(const QString& fNam
 	else
 		progressDialog = nullptr;
 /* Set default Page to size defined in Preferences */
-	b = 0.0;
-	h = 0.0;
+	double b = 0.0;
+	double h = 0.0;
 	if (progressDialog)
 	{
 		progressDialog->setOverallProgress(1);
diff -Napur a/scribus/plugins/import/wmf/wmfcontext.cpp f/scribus/plugins/import/wmf/wmfcontext.cpp
--- a/scribus/plugins/import/wmf/wmfcontext.cpp	2025-01-08 00:06:55.000000000 +0100
+++ f/scribus/plugins/import/wmf/wmfcontext.cpp	2025-02-07 13:56:47.842903943 +0100
@@ -65,7 +65,7 @@ WMFContext::WMFContext()
 
 void WMFContext::save()
 {
-	if ( this->count() > 0 )
+	if (this->count() > 0)
 		push( WMFGraphicsState(top()) );
 	else
 	{
@@ -75,7 +75,7 @@ void WMFContext::save()
 
 void WMFContext::restore()
 {
-	if ( this->count() > 1 )
+	if (this->count() > 1)
 		pop();
 	else
 	{
@@ -91,7 +91,7 @@ void WMFContext::reset()
 
 WMFGraphicsState& WMFContext::current()
 {
-	if ( this->count() <= 0 )
+	if (this->count() <= 0)
 		push( WMFGraphicsState() ) ;
 	return top();
 }
diff -Napur a/scribus/plugins/import/wmf/wmfimport.cpp f/scribus/plugins/import/wmf/wmfimport.cpp
--- a/scribus/plugins/import/wmf/wmfimport.cpp	2025-01-08 00:06:55.000000000 +0100
+++ f/scribus/plugins/import/wmf/wmfimport.cpp	2025-02-07 13:56:47.842903943 +0100
@@ -18,6 +18,7 @@ for which a new license (GPL+exception)
 #include <QMimeData>
 #include <QPainterPath>
 #include <QRegExp>
+#include <QTextCodec>
 
 #include "commonstrings.h"
 #include "fpointarray.h"
diff -Napur a/scribus/plugins/import/wmf/wmfimport.h f/scribus/plugins/import/wmf/wmfimport.h
--- a/scribus/plugins/import/wmf/wmfimport.h	2025-01-08 00:06:55.000000000 +0100
+++ f/scribus/plugins/import/wmf/wmfimport.h	2025-02-07 13:56:47.842903943 +0100
@@ -20,6 +20,8 @@ for which a new license (GPL+exception)
 #include "wmfcontext.h"
 
 class QBuffer;
+class QTextCodec;
+
 class FPointArray;
 class PageItem;
 class ScribusDoc;
diff -Napur a/scribus/plugins/import/wpg/importwpg.cpp f/scribus/plugins/import/wpg/importwpg.cpp
--- a/scribus/plugins/import/wpg/importwpg.cpp	2025-01-08 21:31:33.000000000 +0100
+++ f/scribus/plugins/import/wpg/importwpg.cpp	2025-02-07 13:56:47.899902924 +0100
@@ -425,7 +425,7 @@ WpgPlug::WpgPlug(ScribusDoc* doc, int fl
 
 QImage WpgPlug::readThumbnail(const QString& fName)
 {
-	QFileInfo fi = QFileInfo(fName);
+	QFileInfo fi(fName);
 	double b = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
 	double h = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
 	docWidth = b;
@@ -485,15 +485,14 @@ bool WpgPlug::import(const QString& fNam
 	interactive = (flags & LoadSavePlugin::lfInteractive);
 	importerFlags = flags;
 	cancel = false;
-	double b, h;
 	bool ret = false;
-	QFileInfo fi = QFileInfo(fNameIn);
-	if ( !ScCore->usingGUI() )
+	QFileInfo fi(fNameIn);
+	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	if ( showProgress )
+	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
@@ -513,8 +512,8 @@ bool WpgPlug::import(const QString& fNam
 	else
 		progressDialog = nullptr;
 /* Set default Page to size defined in Preferences */
-	b = 0.0;
-	h = 0.0;
+	double b = 0.0;
+	double h = 0.0;
 	if (progressDialog)
 	{
 		progressDialog->setOverallProgress(1);
diff -Napur a/scribus/plugins/import/xar/importxar.cpp f/scribus/plugins/import/xar/importxar.cpp
--- a/scribus/plugins/import/xar/importxar.cpp	2025-01-08 21:31:33.000000000 +0100
+++ f/scribus/plugins/import/xar/importxar.cpp	2025-02-07 13:56:47.845903890 +0100
@@ -18,7 +18,6 @@ for which a new license (GPL+exception)
 #include <QFile>
 #include <QMimeData>
 #include <QRegExp>
-#include <QTextCodec>
 #include <QDebug>
 #include "qtiocompressor.h"
 
@@ -235,13 +234,13 @@ bool XarPlug::import(const QString& fNam
 	cancel = false;
 	double x, y, b, h;
 	bool ret = false;
-	QFileInfo fi = QFileInfo(fName);
-	if ( !ScCore->usingGUI() )
+	QFileInfo fi(fName);
+	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	if ( showProgress )
+	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
@@ -1341,7 +1340,7 @@ void XarPlug::endTextLine()
 							{
 								item->GrType = txDat.FillGradientType;
 								item->fill_gradient = txDat.FillGradient;
-								FPoint p = FPoint(item->xPos(), item->yPos());
+								FPoint p(item->xPos(), item->yPos());
 								item->setDiamondGeometry(txDat.GrControl1 - p, txDat.GrControl2 - p, txDat.GrControl3 - p, txDat.GrControl4 - p, txDat.GrControl5 - p);
 							}
 							if (txDat.GradMask > 0)
@@ -1448,7 +1447,7 @@ void XarPlug::endTextLine()
 					{
 						item->GrType = txDat.FillGradientType;
 						item->fill_gradient = txDat.FillGradient;
-						FPoint p = FPoint(item->xPos(), item->yPos());
+						FPoint p(item->xPos(), item->yPos());
 						item->setDiamondGeometry(txDat.GrControl1 - p, txDat.GrControl2 - p, txDat.GrControl3 - p, txDat.GrControl4 - p, txDat.GrControl5 - p);
 					}
 					if (txDat.GradMask > 0)
@@ -2420,21 +2419,21 @@ void XarPlug::handleMultiDiamondGradient
 		gc->FillGradient.addStop( QColor(255, 255, 255, 0), 1.0, 0.5, 0.0, gCol2, 100 );
 	gc->FillGradientType = 10;
 	gc->GrControl5 = FPoint(bcx + baseX + m_Doc->currentPage()->xOffset(), (docHeight - bcy) + baseY + m_Doc->currentPage()->yOffset());
-	QPointF cen = QPointF(bcx + baseX + m_Doc->currentPage()->xOffset(), (docHeight - bcy) + baseY + m_Doc->currentPage()->yOffset());
-	QPointF rig = QPointF(brx + baseX + m_Doc->currentPage()->xOffset(), (docHeight - bry) + baseY + m_Doc->currentPage()->yOffset());
-	QPointF top = QPointF(btx + baseX + m_Doc->currentPage()->xOffset(), (docHeight - bty) + baseY + m_Doc->currentPage()->yOffset());
-	QLineF rVec = QLineF(cen, rig);
-	QLineF tVec = QLineF(cen, top);
+	QPointF cen(bcx + baseX + m_Doc->currentPage()->xOffset(), (docHeight - bcy) + baseY + m_Doc->currentPage()->yOffset());
+	QPointF rig(brx + baseX + m_Doc->currentPage()->xOffset(), (docHeight - bry) + baseY + m_Doc->currentPage()->yOffset());
+	QPointF top(btx + baseX + m_Doc->currentPage()->xOffset(), (docHeight - bty) + baseY + m_Doc->currentPage()->yOffset());
+	QLineF rVec(cen, rig);
+	QLineF tVec(cen, top);
 	QLineF rNVec = tVec.translated(rVec.dx(), rVec.dy());
 	QPointF intRT = rNVec.p2();
 	gc->GrControl2 = FPoint(intRT.x(), intRT.y());
-	QLineF vg4 = QLineF(cen, intRT);
+	QLineF vg4(cen, intRT);
 	vg4.setAngle(vg4.angle()+180);
 	gc->GrControl4 = FPoint(vg4.x2(), vg4.y2());
 	QLineF tNVec = tVec.translated(-rVec.dx(), -rVec.dy());
 	QPointF intLT = tNVec.p2();
 	gc->GrControl1 = FPoint(intLT.x(), intLT.y());
-	QLineF vg3 = QLineF(cen, intLT);
+	QLineF vg3(cen, intLT);
 	vg3.setAngle(vg3.angle()+180);
 	gc->GrControl3 = FPoint(vg3.x2(), vg3.y2());
 	if (textLines.count() > 0)
@@ -2489,21 +2488,21 @@ void XarPlug::handleSimpleDiamondGradien
 		gc->FillGradient.addStop( QColor(255, 255, 255, 0), 1.0, 0.5, 0.0, gCol2, 100 );
 	gc->FillGradientType = 10;
 	gc->GrControl5 = FPoint(bcx + baseX + m_Doc->currentPage()->xOffset(), (docHeight - bcy) + baseY + m_Doc->currentPage()->yOffset());
-	QPointF cen = QPointF(bcx + baseX + m_Doc->currentPage()->xOffset(), (docHeight - bcy) + baseY + m_Doc->currentPage()->yOffset());
-	QPointF rig = QPointF(brx + baseX + m_Doc->currentPage()->xOffset(), (docHeight - bry) + baseY + m_Doc->currentPage()->yOffset());
-	QPointF top = QPointF(btx + baseX + m_Doc->currentPage()->xOffset(), (docHeight - bty) + baseY + m_Doc->currentPage()->yOffset());
-	QLineF rVec = QLineF(cen, rig);
-	QLineF tVec = QLineF(cen, top);
+	QPointF cen(bcx + baseX + m_Doc->currentPage()->xOffset(), (docHeight - bcy) + baseY + m_Doc->currentPage()->yOffset());
+	QPointF rig(brx + baseX + m_Doc->currentPage()->xOffset(), (docHeight - bry) + baseY + m_Doc->currentPage()->yOffset());
+	QPointF top(btx + baseX + m_Doc->currentPage()->xOffset(), (docHeight - bty) + baseY + m_Doc->currentPage()->yOffset());
+	QLineF rVec(cen, rig);
+	QLineF tVec(cen, top);
 	QLineF rNVec = tVec.translated(rVec.dx(), rVec.dy());
 	QPointF intRT = rNVec.p2();
 	gc->GrControl2 = FPoint(intRT.x(), intRT.y());
-	QLineF vg4 = QLineF(cen, intRT);
+	QLineF vg4(cen, intRT);
 	vg4.setAngle(vg4.angle()+180);
 	gc->GrControl4 = FPoint(vg4.x2(), vg4.y2());
 	QLineF tNVec = tVec.translated(-rVec.dx(), -rVec.dy());
 	QPointF intLT = tNVec.p2();
 	gc->GrControl1 = FPoint(intLT.x(), intLT.y());
-	QLineF vg3 = QLineF(cen, intLT);
+	QLineF vg3(cen, intLT);
 	vg3.setAngle(vg3.angle()+180);
 	gc->GrControl3 = FPoint(vg3.x2(), vg3.y2());
 	if (textLines.count() > 0)
@@ -3547,14 +3546,14 @@ void XarPlug::addGraphicContext()
 {
 /*	XarStyle *gc2 = m_gc.top();
 	XarStyle *gc = new XarStyle;
-	if ( m_gc.top() )
+	if (m_gc.top())
 		*gc = *( m_gc.top() );
 	m_gc.push( gc );
 	if (gc2->Elements.count() > 0)
 		gc2->Elements.removeLast(); */
 	XarStyle *gc2 = m_gc.top();
 	XarStyle *gc = new XarStyle;
-	if ( m_gc.top() )
+	if (m_gc.top())
 		*gc = *( m_gc.top() );
 	m_gc.push( gc );
 	if (gc2->Elements.count() > 0)
@@ -3699,7 +3698,7 @@ void XarPlug::popGraphicContext()
 			{
 				item->GrType = gc->FillGradientType;
 				item->fill_gradient = gc->FillGradient;
-				FPoint p = FPoint(item->xPos(), item->yPos());
+				FPoint p(item->xPos(), item->yPos());
 				item->setDiamondGeometry(gc->GrControl1 - p, gc->GrControl2 - p, gc->GrControl3 - p, gc->GrControl4 - p, gc->GrControl5 - p);
 			}
 			if (gc->GradMask > 0)
diff -Napur a/scribus/plugins/import/xfig/importxfig.cpp f/scribus/plugins/import/xfig/importxfig.cpp
--- a/scribus/plugins/import/xfig/importxfig.cpp	2025-01-08 21:31:34.000000000 +0100
+++ f/scribus/plugins/import/xfig/importxfig.cpp	2025-02-07 13:56:47.872903407 +0100
@@ -62,9 +62,9 @@ XfigPlug::XfigPlug(ScribusDoc* doc, int
 
 QImage XfigPlug::readThumbnail(const QString& fName)
 {
-	QFileInfo fi = QFileInfo(fName);
-	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
-	double w=0.0, h=0.0, x=0.0, y=0.0;
+	QFileInfo fi(fName);
+	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
+	double w = 0.0, h = 0.0, x = 0.0, y = 0.0;
 	parseHeader(fName, x, y, w, h);
 	docX = x;
 	docY = y;
@@ -257,14 +257,14 @@ bool XfigPlug::import(const QString& fNa
 	CustColors.insert("Pink2", ScColor(255, 192, 192));
 	CustColors.insert("Pink", ScColor(255, 224, 224));
 	CustColors.insert("Gold", ScColor(255, 215, 0));
-	QFileInfo fi = QFileInfo(fNameIn);
-	if ( !ScCore->usingGUI() )
+	QFileInfo fi(fNameIn);
+	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
-	if ( showProgress )
+	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
+	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
@@ -1067,7 +1067,7 @@ void XfigPlug::processArc(QDataStream &t
 	double r1 = distance(x1R - center_x, y1R - center_y);
 	double x0 = center_x - r1;
 	double y0 = center_y - r1;
-	QRectF bBox = QRectF(x0, y0, r1 * 2.0, r1 * 2.0);
+	QRectF bBox(x0, y0, r1 * 2.0, r1 * 2.0);
 	double angle1 = -xy2Deg(x1R - center_x, y1R - center_y);
 	double angle2 = -xy2Deg(x3R - center_x, y3R - center_y);
 	double sweep;
diff -Napur a/scribus/plugins/import/xps/importxps.cpp f/scribus/plugins/import/xps/importxps.cpp
--- a/scribus/plugins/import/xps/importxps.cpp	2025-01-08 21:31:34.000000000 +0100
+++ f/scribus/plugins/import/xps/importxps.cpp	2025-02-07 13:56:47.869903461 +0100
@@ -121,8 +121,8 @@ QImage XpsPlug::readThumbnail(const QStr
 	}
 	if (!found)
 	{
-		QFileInfo fi = QFileInfo(fName);
-		baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
+		QFileInfo fi(fName);
+		baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
 		docWidth = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
 		docHeight = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
 		m_Doc = new ScribusDoc();
@@ -196,15 +196,15 @@ bool XpsPlug::import(const QString& fNam
 	bool ret = false;
 	firstPage = true;
 	pagecount = 1;
-	QFileInfo fi = QFileInfo(fNameIn);
+	QFileInfo fi(fNameIn);
 	m_FileName = fi.fileName();
-	if ( !ScCore->usingGUI() )
+	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath()+"/"));
-	if ( showProgress )
+	baseFile = QDir::cleanPath(QDir::toNativeSeparators(fi.absolutePath() + "/"));
+	if (showProgress)
 	{
 		ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
@@ -1229,7 +1229,7 @@ PageItem* XpsPlug::parseObjectXML(QDomEl
 				double dx = 0.0;
 				double dy = 0.0;
 				getTransformValuesFromMatrix( obState.transform, scX, scY, rot, dx, dy);
-				QLineF transp = QLineF(0, 0, retObj->xPos() - m_Doc->currentPage()->xOffset(), retObj->yPos() - m_Doc->currentPage()->yOffset());
+				QLineF transp(0, 0, retObj->xPos() - m_Doc->currentPage()->xOffset(), retObj->yPos() - m_Doc->currentPage()->yOffset());
 				transp = obState.transform.map(transp);
 				retObj->setXYPos(transp.p2().x() + m_Doc->currentPage()->xOffset(), transp.p2().y() + m_Doc->currentPage()->yOffset());
 				if ((scX != 1.0) || (scY != 1.0))
diff -Napur a/scribus/plugins/import/zmf/importzmf.cpp f/scribus/plugins/import/zmf/importzmf.cpp
--- a/scribus/plugins/import/zmf/importzmf.cpp	2025-01-08 00:06:55.000000000 +0100
+++ f/scribus/plugins/import/zmf/importzmf.cpp	2025-02-07 13:56:47.901902888 +0100
@@ -63,7 +63,7 @@ ZmfPlug::ZmfPlug(ScribusDoc* doc, int fl
 
 QImage ZmfPlug::readThumbnail(QString fName)
 {
-	QFileInfo fi = QFileInfo(fName);
+	QFileInfo fi(fName);
 	double b = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
 	double h = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
 	docWidth = b;
@@ -127,15 +127,14 @@ bool ZmfPlug::import(QString fNameIn, co
 	interactive = (flags & LoadSavePlugin::lfInteractive);
 	importerFlags = flags;
 	cancel = false;
-	double b, h;
 	bool ret = false;
-	QFileInfo fi = QFileInfo(fName);
-	if ( !ScCore->usingGUI() )
+	QFileInfo fi(fName);
+	if (!ScCore->usingGUI())
 	{
 		interactive = false;
 		showProgress = false;
 	}
-	if ( showProgress )
+	if (showProgress)
 	{
 		ScribusMainWindow* mw=(m_Doc==0) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
@@ -155,8 +154,8 @@ bool ZmfPlug::import(QString fNameIn, co
 	else
 		progressDialog = nullptr;
 /* Set default Page to size defined in Preferences */
-	b = 0.0;
-	h = 0.0;
+	double b = 0.0;
+	double h = 0.0;
 	if (progressDialog)
 	{
 		progressDialog->setOverallProgress(1);
diff -Napur a/scribus/plugins/picbrowser/loadimage.cpp f/scribus/plugins/picbrowser/loadimage.cpp
--- a/scribus/plugins/picbrowser/loadimage.cpp	2025-01-08 21:31:37.000000000 +0100
+++ f/scribus/plugins/picbrowser/loadimage.cpp	2025-02-07 13:56:47.980901475 +0100
@@ -81,7 +81,7 @@ void loadImagesThread::processLoadImageJ
 		return;
 	}
 
-	QFileInfo fi = QFileInfo(path);
+	QFileInfo fi(path);
 	QString ext = fi.suffix().toLower();
 	QStringList allFormatsV = LoadSavePlugin::getExtensionsForPreview(FORMATID_FIRSTUSER);
 	if (allFormatsV.contains(ext.toUtf8()))
diff -Napur a/scribus/plugins/scriptplugin/cmdgetprop.cpp f/scribus/plugins/scriptplugin/cmdgetprop.cpp
--- a/scribus/plugins/scriptplugin/cmdgetprop.cpp	2025-01-08 21:31:35.000000000 +0100
+++ f/scribus/plugins/scriptplugin/cmdgetprop.cpp	2025-02-07 13:56:47.788904910 +0100
@@ -17,7 +17,7 @@ for which a new license (GPL+exception)
 PyObject *scribus_getobjecttype(PyObject* /* self */, PyObject* args)
 {
 	PyESString name;
-	QString result = "";
+	QString result;
 
 	if (!PyArg_ParseTuple(args, "|es", "utf-8", name.ptr()))
 		return nullptr;
@@ -79,6 +79,19 @@ PyObject *scribus_getfillcolor(PyObject*
 	return PyUnicode_FromString(item->fillColor().toUtf8());
 }
 
+PyObject *scribus_getfillshade(PyObject* /* self */, PyObject* args)
+{
+	PyESString name;
+	if (!PyArg_ParseTuple(args, "|es", "utf-8", name.ptr()))
+		return nullptr;
+	if (!checkHaveDocument())
+		return nullptr;
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	if (item == nullptr)
+		return nullptr;
+	return PyLong_FromLong(static_cast<long>(item->fillShade()));
+}
+
 PyObject *scribus_getfilltransparency(PyObject* /* self */, PyObject* args)
 {
 	PyESString name;
@@ -222,19 +235,6 @@ PyObject *scribus_getlinestyle(PyObject*
 	return PyLong_FromLong(static_cast<long>(item->PLineArt));
 }
 
-PyObject *scribus_getfillshade(PyObject* /* self */, PyObject* args)
-{
-	PyESString name;
-	if (!PyArg_ParseTuple(args, "|es", "utf-8", name.ptr()))
-		return nullptr;
-	if (!checkHaveDocument())
-		return nullptr;
-	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
-	if (item == nullptr)
-		return nullptr;
-	return PyLong_FromLong(static_cast<long>(item->fillShade()));
-}
-
 PyObject *scribus_getcornerradius(PyObject* /* self */, PyObject* args)
 {
 	PyESString name;
@@ -327,6 +327,46 @@ PyObject *scribus_getrotation(PyObject*
 	return PyFloat_FromDouble(item->rotation() * -1.0);
 }
 
+PyObject *scribus_getboundingbox(PyObject* /* self */, PyObject* args)
+{
+	PyESString name;
+	if (!PyArg_ParseTuple(args, "|es", "utf-8", name.ptr()))
+		return nullptr;
+	if (!checkHaveDocument())
+		return nullptr;
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	if (item == nullptr)
+		return nullptr;
+
+	return Py_BuildValue("(dddd)",
+	                     docUnitXToPageX(item->BoundingX),
+	                     docUnitYToPageY(item->BoundingY),
+	                     PointToValue(item->BoundingW),
+	                     PointToValue(item->BoundingH)
+	                    );
+}
+
+PyObject *scribus_getvisualboundingbox(PyObject* /* self */, PyObject* args)
+{
+	PyESString name;
+	if (!PyArg_ParseTuple(args, "|es", "utf-8", name.ptr()))
+		return nullptr;
+	if (!checkHaveDocument())
+		return nullptr;
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	if (item == nullptr)
+		return nullptr;
+
+	QRectF boundingBox = item->getVisualBoundingRect();
+
+	return Py_BuildValue("(dddd)",
+	                     docUnitXToPageX(boundingBox.x()),
+	                     docUnitYToPageY(boundingBox.y()),
+	                     PointToValue(boundingBox.width()),
+	                     PointToValue(boundingBox.height())
+	                    );
+}
+
 PyObject *scribus_getallobjects(PyObject* /* self */, PyObject* args, PyObject *keywds)
 {
 	int itemType = -1;
@@ -469,6 +509,7 @@ void cmdgetpropdocwarnings()
 {
 	QStringList s;
 	s << scribus_getallobjects__doc__
+	  << scribus_getboundingbox__doc__
 	  << scribus_getcornerradius__doc__ 
 	  << scribus_getcustomlinestyle__doc__
 	  << scribus_getfillcolor__doc__
@@ -491,5 +532,6 @@ void cmdgetpropdocwarnings()
 	  << scribus_getobjecttype__doc__
 	  << scribus_getposition__doc__
 	  << scribus_getrotation__doc__
-	  << scribus_getsize__doc__;
+	  << scribus_getsize__doc__
+	  << scribus_getvisualboundingbox__doc__;
 }
diff -Napur a/scribus/plugins/scriptplugin/cmdgetprop.h f/scribus/plugins/scriptplugin/cmdgetprop.h
--- a/scribus/plugins/scriptplugin/cmdgetprop.h	2025-01-08 21:31:35.000000000 +0100
+++ f/scribus/plugins/scriptplugin/cmdgetprop.h	2025-02-07 13:56:47.789904892 +0100
@@ -41,6 +41,16 @@ If \"name\" is not given the currently s
 PyObject *scribus_getfillcolor(PyObject * /*self*/, PyObject* args);
 
 /*! docstring */
+PyDoc_STRVAR(scribus_getfillshade__doc__,
+QT_TR_NOOP("getFillShade([\"name\"]) -> integer\n\
+\n\
+Returns the shading value of the fill color of the object \"name\".\n\
+If \"name\" is not given the currently selected item is used.\n\
+"));
+/*! Returns fill shade of the object */
+PyObject* scribus_getfillshade(PyObject* /*self*/, PyObject* args);
+
+/*! docstring */
 PyDoc_STRVAR(scribus_getfilltransparency__doc__,
 QT_TR_NOOP("getFillTransparency([\"name\"]) -> float\n\
 \n\
@@ -154,16 +164,6 @@ LINE_DASH, LINE_DASHDOT, LINE_DASHDOTDOT
 PyObject *scribus_getlinestyle(PyObject * /*self*/, PyObject* args);
 
 /*! docstring */
-PyDoc_STRVAR(scribus_getfillshade__doc__,
-QT_TR_NOOP("getFillShade([\"name\"]) -> integer\n\
-\n\
-Returns the shading value of the fill color of the object \"name\".\n\
-If \"name\" is not given the currently selected item is used.\n\
-"));
-/*! Returns fill shade of the object */
-PyObject *scribus_getfillshade(PyObject * /*self*/, PyObject* args);
-
-/*! docstring */
 PyDoc_STRVAR(scribus_getcornerradius__doc__,
 QT_TR_NOOP("getCornerRadius([\"name\"]) -> integer\n\
 \n\
@@ -252,6 +252,31 @@ is used.\n\
 PyObject *scribus_getrotation(PyObject * /*self*/, PyObject* args);
 
 /*! docstring */
+PyDoc_STRVAR(scribus_getboundingbox__doc__,
+QT_TR_NOOP("getBoundingBox([\"name\"]) -> (x, y, width, height)\n\
+\n\
+Returns a (x, y, width, height) tuple with the position and size of the object \"name\".\n\
+If \"name\" is not given the currently selected item is used. The size is\n\
+expressed in the current measurement unit of the document - see UNIT_<type>\n\
+for reference.\n\
+"));
+/*! Returns size of the object */
+PyObject *scribus_getboundingbox(PyObject * /*self*/, PyObject* args);
+
+/*! docstring */
+PyDoc_STRVAR(scribus_getvisualboundingbox__doc__,
+QT_TR_NOOP("getVisualBoundingBox([\"name\"]) -> (x, y, width, height)\n\
+\n\
+Returns a (x, y, width, height) tuple corresponding to the visual bounding box\n\
+of the object \"name\".\n\
+If \"name\" is not given the currently selected item is used. The size is\n\
+expressed in the current measurement unit of the document - see UNIT_<type>\n\
+for reference.\n\
+"));
+/*! Returns size of the object */
+PyObject *scribus_getvisualboundingbox(PyObject * /*self*/, PyObject* args);
+
+/*! docstring */
 PyDoc_STRVAR(scribus_getallobjects__doc__,
 QT_TR_NOOP("getAllObjects([type, page, \"layer\"]) -> list\n\
 \n\
diff -Napur a/scribus/plugins/scriptplugin/cmdmisc.cpp f/scribus/plugins/scriptplugin/cmdmisc.cpp
--- a/scribus/plugins/scriptplugin/cmdmisc.cpp	2025-01-08 21:31:35.000000000 +0100
+++ f/scribus/plugins/scriptplugin/cmdmisc.cpp	2025-02-07 13:56:47.788904910 +0100
@@ -263,7 +263,7 @@ PyObject *scribus_setlayervisible(PyObje
 		return nullptr;
 	}
 	bool found = false;
-	for (int lam=0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); ++lam)
+	for (int lam = 0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); ++lam)
 	{
 		if (ScCore->primaryMainWindow()->doc->Layers[lam].Name == QString::fromUtf8(name.c_str()))
 		{
@@ -294,7 +294,7 @@ PyObject *scribus_setlayerprintable(PyOb
 		return nullptr;
 	}
 	bool found = false;
-	for (int lam=0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); ++lam)
+	for (int lam = 0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); ++lam)
 	{
 		if (ScCore->primaryMainWindow()->doc->Layers[lam].Name == QString::fromUtf8(name.c_str()))
 		{
@@ -325,7 +325,7 @@ PyObject *scribus_setlayerlocked(PyObjec
 		return nullptr;
 	}
 	bool found = false;
-	for (int lam=0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); ++lam)
+	for (int lam = 0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); ++lam)
 	{
 		if (ScCore->primaryMainWindow()->doc->Layers[lam].Name == QString::fromUtf8(name.c_str()))
 		{
@@ -356,7 +356,7 @@ PyObject *scribus_setlayeroutlined(PyObj
 		return nullptr;
 	}
 	bool found = false;
-	for (int lam=0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); ++lam)
+	for (int lam = 0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); ++lam)
 	{
 		if (ScCore->primaryMainWindow()->doc->Layers[lam].Name == QString::fromUtf8(name.c_str()))
 		{
@@ -387,7 +387,7 @@ PyObject *scribus_setlayerflow(PyObject*
 		return nullptr;
 	}
 	bool found = false;
-	for (int lam=0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); ++lam)
+	for (int lam = 0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); ++lam)
 	{
 		if (ScCore->primaryMainWindow()->doc->Layers[lam].Name == QString::fromUtf8(name.c_str()))
 		{
@@ -418,7 +418,7 @@ PyObject *scribus_setlayerblendmode(PyOb
 		return nullptr;
 	}
 	bool found = false;
-	for (int lam=0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); ++lam)
+	for (int lam = 0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); ++lam)
 	{
 		if (ScCore->primaryMainWindow()->doc->Layers[lam].Name == QString::fromUtf8(name.c_str()))
 		{
@@ -449,7 +449,7 @@ PyObject *scribus_setlayertransparency(P
 		return nullptr;
 	}
 	bool found = false;
-	for (int lam=0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); ++lam)
+	for (int lam = 0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); ++lam)
 	{
 		if (ScCore->primaryMainWindow()->doc->Layers[lam].Name == QString::fromUtf8(name.c_str()))
 		{
@@ -480,7 +480,7 @@ PyObject *scribus_islayervisible(PyObjec
 	}
 	int i = 0;
 	bool found = false;
-	for (int lam=0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); lam++)
+	for (int lam = 0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); lam++)
 	{
 		if (ScCore->primaryMainWindow()->doc->Layers[lam].Name == QString::fromUtf8(name.c_str()))
 		{
@@ -511,7 +511,7 @@ PyObject *scribus_islayerprintable(PyObj
 	}
 	int i = 0;
 	bool found = false;
-	for (int lam=0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); ++lam)
+	for (int lam = 0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); ++lam)
 	{
 		if (ScCore->primaryMainWindow()->doc->Layers[lam].Name == QString::fromUtf8(name.c_str()))
 		{
@@ -542,11 +542,11 @@ PyObject *scribus_islayerlocked(PyObject
 	}
 	int i = 0;
 	bool found = false;
-	for (int lam=0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); lam++)
+	for (int lam = 0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); lam++)
 	{
 		if (ScCore->primaryMainWindow()->doc->Layers[lam].Name == QString::fromUtf8(name.c_str()))
 		{
-			i = static_cast<int>(ScCore->primaryMainWindow()->doc->Layers[lam].isEditable);
+			i = static_cast<int>(!ScCore->primaryMainWindow()->doc->Layers[lam].isEditable);
 			found = true;
 			break;
 		}
@@ -573,7 +573,7 @@ PyObject *scribus_islayeroutlined(PyObje
 	}
 	int i = 0;
 	bool found = false;
-	for (int lam=0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); lam++)
+	for (int lam = 0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); lam++)
 	{
 		if (ScCore->primaryMainWindow()->doc->Layers[lam].Name == QString::fromUtf8(name.c_str()))
 		{
@@ -604,7 +604,7 @@ PyObject *scribus_islayerflow(PyObject*
 	}
 	int i = 0;
 	bool found = false;
-	for (int lam=0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); lam++)
+	for (int lam = 0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); lam++)
 	{
 		if (ScCore->primaryMainWindow()->doc->Layers[lam].Name == QString::fromUtf8(name.c_str()))
 		{
@@ -635,7 +635,7 @@ PyObject *scribus_getlayerblendmode(PyOb
 	}
 	int i = 0;
 	bool found = false;
-	for (int lam=0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); lam++)
+	for (int lam = 0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); lam++)
 	{
 		if (ScCore->primaryMainWindow()->doc->Layers[lam].Name == QString::fromUtf8(name.c_str()))
 		{
@@ -666,7 +666,7 @@ PyObject *scribus_getlayertransparency(P
 	}
 	double i = 1.0;
 	bool found = false;
-	for (int lam=0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); lam++)
+	for (int lam = 0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); lam++)
 	{
 		if (ScCore->primaryMainWindow()->doc->Layers[lam].Name == QString::fromUtf8(name.c_str()))
 		{
@@ -696,37 +696,30 @@ PyObject *scribus_deletelayer(PyObject*
 		PyErr_SetString(PyExc_ValueError, QObject::tr("Cannot have an empty layer name.","python error").toLocal8Bit().constData());
 		return nullptr;
 	}
-	if (ScCore->primaryMainWindow()->doc->Layers.count() == 1)
+
+	auto* currentDoc = ScCore->primaryMainWindow()->doc;
+	if (currentDoc->Layers.count() == 1)
 	{
 		PyErr_SetString(ScribusException, QObject::tr("Cannot remove the last layer.","python error").toLocal8Bit().constData());
 		return nullptr;
 	}
-	bool found = false;
-	for (int lam=0; lam < ScCore->primaryMainWindow()->doc->Layers.count(); ++lam)
-	{
-		if (ScCore->primaryMainWindow()->doc->Layers[lam].Name == QString::fromUtf8(name.c_str()))
-		{
-			ScLayer it2 = ScCore->primaryMainWindow()->doc->Layers.at(lam);
-			int num2 = it2.ID;
-			if (!num2)
-			{
-				// FIXME: WTF DOES THIS DO?
-				Py_INCREF(Py_None);
-				return Py_None;
-			}
-			ScCore->primaryMainWindow()->doc->removeLayer(num2);
-			ScCore->primaryMainWindow()->doc->Layers.removeLayerByID(num2);
-			ScCore->primaryMainWindow()->doc->setActiveLayer(0);
-			ScCore->primaryMainWindow()->changeLayer(0);
-			found = true;
-			break;
-		}
-	}
-	if (!found)
+
+	const ScLayer* pLayer = currentDoc->Layers.layerByName(QString::fromUtf8(name.c_str()));
+	if (!pLayer)
 	{
-		PyErr_SetString(NotFoundError, QObject::tr("Layer not found.","python error").toLocal8Bit().constData());
+		PyErr_SetString(NotFoundError, QObject::tr("Layer not found.", "python error").toLocal8Bit().constData());
 		return nullptr;
 	}
+
+	int num2 = pLayer->ID;
+	if (!num2)
+		Py_RETURN_NONE;
+
+	currentDoc->removeLayer(num2);
+	currentDoc->Layers.removeLayerByID(num2);
+	currentDoc->setActiveLayer(0);
+	ScCore->primaryMainWindow()->changeLayer(0);
+
 	Py_RETURN_NONE;
 }
 
diff -Napur a/scribus/plugins/scriptplugin/cmdmisc.h f/scribus/plugins/scriptplugin/cmdmisc.h
--- a/scribus/plugins/scriptplugin/cmdmisc.h	2025-01-08 21:31:36.000000000 +0100
+++ f/scribus/plugins/scriptplugin/cmdmisc.h	2025-02-07 13:56:47.789904892 +0100
@@ -246,8 +246,8 @@ PyDoc_STRVAR(scribus_islayerlocked__doc_
 QT_TR_NOOP("isLayerLocked(\"layer\") -> bool\n\
 \n\
 Returns whether the layer \"layer\" is locked or not, a value of True means\n\
-that the layer \"layer\" is editable, a value of False means that the layer\n\
-\"layer\" is locked.\n\
+that the layer \"layer\" is locked, a value of False means that the layer\n\
+\"layer\" is editable.\n\
 \n\
 May raise NotFoundError if the layer can't be found.\n\
 May raise ValueError if the layer name isn't acceptable.\n\
diff -Napur a/scribus/plugins/scriptplugin/cmdpage.cpp f/scribus/plugins/scriptplugin/cmdpage.cpp
--- a/scribus/plugins/scriptplugin/cmdpage.cpp	2025-01-08 21:31:35.000000000 +0100
+++ f/scribus/plugins/scriptplugin/cmdpage.cpp	2025-02-07 13:56:47.789904892 +0100
@@ -23,7 +23,6 @@ PyObject *scribus_currentpage(PyObject*
 	return PyLong_FromLong(static_cast<long>(ScCore->primaryMainWindow()->doc->currentPageNumber() + 1));
 }
 
-
 PyObject *scribus_currentpagenumberforsection(PyObject* /* self */)
 {
 	if (!checkHaveDocument())
@@ -190,6 +189,49 @@ PyObject *scribus_getpagesize(PyObject*
 	return t;
 }
 
+PyObject *scribus_getcurrentpagesize(PyObject* /* self */)
+{
+    if (!checkHaveDocument())
+        return nullptr;
+    ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
+    const ScPage* currentPage = currentDoc->currentPage();
+
+    if (currentPage == nullptr)
+        return nullptr;
+
+    PyObject *t;
+    t = Py_BuildValue(
+        "(dd)",
+        PointToValue(currentPage->width()),
+        PointToValue(currentPage->height())
+        );
+    return t;
+}
+
+PyObject *scribus_setcurrentpagesize(PyObject* /* self */, PyObject* args)
+{
+    double width, height;
+    if (!PyArg_ParseTuple(args, "dd", &width, &height))
+        return nullptr;
+    if (!checkHaveDocument())
+        return nullptr;
+
+    ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
+    ScribusView* currentView = ScCore->primaryMainWindow()->view;
+    ScPage* currentPage = currentDoc->currentPage();
+
+    if (currentPage == nullptr)
+        return nullptr;
+
+    currentPage->setWidth(ValueToPoint(width));
+    currentPage->setHeight(ValueToPoint(height));
+
+    currentView->reformPagesView();
+    currentView->DrawNew();
+
+    Py_RETURN_NONE;
+}
+
 PyObject *scribus_getpagensize(PyObject* /* self */, PyObject* args)
 {
 	int e;
@@ -692,7 +734,6 @@ PyObject *scribus_importpage(PyObject* /
 	Py_RETURN_NONE;
 }
 
-
 /*! HACK: this removes "warning: 'blah' defined but not used" compiler warnings
 with header files structure untouched (docstrings are kept near declarations)
 PV */
@@ -702,11 +743,12 @@ void cmdpagedocwarnings()
 	s << scribus_currentpage__doc__
 	  << scribus_deletepage__doc__
 	  << scribus_getColumnGuides__doc__
+	  << scribus_getcurrentpagesize__doc__
 	  << scribus_getHguides__doc__
 	  << scribus_getpageitems__doc__
 	  << scribus_getpagemargins__doc__
-	  << scribus_getpagenmargins__doc__ 
-	  << scribus_getpagensize__doc__ 
+	  << scribus_getpagenmargins__doc__
+	  << scribus_getpagensize__doc__
 	  << scribus_getpagesize__doc__
 	  << scribus_getpagetype__doc__
 	  << scribus_getRowGuides__doc__
@@ -716,8 +758,9 @@ void cmdpagedocwarnings()
 	  << scribus_newpage__doc__
 	  << scribus_pagecount__doc__
 	  << scribus_redraw__doc__
-	  << scribus_savepageeps__doc__           
+	  << scribus_savepageeps__doc__
 	  << scribus_setColumnGuides__doc__
+	  << scribus_setcurrentpagesize__doc__
 	  << scribus_setHguides__doc__
 	  << scribus_setRowGuides__doc__
 	  << scribus_setVguides__doc__;
diff -Napur a/scribus/plugins/scriptplugin/cmdpage.h f/scribus/plugins/scriptplugin/cmdpage.h
--- a/scribus/plugins/scriptplugin/cmdpage.h	2025-01-08 21:31:35.000000000 +0100
+++ f/scribus/plugins/scriptplugin/cmdpage.h	2025-02-07 13:56:47.789904892 +0100
@@ -46,7 +46,7 @@ PyObject *scribus_currentpage(PyObject *
  "));
  /*! get actual page */
  PyObject *scribus_currentpagenumberforsection(PyObject * /*self*/);
- 
+
 /*! docstring */
 PyDoc_STRVAR(scribus_redraw__doc__,
 QT_TR_NOOP("redrawAll()\n\
@@ -217,6 +217,25 @@ e.g. when is the doc in picas returns pi
 PyObject *scribus_getpagesize(PyObject * /*self*/);
 
 /*! docstring */
+PyDoc_STRVAR(scribus_getcurrentpagesize__doc__,
+QT_TR_NOOP("getCurrentPageSize() ->  (width, height)\n\
+\n\
+Returns a tuple with current page dimensions measured in the document's current units.\n\
+See UNIT_<type> constants and getPageMargins()\n\
+"));
+PyObject *scribus_getcurrentpagesize(PyObject * /*self*/);
+
+
+/*! docstring */
+PyDoc_STRVAR(scribus_setcurrentpagesize__doc__,
+QT_TR_NOOP("setCurrentPageSize(width, height)\n\
+\n\
+Sets the current page dimensions measured in the document's current units.\n\
+See UNIT_<type> constants and getPageMargins()\n\
+"));
+PyObject *scribus_setcurrentpagesize(PyObject * /*self*/, PyObject* args);
+
+/*! docstring */
 PyDoc_STRVAR(scribus_getpagensize__doc__,
 QT_TR_NOOP("getPageNSize(nr) -> tuple\n\
 \n\
@@ -284,5 +303,6 @@ importWherePage: number; used if create=
 "));
 PyObject *scribus_importpage(PyObject */*self*/, PyObject* args);
 
+
 #endif
 
diff -Napur a/scribus/plugins/scriptplugin/cmdtext.cpp f/scribus/plugins/scriptplugin/cmdtext.cpp
--- a/scribus/plugins/scriptplugin/cmdtext.cpp	2025-01-08 21:31:35.000000000 +0100
+++ f/scribus/plugins/scriptplugin/cmdtext.cpp	2025-02-07 13:56:47.787904927 +0100
@@ -153,6 +153,60 @@ PyObject *scribus_gettextshade(PyObject*
 	return PyLong_FromLong(item->currentCharStyle().fillShade());
 }
 
+PyObject *scribus_gettracking(PyObject* /* self */, PyObject* args)
+{
+	PyESString name;
+	if (!PyArg_ParseTuple(args, "|es", "utf-8", name.ptr()))
+		return nullptr;
+	if (!checkHaveDocument())
+		return nullptr;
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	if (item == nullptr)
+		return nullptr;
+	if (!(item->isTextFrame()) && !(item->isPathText()))
+	{
+		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot get tracking of non-text frame.", "python error").toLocal8Bit().constData());
+		return nullptr;
+	}
+	if (item->HasSel)
+	{
+		for (int i = 0; i < item->itemText.length(); ++i)
+		{
+			if (item->itemText.selected(i))
+				return PyLong_FromLong(item->itemText.charStyle(i).tracking());
+		}
+		return nullptr;
+	}
+	return PyLong_FromLong(item->currentCharStyle().tracking()/10.0);
+}
+
+PyObject *scribus_getwordtracking(PyObject* /* self */, PyObject* args)
+{
+	PyESString name;
+	if (!PyArg_ParseTuple(args, "|es", "utf-8", name.ptr()))
+		return nullptr;
+	if (!checkHaveDocument())
+		return nullptr;
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	if (item == nullptr)
+		return nullptr;
+	if (!(item->isTextFrame()) && !(item->isPathText()))
+	{
+		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot get word tracking of non-text frame.", "python error").toLocal8Bit().constData());
+		return nullptr;
+	}
+	if (item->HasSel)
+	{
+		for (int i = 0; i < item->itemText.length(); ++i)
+		{
+			if (item->itemText.selected(i))
+				return PyLong_FromLong(item->itemText.charStyle(i).wordTracking());
+		}
+		return nullptr;
+	}
+	return PyLong_FromLong(item->currentCharStyle().wordTracking()*100.0);
+}
+
 PyObject *scribus_gettextlength(PyObject* /* self */, PyObject* args)
 {
 	PyESString name;
@@ -876,6 +930,66 @@ PyObject *scribus_setlinespacing(PyObjec
 	doc->appMode = oldAppMode;
 
 	Py_RETURN_NONE;
+}
+
+PyObject *scribus_settracking(PyObject* /* self */, PyObject* args)
+{
+	PyESString name;
+	double kern;
+	if (!PyArg_ParseTuple(args, "d|es", &kern, "utf-8", name.ptr()))
+		return nullptr;
+	if (!checkHaveDocument())
+		return nullptr;
+	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	if (item == nullptr)
+		return nullptr;
+	if (!item->isTextFrame())
+	{
+		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot set tracking on a non-text frame.","python error").toLocal8Bit().constData());
+		return nullptr;
+	}
+
+	ScribusDoc* doc = ScCore->primaryMainWindow()->doc;
+	int oldAppMode = ScCore->primaryMainWindow()->doc->appMode;
+
+	Selection tmpSelection(nullptr, false);
+	tmpSelection.addItem(item);
+	if (item->HasSel)
+		doc->appMode = modeEdit;
+	doc->itemSelection_SetTracking(kern * 10.0, &tmpSelection);
+	doc->appMode = oldAppMode;
+
+	Py_RETURN_NONE;
+}
+
+PyObject *scribus_setwordtracking(PyObject* /* self */, PyObject* args)
+{
+	PyESString name;
+	double kern;
+	if (!PyArg_ParseTuple(args, "d|es", &kern, "utf-8", name.ptr()))
+		return nullptr;
+	if (!checkHaveDocument())
+		return nullptr;
+	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	if (item == nullptr)
+		return nullptr;
+	if (!item->isTextFrame())
+	{
+		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot set word tracking on a non-text frame.","python error").toLocal8Bit().constData());
+		return nullptr;
+	}
+
+	ScribusDoc* doc = ScCore->primaryMainWindow()->doc;
+	int oldAppMode = ScCore->primaryMainWindow()->doc->appMode;
+
+	Selection tmpSelection(nullptr, false);
+	tmpSelection.addItem(item);
+	if (item->HasSel)
+		doc->appMode = modeEdit;
+	doc->itemSelection_SetWordTracking(kern / 100.0, &tmpSelection);
+	doc->appMode = oldAppMode;
+
+	Py_RETURN_NONE;
 }
 
 PyObject *scribus_setlinespacingmode(PyObject* /* self */, PyObject* args)
diff -Napur a/scribus/plugins/scriptplugin/cmdtext.h f/scribus/plugins/scriptplugin/cmdtext.h
--- a/scribus/plugins/scriptplugin/cmdtext.h	2025-01-08 21:31:35.000000000 +0100
+++ f/scribus/plugins/scriptplugin/cmdtext.h	2025-02-07 13:56:47.788904910 +0100
@@ -188,6 +188,29 @@ If \"name\" is not given the currently s
 PyObject *scribus_getfirstlineoffset(PyObject * /*self*/, PyObject* args);
 
 /*! docstring */
+PyDoc_STRVAR(scribus_gettracking__doc__,
+	QT_TR_NOOP("getTracking([\"name\"]) -> integer\n\
+\n\
+Gets the tracking of text inside text frame \"name\".\n\
+If \"name\" is not given the currently selected item is used. \n\
+If there is some text selected only the selected text tracking is returned.\n\
+"));
+/*! Get tracking */
+PyObject *scribus_gettracking(PyObject * /*self*/, PyObject* args);
+
+
+/*! docstring */
+PyDoc_STRVAR(scribus_getwordtracking__doc__,
+QT_TR_NOOP("getWordTracking([\"name\"]) -> integer\n\
+\n\
+Gets the word tracking of text inside text frame \"name\".\n\
+If \"name\" is not given the currently selected item is used. \n\
+If there is some text selected only the selected text tracking is returned.\n\
+"));
+/*! Get word tracking */
+PyObject *scribus_getwordtracking(PyObject * /*self*/, PyObject* args);
+
+/*! docstring */
 PyDoc_STRVAR(scribus_getlinespacing__doc__,
 QT_TR_NOOP("getLineSpacing([\"name\"]) -> float\n\
 \n\
@@ -593,6 +616,31 @@ used.\n\
 PyObject *scribus_settextshade(PyObject * /*self*/, PyObject* args);
 
 /*! docstring */
+PyDoc_STRVAR(scribus_settracking__doc__,
+QT_TR_NOOP("setTracking(kern, [\"name\"])\n\
+\n\
+Sets the tracking of the text the object \"name\" to \"kern\". If\n\
+there is some text selected only the selected text is changed. \"kern\" must\n\
+be an integer. If \"name\" is not given the currently selected item is\n\
+used.\n\
+"));
+
+/*! Set text tracking */
+PyObject *scribus_settracking(PyObject * /*self*/, PyObject* args);
+
+/*! docstring */
+PyDoc_STRVAR(scribus_setwordtracking__doc__,
+QT_TR_NOOP("setWordTracking(kern, [\"name\"])\n\
+\n\
+Sets the word tracking of the text the object \"name\" to \"kern\". If\n\
+there is some text selected only the selected text is changed. \"kern\" must\n\
+be an integer. If \"name\" is not given the currently selected item is\n\
+used.\n\
+"));
+/*! Set text word tracking */
+PyObject *scribus_setwordtracking(PyObject * /*self*/, PyObject* args);
+
+/*! docstring */
 PyDoc_STRVAR(scribus_linktextframes__doc__,
 QT_TR_NOOP("linkTextFrames(\"fromname\", \"toname\")\n\
 \n\
diff -Napur a/scribus/plugins/scriptplugin/scriptercore.cpp f/scribus/plugins/scriptplugin/scriptercore.cpp
--- a/scribus/plugins/scriptplugin/scriptercore.cpp	2025-01-08 21:31:35.000000000 +0100
+++ f/scribus/plugins/scriptplugin/scriptercore.cpp	2025-02-07 13:56:47.788904910 +0100
@@ -6,41 +6,41 @@ for which a new license (GPL+exception)
 */
 #include "scriptercore.h"
 
-#include <QGlobalStatic>
-#include <QWidget>
-#include <QString>
-#include <QStringList>
+#include <cstdlib>
+
 #include <QApplication>
-#include <QMessageBox>
-#include <QTextCodec>
 #include <QByteArray>
+#include <QGlobalStatic>
+#include <QMessageBox>
 #include <QPixmap>
-#include <cstdlib>
+#include <QString>
+#include <QStringList>
+#include <QWidget>
 
 #include "cmdutil.h"
+#include "pconsole.h"
+#include "prefscontext.h"
+#include "prefsfile.h"
+#include "prefsmanager.h"
+#include "prefstable.h"
 #include "runscriptdialog.h"
+#include "scpaths.h"
+#include "scraction.h"
+#include "scribusapp.h" // need it to access ScQApp->pythonScript & ScQApp->pythonScriptArgs
+#include "scribuscore.h"
+#include "scribusdoc.h"
+#include "scribusview.h"
+#include "selection.h"
+#include "ui/contentpalette.h" //TODO Move the calls to this to a signal
 #include "ui/helpbrowser.h"
+#include "ui/layers.h" //TODO Move the calls to this to a signal
 #include "ui/marksmanager.h"
 #include "ui/notesstyleseditor.h"
-#include "ui/propertiespalette.h" //TODO Move the calls to this to a signal
-#include "ui/contentpalette.h" //TODO Move the calls to this to a signal
-#include "ui/pagepalette.h" //TODO Move the calls to this to a signal
-#include "ui/layers.h" //TODO Move the calls to this to a signal
 #include "ui/outlinepalette.h" //TODO Move the calls to this to a signal
+#include "ui/pagepalette.h" //TODO Move the calls to this to a signal
+#include "ui/propertiespalette.h" //TODO Move the calls to this to a signal
 #include "ui/scmessagebox.h"
 #include "ui/scmwmenumanager.h"
-#include "pconsole.h"
-#include "scraction.h"
-#include "scribuscore.h"
-#include "scribusdoc.h"
-#include "scribusview.h"
-#include "scpaths.h"
-#include "selection.h"
-#include "prefsfile.h"
-#include "prefscontext.h"
-#include "prefstable.h"
-#include "prefsmanager.h"
-#include "scribusapp.h" // need it to access ScQApp->pythonScript & ScQApp->pythonScriptArgs
 
 ScripterCore::ScripterCore(QWidget* parent)
 {
diff -Napur a/scribus/plugins/scriptplugin/scriptplugin.cpp f/scribus/plugins/scriptplugin/scriptplugin.cpp
--- a/scribus/plugins/scriptplugin/scriptplugin.cpp	2025-01-08 21:31:35.000000000 +0100
+++ f/scribus/plugins/scriptplugin/scriptplugin.cpp	2025-02-07 13:56:47.788904910 +0100
@@ -21,6 +21,17 @@ for which a new license (GPL+exception)
  *                                                                         *
  ***************************************************************************/
 
+#include <cstdlib>
+#include <iostream>
+
+#include <QApplication>
+#include <QByteArray>
+#include <QMessageBox>
+#include <QPixmap>
+#include <QRegExp>
+#include <QString>
+#include <QWidget>
+
 // include cmdvar.h first, as it pulls in <Python.h>
 #include "cmdannotations.h"
 #include "cmdvar.h"
@@ -60,35 +71,22 @@ for which a new license (GPL+exception)
 
 #include "api/api_application.h"
 
-#include <QApplication>
-#include <QMessageBox>
-#include <QTextCodec>
-#include <QRegExp>
-#include <QPixmap>
-#include <QWidget>
-#include <QString>
-//Added by qt3to4:
-#include <QByteArray>
-#include <cstdlib>
-#include <iostream>
-
-
 #ifdef HAVE_SCRIPTER2
 extern void scripter2_init();
 #endif
 
 // Exceptions; visible from cmdvar.h, set up in initscribus()
-PyObject* ScribusException;
-PyObject* NoDocOpenError;
-PyObject* WrongFrameTypeError;
-PyObject* NoValidObjectError;
-PyObject* NotFoundError;
-PyObject* NameExistsError;
+PyObject* ScribusException = nullptr;
+PyObject* NoDocOpenError = nullptr;
+PyObject* WrongFrameTypeError = nullptr;
+PyObject* NoValidObjectError = nullptr;
+PyObject* NotFoundError = nullptr;
+PyObject* NameExistsError = nullptr;
 
 // Other extern variables defined in cmdvar.h
-PyObject* wrappedMainWindow;
-PyObject* wrappedQApp;
-ScripterCore* scripterCore;
+PyObject* wrappedMainWindow = nullptr;
+PyObject* wrappedQApp = nullptr;
+ScripterCore* scripterCore = nullptr;
 
 
 int scriptplugin_getPluginAPIVersion()
@@ -338,6 +336,7 @@ PyMethodDef scribus_methods[] = {
 	{ "getAllText", scribus_getalltext, METH_VARARGS, tr(scribus_getalltext__doc__)},
 	{ "getBaseLine", (PyCFunction) scribus_getbaseline, METH_NOARGS, tr(scribus_getbaseline__doc__)},
 	{ "getBleeds", scribus_getbleeds, METH_NOARGS, tr(scribus_getbleeds__doc__)},
+	{ "getBoundingBox", scribus_getboundingbox, METH_VARARGS, tr(scribus_getboundingbox__doc__)},
 	{ "getCellColumnSpan", scribus_getcellcolumnspan, METH_VARARGS, tr(scribus_getcellcolumnspan__doc__)},
 	{ "getCellFillColor", scribus_getcellfillcolor, METH_VARARGS, tr(scribus_getcellfillcolor__doc__)},
 	{ "getCellRowSpan", scribus_getcellrowspan, METH_VARARGS, tr(scribus_getcellrowspan__doc__)},
@@ -355,6 +354,7 @@ PyMethodDef scribus_methods[] = {
 	{ "getColumns", scribus_getcolumns, METH_VARARGS, tr(scribus_getcolumns__doc__)},
 	{ "getColumnGuides", (PyCFunction) scribus_getColumnGuides, METH_VARARGS|METH_KEYWORDS, tr(scribus_getColumnGuides__doc__)},
 	{ "getCornerRadius", scribus_getcornerradius, METH_VARARGS, tr(scribus_getcornerradius__doc__)},
+	{ "getCurrentPageSize", (PyCFunction) scribus_getcurrentpagesize, METH_NOARGS, tr(scribus_getcurrentpagesize__doc__)},
 	{ "getCustomLineStyle", scribus_getcustomlinestyle, METH_VARARGS, tr(scribus_getcustomlinestyle__doc__)},
 	{ "getDocName", (PyCFunction) scribus_getdocname, METH_NOARGS, tr(scribus_getdocname__doc__)},
 	{ "getFillBlendmode", scribus_getfillblendmode, METH_VARARGS, tr(scribus_getfillblendmode__doc__)},
@@ -429,7 +429,10 @@ PyMethodDef scribus_methods[] = {
 	{ "getTextLines", scribus_gettextlines, METH_VARARGS, tr(scribus_gettextlines__doc__)},
 	{ "getTextShade", scribus_gettextshade, METH_VARARGS, tr(scribus_gettextshade__doc__)},
 	{ "getTextVerticalAlignment", scribus_gettextverticalalignment, METH_VARARGS, tr(scribus_gettextverticalalignment__doc__)},
+	{ "getTracking", scribus_gettracking, METH_VARARGS, tr(scribus_gettracking__doc__) },
 	{ "getUnit", (PyCFunction) scribus_getunit, METH_NOARGS, tr(scribus_getunit__doc__)},
+	{ "getVisualBoundingBox", scribus_getvisualboundingbox, METH_VARARGS, tr(scribus_getvisualboundingbox__doc__) },
+	{ "getWordTracking", scribus_getwordtracking, METH_VARARGS, tr(scribus_getwordtracking__doc__) },
 	{ "pointsToDocUnit", scribus_pointstodocunit, METH_VARARGS, tr(scribus_pointstodocunit__doc__)},
 	{ "docUnitToPoints", scribus_docunittopoints, METH_VARARGS, tr(scribus_docunittopoints__doc__)},
 	{ "stringValueToPoints", scribus_stringvaluetopoints, METH_VARARGS, tr(scribus_stringvaluetopoints__doc__)},
@@ -529,6 +532,7 @@ PyMethodDef scribus_methods[] = {
 	{ "setColumns", scribus_setcolumns, METH_VARARGS, tr(scribus_setcolumns__doc__)},
 	{ "setColumnGuides", (PyCFunction) scribus_setColumnGuides, METH_VARARGS|METH_KEYWORDS, tr(scribus_setColumnGuides__doc__)},
 	{ "setCornerRadius", scribus_setcornerradius, METH_VARARGS, tr(scribus_setcornerradius__doc__)},
+	{ "setCurrentPageSize", scribus_setcurrentpagesize, METH_VARARGS, tr(scribus_setcurrentpagesize__doc__) },
 	{ "setCursor", scribus_setcursor, METH_VARARGS, tr(scribus_setcursor__doc__)},
 	{ "setCustomLineStyle", scribus_setcustomlinestyle, METH_VARARGS, tr(scribus_setcustomlinestyle__doc__)},
 	{ "setDocType", scribus_setdoctype, METH_VARARGS, tr(scribus_setdoctype__doc__)},
@@ -598,8 +602,10 @@ PyMethodDef scribus_methods[] = {
 	{ "setTextShade", scribus_settextshade, METH_VARARGS, tr(scribus_settextshade__doc__)},
 	{ "setTextStroke", scribus_settextstroke, METH_VARARGS, tr(scribus_settextstroke__doc__)},
 	{ "setTextVerticalAlignment", scribus_settextverticalalignment, METH_VARARGS, tr(scribus_settextverticalalignment__doc__)},
+	{ "setTracking", scribus_settracking, METH_VARARGS, tr(scribus_settracking__doc__) },
 	{ "setUnit", scribus_setunit, METH_VARARGS, tr(scribus_setunit__doc__)},
 	{ "setVGuides", scribus_setVguides, METH_VARARGS, tr(scribus_setVguides__doc__)},
+	{ "setWordTracking", scribus_setwordtracking, METH_VARARGS, tr(scribus_setwordtracking__doc__) },
 	{ "sizeObject", scribus_sizeobject, METH_VARARGS, tr(scribus_sizeobject__doc__)},
 	{ "statusMessage", scribus_statusmessage, METH_VARARGS, tr(scribus_statusmessage__doc__)},
 	{ "textFlowMode", scribus_settextflowmode, METH_VARARGS, tr(scribus_textflowmode__doc__)}, // Deprecated
@@ -627,8 +633,8 @@ PyMethodDef scribus_methods[] = {
 	// by Tj (hacker@iam.tj>
 	{ "combinePolygons", (PyCFunction) scribus_combinepolygons, METH_NOARGS, tr(scribus_combinepolygons__doc__)},
 	// Internal methods - Not for public use
-	{ "retval", (PyCFunction) scribus_retval, METH_VARARGS,  "Scribus internal."},
-	{ "getval", (PyCFunction) scribus_getval, METH_NOARGS,  "Scribus internal."},
+	{ "retval", (PyCFunction) scribus_retval, METH_VARARGS, "Scribus internal." },
+	{ "getval", (PyCFunction) scribus_getval, METH_NOARGS, "Scribus internal." },
 	{ "setLinkAnnotation", scribus_setlinkannotation, METH_VARARGS,tr(scribus_setlinkannotation__doc__)},
 	{ "setFileAnnotation", (PyCFunction) scribus_setfileannotation, METH_VARARGS|METH_KEYWORDS,tr(scribus_setfileannotation__doc__)},
 	{ "setURIAnnotation", scribus_seturiannotation, METH_VARARGS,tr(scribus_seturiannotation__doc__)},
diff -Napur a/scribus/plugins/shapes/shapepalette.cpp f/scribus/plugins/shapes/shapepalette.cpp
--- a/scribus/plugins/shapes/shapepalette.cpp	2025-01-08 21:31:38.000000000 +0100
+++ f/scribus/plugins/shapes/shapepalette.cpp	2025-02-07 13:56:47.968901689 +0100
@@ -472,7 +472,7 @@ void ShapePalette::Import()
 		qint32 x, y, w, h;
 		ds >> y >> x >> h >> w;
 		paDataLen = shpLen - 53;
-		QRect bounds = QRect(QPoint(x,y), QPoint(w, h));
+		QRect bounds(QPoint(x,y), QPoint(w, h));
 		bool first = false;
 		bool pathOpen = false;
 		FPoint firstPoint, firstControl;
diff -Napur a/scribus/plugins/short-words/shortwords.cpp f/scribus/plugins/short-words/shortwords.cpp
--- a/scribus/plugins/short-words/shortwords.cpp	2025-01-08 21:31:38.000000000 +0100
+++ f/scribus/plugins/short-words/shortwords.cpp	2025-02-07 13:56:47.955901922 +0100
@@ -21,7 +21,6 @@ or documentation
 #include <QFile>
 #include <QMessageBox>
 #include <QProgressBar>
-#include <QTextCodec>
 #include <QPixmap>
 
 #include "configuration.h"
diff -Napur a/scribus/plugins/tools/2geomtools/pathalongpath/pathalongpath.cpp f/scribus/plugins/tools/2geomtools/pathalongpath/pathalongpath.cpp
--- a/scribus/plugins/tools/2geomtools/pathalongpath/pathalongpath.cpp	2025-01-08 00:06:53.000000000 +0100
+++ f/scribus/plugins/tools/2geomtools/pathalongpath/pathalongpath.cpp	2025-02-07 13:56:47.986901367 +0100
@@ -159,114 +159,115 @@ bool PathAlongPathPlugin::run(ScribusDoc
 	patternItemG.clear();
 	if (m_doc == nullptr)
 		m_doc = ScCore->primaryMainWindow()->doc;
-	if (m_doc->m_Selection->count() > 1)
+
+	if (m_doc->m_Selection->count() < 2)
+		return true;
+
+	if ((m_doc->m_Selection->itemAt(0)->isGroup()) || (m_doc->m_Selection->itemAt(1)->isGroup()))
 	{
-		if ((m_doc->m_Selection->itemAt(0)->isGroup()) || (m_doc->m_Selection->itemAt(1)->isGroup()))
+		selOffs = 0;
+		selCount = m_doc->m_Selection->count() - 1;
+		if (!m_doc->m_Selection->itemAt(0)->isGroup())
 		{
-			selOffs = 0;
-			selCount = m_doc->m_Selection->count() - 1;
-			if (!m_doc->m_Selection->itemAt(0)->isGroup())
-			{
-				pathItem = m_doc->m_Selection->itemAt(0);
-				selOffs = 1;
-			}
-			else
-				pathItem = m_doc->m_Selection->itemAt(selCount);
-			effectPath = pathItem->PoLine.copy();
-			QTransform mp;
-			mp.rotate(pathItem->rotation());
-			effectPath.map(mp);
-			PageItem* bxi = m_doc->m_Selection->itemAt(selOffs);
-			bxi->asGroupFrame()->adjustXYPosition();
-			originalPathG.append(bxi->PoLine.copy());
-			originalXPosG.append(bxi->xPos());
-			originalYPosG.append(bxi->yPos());
-			originalXPosGi.append(bxi->gXpos);
-			originalYPosGi.append(bxi->gYpos);
-			originalRotG.append(bxi->rotation());
-			originalWidth.append(bxi->width());
-			originalHeight.append(bxi->height());
-			originalWidthG.append(bxi->groupWidth);
-			originalHeightG.append(bxi->groupHeight);
-			patternItemG.append(bxi);
-			QList<PageItem*> bxiL = bxi->getAllChildren();
-			for (int bx = 0; bx < bxiL.count(); ++bx)
-			{
-				PageItem* cIte = bxiL.at(bx);
-				originalPathG.append(cIte->PoLine.copy());
-				originalXPosG.append(cIte->xPos());
-				originalYPosG.append(cIte->yPos());
-				originalWidth.append(cIte->width());
-				originalHeight.append(cIte->height());
-				originalWidthG.append(cIte->groupWidth);
-				originalHeightG.append(cIte->groupHeight);
-				originalXPosGi.append(cIte->gXpos);
-				originalYPosGi.append(cIte->gYpos);
-				originalRotG.append(cIte->rotation());
-				patternItemG.append(cIte);
-			}
-			QPainterPath tmpPath = effectPath.toQPainterPath(false);
-			PathDialog *dia = new PathDialog(m_doc->scMW(), m_doc->unitIndex(), tmpPath.length(), true);
-			connect(dia, SIGNAL(updateValues(int, double, double, double, int)), this, SLOT(updateEffectG(int, double, double, double, int)));
-			if (dia->exec())
-			{
-				updateEffectG(dia->effectType, dia->offset, dia->offsetY, dia->gap, dia->rotate);
-				m_doc->changed();
-				if (bxi->isGroup())
-				{
-					m_doc->resizeGroupToContents(bxi);
-					bxi->SetRectFrame();
-					m_doc->view()->DrawNew();
-				}
-			}
-			else
-			{
-				updateEffectG(-1, dia->offset, dia->offsetY, dia->gap, dia->rotate);
-				m_doc->view()->DrawNew();
-			}
-			delete dia;
+			pathItem = m_doc->m_Selection->itemAt(0);
+			selOffs = 1;
 		}
 		else
+			pathItem = m_doc->m_Selection->itemAt(selCount);
+		effectPath = pathItem->PoLine.copy();
+		QTransform mp;
+		mp.rotate(pathItem->rotation());
+		effectPath.map(mp);
+		PageItem* bxi = m_doc->m_Selection->itemAt(selOffs);
+		bxi->asGroupFrame()->adjustXYPosition();
+		originalPathG.append(bxi->PoLine.copy());
+		originalXPosG.append(bxi->xPos());
+		originalYPosG.append(bxi->yPos());
+		originalXPosGi.append(bxi->gXpos);
+		originalYPosGi.append(bxi->gYpos);
+		originalRotG.append(bxi->rotation());
+		originalWidth.append(bxi->width());
+		originalHeight.append(bxi->height());
+		originalWidthG.append(bxi->groupWidth);
+		originalHeightG.append(bxi->groupHeight);
+		patternItemG.append(bxi);
+		QList<PageItem*> bxiL = bxi->getAllChildren();
+		for (int bx = 0; bx < bxiL.count(); ++bx)
 		{
-			patternItem = m_doc->m_Selection->itemAt(0);
-			pathItem = m_doc->m_Selection->itemAt(1);
-			if (pathItem->itemType() != PageItem::PolyLine)
-			{
-				patternItem = m_doc->m_Selection->itemAt(1);
-				pathItem = m_doc->m_Selection->itemAt(0);
-			}
-			effectPath = pathItem->PoLine.copy();
-			QTransform mp;
-			mp.rotate(pathItem->rotation());
-			effectPath.map(mp);
-			originalPath = patternItem->PoLine.copy();
-			originalXPos = patternItem->xPos();
-			originalYPos = patternItem->yPos();
-			originalRot = patternItem->rotation();
-			QPainterPath tmpPath = effectPath.toQPainterPath(false);
-			PathDialog *dia = new PathDialog(m_doc->scMW(), m_doc->unitIndex(), tmpPath.length(), false);
-			connect(dia, SIGNAL(updateValues(int, double, double, double, int)), this, SLOT(updateEffect(int, double, double, double, int)));
-			if (dia->exec())
-			{
-				updateEffect(dia->effectType, dia->offset, dia->offsetY, dia->gap, dia->rotate);
-				patternItem->ContourLine = patternItem->PoLine.copy();
-				m_doc->changed();
-			}
-			else
+			PageItem* cIte = bxiL.at(bx);
+			originalPathG.append(cIte->PoLine.copy());
+			originalXPosG.append(cIte->xPos());
+			originalYPosG.append(cIte->yPos());
+			originalWidth.append(cIte->width());
+			originalHeight.append(cIte->height());
+			originalWidthG.append(cIte->groupWidth);
+			originalHeightG.append(cIte->groupHeight);
+			originalXPosGi.append(cIte->gXpos);
+			originalYPosGi.append(cIte->gYpos);
+			originalRotG.append(cIte->rotation());
+			patternItemG.append(cIte);
+		}
+		QPainterPath tmpPath = effectPath.toQPainterPath(false);
+		PathDialog *dia = new PathDialog(m_doc->scMW(), m_doc->unitIndex(), tmpPath.length(), true);
+		connect(dia, SIGNAL(updateValues(int, double, double, double, int)), this, SLOT(updateEffectG(int, double, double, double, int)));
+		if (dia->exec())
+		{
+			updateEffectG(dia->effectType, dia->offset, dia->offsetY, dia->gap, dia->rotate);
+			m_doc->changed();
+			if (bxi->isGroup())
 			{
-				patternItem->PoLine = originalPath;
-				patternItem->ClipEdited = true;
-				patternItem->FrameType = 3;
-				patternItem->setXYPos(originalXPos, originalYPos);
-				patternItem->setRotation(originalRot);
-				m_doc->adjustItemSize(patternItem);
-				patternItem->OldB2 = patternItem->width();
-				patternItem->OldH2 = patternItem->height();
-				patternItem->updateClip();
+				m_doc->resizeGroupToContents(bxi);
+				bxi->SetRectFrame();
 				m_doc->view()->DrawNew();
 			}
-			delete dia;
 		}
+		else
+		{
+			updateEffectG(-1, dia->offset, dia->offsetY, dia->gap, dia->rotate);
+			m_doc->view()->DrawNew();
+		}
+		delete dia;
+	}
+	else
+	{
+		patternItem = m_doc->m_Selection->itemAt(0);
+		pathItem = m_doc->m_Selection->itemAt(1);
+		if (pathItem->itemType() != PageItem::PolyLine)
+		{
+			patternItem = m_doc->m_Selection->itemAt(1);
+			pathItem = m_doc->m_Selection->itemAt(0);
+		}
+		effectPath = pathItem->PoLine.copy();
+		QTransform mp;
+		mp.rotate(pathItem->rotation());
+		effectPath.map(mp);
+		originalPath = patternItem->PoLine.copy();
+		originalXPos = patternItem->xPos();
+		originalYPos = patternItem->yPos();
+		originalRot = patternItem->rotation();
+		QPainterPath tmpPath = effectPath.toQPainterPath(false);
+		PathDialog *dia = new PathDialog(m_doc->scMW(), m_doc->unitIndex(), tmpPath.length(), false);
+		connect(dia, SIGNAL(updateValues(int, double, double, double, int)), this, SLOT(updateEffect(int, double, double, double, int)));
+		if (dia->exec())
+		{
+			updateEffect(dia->effectType, dia->offset, dia->offsetY, dia->gap, dia->rotate);
+			patternItem->ContourLine = patternItem->PoLine.copy();
+			m_doc->changed();
+		}
+		else
+		{
+			patternItem->PoLine = originalPath;
+			patternItem->ClipEdited = true;
+			patternItem->FrameType = 3;
+			patternItem->setXYPos(originalXPos, originalYPos);
+			patternItem->setRotation(originalRot);
+			m_doc->adjustItemSize(patternItem);
+			patternItem->OldB2 = patternItem->width();
+			patternItem->OldH2 = patternItem->height();
+			patternItem->updateClip();
+			m_doc->view()->DrawNew();
+		}
+		delete dia;
 	}
 	return true;
 }
diff -Napur a/scribus/plugins/tools/lenseffects/lenseffects.cpp f/scribus/plugins/tools/lenseffects/lenseffects.cpp
--- a/scribus/plugins/tools/lenseffects/lenseffects.cpp	2025-01-08 00:06:53.000000000 +0100
+++ f/scribus/plugins/tools/lenseffects/lenseffects.cpp	2025-02-07 13:56:47.992901260 +0100
@@ -24,6 +24,8 @@ for which a new license (GPL+exception)
 *   51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.              *
 ****************************************************************************/
 
+#include <QScopedPointer>
+
 #include "lenseffects.h"
 #include "lensdialog.h"
 #include "scribuscore.h"
@@ -113,53 +115,54 @@ bool LensEffectsPlugin::run(ScribusDoc*
 	ScribusDoc* currDoc = doc;
 	if (currDoc == nullptr)
 		currDoc = ScCore->primaryMainWindow()->doc;
+	if (currDoc->m_Selection->isEmpty())
+		return true;
+
+	using LensDialogScopedPointer = QScopedPointer<LensDialog, QScopedPointerDeleteLater>;
+	LensDialogScopedPointer dia(new LensDialog(currDoc->scMW(), currDoc));
+	if (!dia->exec())
+		return true;
+
+	for (int i = 0; i < dia->origPathItem.count(); i++)
+	{
+		PageItem *currItem = dia->origPageItem[i];
+		if (currItem->itemType() == PageItem::Line)
+			continue;
+		QPainterPath path = dia->origPathItem[i]->path();
+		FPointArray points;
+		points.fromQPainterPath(path);
+		currItem->PoLine = points;
+		currItem->ClipEdited = true;
+		currItem->FrameType = 3;
+		double oW = currItem->width();
+		double oH = currItem->height();
+		currDoc->adjustItemSize(currItem, true);
+		currItem->OldB2 = currItem->width();
+		currItem->OldH2 = currItem->height();
+		if (currItem->isGroup())
+		{
+			currItem->groupWidth = currItem->groupWidth * (currItem->OldB2 / oW);
+			currItem->groupHeight = currItem->groupHeight * (currItem->OldH2 / oH);
+		}
+		currItem->updateClip();
+		if (currItem->isGroup())
+		{
+			currDoc->resizeGroupToContents(currItem);
+			currItem->SetRectFrame();
+		}
+		currItem->ContourLine = currItem->PoLine.copy();
+	}
 	if (currDoc->m_Selection->count() > 0)
 	{
-		LensDialog *dia = new LensDialog(currDoc->scMW(), currDoc);
-		if (dia->exec())
+		PageItem *m_patternItem = currDoc->m_Selection->itemAt(0);
+		if (m_patternItem->isGroup())
 		{
-			for (int a = 0; a < dia->origPathItem.count(); a++)
-			{
-				PageItem *currItem = dia->origPageItem[a];
-				if (currItem->itemType() == PageItem::Line)
-					continue;
-				QPainterPath path = dia->origPathItem[a]->path();
-				FPointArray points;
-				points.fromQPainterPath(path);
-				currItem->PoLine = points;
-				currItem->ClipEdited = true;
-				currItem->FrameType = 3;
-				double oW = currItem->width();
-				double oH = currItem->height();
-				currDoc->adjustItemSize(currItem, true);
-				currItem->OldB2 = currItem->width();
-				currItem->OldH2 = currItem->height();
-				if (currItem->isGroup())
-				{
-					currItem->groupWidth = currItem->groupWidth * (currItem->OldB2 / oW);
-					currItem->groupHeight = currItem->groupHeight * (currItem->OldH2 / oH);
-				}
-				currItem->updateClip();
-				if (currItem->isGroup())
-				{
-					currDoc->resizeGroupToContents(currItem);
-					currItem->SetRectFrame();
-				}
-				currItem->ContourLine = currItem->PoLine.copy();
-			}
-			if (currDoc->m_Selection->count() > 0)
-			{
-				PageItem *m_patternItem = currDoc->m_Selection->itemAt(0);
-				if (m_patternItem->isGroup())
-				{
-					currDoc->resizeGroupToContents(m_patternItem);
-					m_patternItem->SetRectFrame();
-				}
-			}
-			currDoc->changed();
-			currDoc->view()->DrawNew();
+			currDoc->resizeGroupToContents(m_patternItem);
+			m_patternItem->SetRectFrame();
 		}
-		delete dia;
 	}
+	currDoc->changed();
+	currDoc->view()->DrawNew();
+
 	return true;
 }
diff -Napur a/scribus/scimage.cpp f/scribus/scimage.cpp
--- a/scribus/scimage.cpp	2025-01-08 21:31:43.000000000 +0100
+++ f/scribus/scimage.cpp	2025-02-07 13:56:48.393894086 +0100
@@ -1968,7 +1968,7 @@ bool ScImage::getAlpha(const QString& fn
 	imgInfo.clipPath.clear();
 	imgInfo.PDSpathData.clear();
 	imgInfo.layerInfo.clear();
-	QFileInfo fi = QFileInfo(fn);
+	QFileInfo fi(fn);
 	if (!fi.exists())
 		return false;
 	alpha.resize(0);
diff -Napur a/scribus/scribus.cpp f/scribus/scribus.cpp
--- a/scribus/scribus.cpp	2025-01-08 21:31:39.000000000 +0100
+++ f/scribus/scribus.cpp	2025-02-07 13:56:48.342894998 +0100
@@ -64,7 +64,6 @@ for which a new license (GPL+exception)
 #include <QScreen>
 #include <QStyleFactory>
 #include <QTableWidget>
-#include <QTextCodec>
 #include <QTranslator>
 #include <QWindow>
 #include <QWheelEvent>
diff -Napur a/scribus/scribusXml.cpp f/scribus/scribusXml.cpp
--- a/scribus/scribusXml.cpp	2025-01-08 21:31:45.000000000 +0100
+++ f/scribus/scribusXml.cpp	2025-02-07 13:56:48.343894981 +0100
@@ -21,7 +21,6 @@ for which a new license (GPL+exception)
 #include <QDir>
 #include <QFile>
 #include <QRegExp>
-#include <QTextCodec>
 #include <QTextStream>
 #include <QXmlStreamReader>
 #include <QDebug>
diff -Napur a/scribus/scribusapp.cpp f/scribus/scribusapp.cpp
--- a/scribus/scribusapp.cpp	2025-01-08 21:31:41.000000000 +0100
+++ f/scribus/scribusapp.cpp	2025-02-07 13:56:48.343894981 +0100
@@ -33,7 +33,6 @@ for which a new license (GPL+exception)
 #include <QLocale>
 #include <QString>
 #include <QStringList>
-#include <QTextCodec>
 #include <QTextStream>
 #include <QTranslator>
 
diff -Napur a/scribus/scribusdoc.cpp f/scribus/scribusdoc.cpp
--- a/scribus/scribusdoc.cpp	2025-01-08 21:31:39.000000000 +0100
+++ f/scribus/scribusdoc.cpp	2025-02-07 13:56:48.189897736 +0100
@@ -8994,6 +8994,13 @@ void ScribusDoc::itemSelection_SetTracki
 	itemSelection_ApplyCharStyle(newStyle, customSelection, "TRACKING");
 }
 
+void ScribusDoc::itemSelection_SetWordTracking(double kern, Selection* customSelection)
+{
+	ParagraphStyle newStyle;
+	newStyle.charStyle().setWordTracking(kern);
+	itemSelection_ApplyParagraphStyle(newStyle, customSelection);
+}
+
 void ScribusDoc::itemSelection_SetLineSpacingMode(int m, Selection* customSelection)
 {
 	ParagraphStyle newStyle;
diff -Napur a/scribus/scribusdoc.h f/scribus/scribusdoc.h
--- a/scribus/scribusdoc.h	2025-01-08 21:31:39.000000000 +0100
+++ f/scribus/scribusdoc.h	2025-02-07 13:56:48.190897718 +0100
@@ -1153,6 +1153,7 @@ public:
 	void itemSelection_SetCompressionMethod(int cmIndex, Selection* customSelection = nullptr);
 	void itemSelection_SetCompressionQuality(int cqIndex, Selection* customSelection = nullptr);
 	void itemSelection_SetTracking(int us, Selection* customSelection = nullptr);
+	void itemSelection_SetWordTracking(double us, Selection* customSelection = nullptr);
 	void MirrorPolyH(PageItem *currItem);
 	void MirrorPolyV(PageItem *currItem);
 	bool getItem(PageItem **currItem, int nr = -1);
diff -Napur a/scribus/scribusview.cpp f/scribus/scribusview.cpp
--- a/scribus/scribusview.cpp	2025-01-08 21:31:43.000000000 +0100
+++ f/scribus/scribusview.cpp	2025-02-07 13:56:48.343894981 +0100
@@ -46,6 +46,7 @@ for which a new license (GPL+exception)
 #include <QStack>
 #include <QStringList>
 #include <QStyleOptionRubberBand>
+#include <QTextCodec>
 #include <QWidgetAction>
 
 #include <cstdio>
diff -Napur a/scribus/storyloader.cpp f/scribus/storyloader.cpp
--- a/scribus/storyloader.cpp	2025-01-08 21:31:45.000000000 +0100
+++ f/scribus/storyloader.cpp	2025-02-07 13:56:48.343894981 +0100
@@ -20,7 +20,6 @@ for which a new license (GPL+exception)
 #include <QProgressBar>
 #include <QRegExp>
 #include <QtAlgorithms>
-#include <QTextCodec>
 #include <QTextStream>
 
 #include "scconfig.h"
diff -Napur a/scribus/third_party/rtf-qt/AuthorPcdataDestination.cpp f/scribus/third_party/rtf-qt/AuthorPcdataDestination.cpp
diff -Napur a/scribus/third_party/rtf-qt/CategoryPcdataDestination.cpp f/scribus/third_party/rtf-qt/CategoryPcdataDestination.cpp
diff -Napur a/scribus/third_party/rtf-qt/ColorTableDestination.cpp f/scribus/third_party/rtf-qt/ColorTableDestination.cpp
diff -Napur a/scribus/third_party/rtf-qt/CommentPcdataDestination.cpp f/scribus/third_party/rtf-qt/CommentPcdataDestination.cpp
diff -Napur a/scribus/third_party/rtf-qt/CompanyPcdataDestination.cpp f/scribus/third_party/rtf-qt/CompanyPcdataDestination.cpp
diff -Napur a/scribus/third_party/rtf-qt/DocumentCommentPcdataDestination.cpp f/scribus/third_party/rtf-qt/DocumentCommentPcdataDestination.cpp
diff -Napur a/scribus/third_party/rtf-qt/HLinkBasePcdataDestination.cpp f/scribus/third_party/rtf-qt/HLinkBasePcdataDestination.cpp
diff -Napur a/scribus/third_party/rtf-qt/InfoCreatedTimeDestination.cpp f/scribus/third_party/rtf-qt/InfoCreatedTimeDestination.cpp
diff -Napur a/scribus/third_party/rtf-qt/InfoDestination.cpp f/scribus/third_party/rtf-qt/InfoDestination.cpp
diff -Napur a/scribus/third_party/rtf-qt/InfoPrintedTimeDestination.cpp f/scribus/third_party/rtf-qt/InfoPrintedTimeDestination.cpp
diff -Napur a/scribus/third_party/rtf-qt/InfoRevisedTimeDestination.cpp f/scribus/third_party/rtf-qt/InfoRevisedTimeDestination.cpp
diff -Napur a/scribus/third_party/rtf-qt/InfoTimeDestination.cpp f/scribus/third_party/rtf-qt/InfoTimeDestination.cpp
diff -Napur a/scribus/third_party/rtf-qt/KeywordsPcdataDestination.cpp f/scribus/third_party/rtf-qt/KeywordsPcdataDestination.cpp
diff -Napur a/scribus/third_party/rtf-qt/ManagerPcdataDestination.cpp f/scribus/third_party/rtf-qt/ManagerPcdataDestination.cpp
diff -Napur a/scribus/third_party/rtf-qt/OperatorPcdataDestination.cpp f/scribus/third_party/rtf-qt/OperatorPcdataDestination.cpp
diff -Napur a/scribus/third_party/rtf-qt/PcdataDestination.cpp f/scribus/third_party/rtf-qt/PcdataDestination.cpp
diff -Napur a/scribus/third_party/rtf-qt/SubjectPcdataDestination.cpp f/scribus/third_party/rtf-qt/SubjectPcdataDestination.cpp
diff -Napur a/scribus/third_party/rtf-qt/TitlePcdataDestination.cpp f/scribus/third_party/rtf-qt/TitlePcdataDestination.cpp
diff -Napur a/scribus/third_party/rtf-qt/UserPropsDestination.cpp f/scribus/third_party/rtf-qt/UserPropsDestination.cpp
diff -Napur a/scribus/third_party/rtf-qt/sladocumentrtfoutput.cpp f/scribus/third_party/rtf-qt/sladocumentrtfoutput.cpp
diff -Napur a/scribus/third_party/rtf-qt/sladocumentrtfoutput.h f/scribus/third_party/rtf-qt/sladocumentrtfoutput.h
diff -Napur a/scribus/ui/about.cpp f/scribus/ui/about.cpp
diff -Napur a/scribus/ui/curvewidget.cpp f/scribus/ui/curvewidget.cpp
diff -Napur a/scribus/ui/dasheditor.cpp f/scribus/ui/dasheditor.cpp
diff -Napur a/scribus/ui/outputpreview_pdf.ui f/scribus/ui/outputpreview_pdf.ui
diff -Napur a/scribus/ui/outputpreview_ps.ui f/scribus/ui/outputpreview_ps.ui
diff -Napur a/scribus/ui/picstatus.cpp f/scribus/ui/picstatus.cpp
diff -Napur a/scribus/ui/prefs_hyphenator.cpp f/scribus/ui/prefs_hyphenator.cpp
diff -Napur a/scribus/ui/printpreviewbase.ui f/scribus/ui/printpreviewbase.ui
diff -Napur a/scribus/ui/propertiespalette_xyz.cpp f/scribus/ui/propertiespalette_xyz.cpp
diff -Napur a/scribus/ui/proptree.cpp f/scribus/ui/proptree.cpp
diff -Napur a/scribus/ui/sctreewidget.cpp f/scribus/ui/sctreewidget.cpp
diff -Napur a/scribus/ui/storyeditor.cpp f/scribus/ui/storyeditor.cpp
diff -Napur a/scribus/ui/tabpdfoptions.cpp f/scribus/ui/tabpdfoptions.cpp
diff -Napur a/scribus/ui/tabpdfoptions.h f/scribus/ui/tabpdfoptions.h
diff -Napur a/scribus/util_color.cpp f/scribus/util_color.cpp
--- a/scribus/util_color.cpp	2025-01-08 21:31:39.000000000 +0100
+++ f/scribus/util_color.cpp	2025-02-07 13:56:48.393894086 +0100
@@ -634,7 +634,7 @@ bool importColorsFromFile(const QString&
 		return false;
 	int oldCount = EditColors.count();
 
-	QFileInfo fi = QFileInfo(fileName);
+	QFileInfo fi(fileName);
 	QString ext = fi.suffix().toLower();
 	if (extensionIndicatesEPSorPS(ext))
 	{
diff -Napur a/scribus/util_math.cpp f/scribus/util_math.cpp
--- a/scribus/util_math.cpp	2025-01-08 21:31:45.000000000 +0100
+++ f/scribus/util_math.cpp	2025-02-07 13:56:48.344894963 +0100
@@ -105,7 +105,7 @@ QPainterPath regularPolygonPath(double w
 			if (i % 2 != 0)
 			{
 				// outer control point
-				QLineF oline = QLineF(cornerPoints[i + 1], cornerPoints[i - 1]);
+				QLineF oline(cornerPoints[i + 1], cornerPoints[i - 1]);
 				mxc1 = oline.pointAt(factor3).x();
 				myc1 = oline.pointAt(factor3).y();
 				// inner control point
@@ -116,7 +116,7 @@ QPainterPath regularPolygonPath(double w
 			else
 			{
 				// outer control point
-				QLineF oline = QLineF(cornerPoints[i], cornerPoints[i + 2]);
+				QLineF oline(cornerPoints[i], cornerPoints[i + 2]);
 				mxc1 = oline.pointAt(factor3).x();
 				myc1 = oline.pointAt(factor3).y();
 				// inner control point
@@ -126,7 +126,7 @@ QPainterPath regularPolygonPath(double w
 			}
 		}
 		// outer control point
-		QLineF oline = QLineF(cornerPoints[cornerPoints.count() - 2], cornerPoints[0]);
+		QLineF oline(cornerPoints[cornerPoints.count() - 2], cornerPoints[0]);
 		mxc1 = oline.pointAt(factor3).x();
 		myc1 = oline.pointAt(factor3).y();
 		// inner control point
diff -Napur a/scribus.lsm f/scribus.lsm
diff -Napur a/win32/msvc2015/scribus-main/Scribus.rc f/win32/msvc2015/scribus-main/Scribus.rc
diff -Napur a/win32/msvc2015/win-config.h f/win32/msvc2015/win-config.h
diff -Napur a/win32/msvc2017/scribus-main/Scribus.rc f/win32/msvc2017/scribus-main/Scribus.rc
diff -Napur a/win32/msvc2017/win-config.h f/win32/msvc2017/win-config.h
diff -Napur a/win32/msvc2019/scribus-main/Scribus.rc f/win32/msvc2019/scribus-main/Scribus.rc
diff -Napur a/win32/msvc2019/win-config.h f/win32/msvc2019/win-config.h
diff -Napur a/win32/msvc2022/scribus-main/Scribus.rc f/win32/msvc2022/scribus-main/Scribus.rc
diff -Napur a/win32/msvc2022/win-config.h f/win32/msvc2022/win-config.h
