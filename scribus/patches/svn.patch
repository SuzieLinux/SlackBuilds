diff -Naupr scribus-1.6.2/CMakeLists.txt scribus16x/CMakeLists.txt
--- scribus-1.6.2/CMakeLists.txt	2024-06-15 16:21:21.000000000 +0200
+++ scribus16x/CMakeLists.txt	2025-01-04 10:59:16.177171060 +0100
@@ -9,7 +9,12 @@
 #Require 3.14 for new Fontconfig module
 
 cmake_minimum_required(VERSION 3.14.0 FATAL_ERROR)
+
 cmake_policy(SET CMP0048 NEW)
+if (POLICY CMP0177)
+	cmake_policy(SET CMP0177 NEW)
+endif()
+
 message(STATUS "CMake Version: ${CMAKE_VERSION}")
 if (WANT_PCH)
 	if(${CMAKE_VERSION} VERSION_LESS "3.16.0")
@@ -28,8 +33,8 @@ endif()
 #where VERSION_SUFFIX is of the form "", "svn" or "Nsvn" (N being the minor patch level)
 set (VERSION_MAJOR "1")
 set (VERSION_MINOR "6")
-set (VERSION_PATCH "2")
-set (VERSION_SUFFIX "")
+set (VERSION_PATCH "3")
+set (VERSION_SUFFIX "svn")
 set (VERSION ${VERSION_MAJOR})
 if (VERSION_MINOR GREATER -1)
 	set (VERSION ${VERSION}.${VERSION_MINOR})
diff -Naupr scribus-1.6.2/CMakeLists_Dependencies.cmake scribus16x/CMakeLists_Dependencies.cmake
--- scribus-1.6.2/CMakeLists_Dependencies.cmake	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/CMakeLists_Dependencies.cmake	2025-01-04 10:59:12.669244236 +0100
@@ -307,6 +307,9 @@ endif()
 #<<Boost for 2Geom Tools
 option(WITH_BOOST "Enable support for Boost based enhancements" ON)
 if (WITH_BOOST)
+	if (POLICY CMP0167)
+		cmake_policy(SET CMP0167 NEW)
+	endif()
 	find_package(Boost)
 	if (Boost_FOUND)
 		message("Boost Library Found OK")
diff -Naupr scribus-1.6.2/COPYING scribus16x/COPYING
--- scribus-1.6.2/COPYING	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/COPYING	2025-01-04 10:59:16.177171060 +0100
@@ -1,5 +1,5 @@
 Scribus Copyright
-Copyright 2001–2024 Franz Schmid and rest of the members of the Scribus Team.
+Copyright 2001–2025 Franz Schmid and rest of the members of the Scribus Team.
 
 The "Scribus Team" is informally defined as the following people: Franz Schmid, Peter Linnell, Craig Bradney, Jean Ghali, Hermann Kraus, Riku Leino, Oleksandr Moskalenko, Christoph Schäfer, Petr Vaněk, Andreas Vox, and Jain Basil.
 
diff -Naupr scribus-1.6.2/ChangeLog scribus16x/ChangeLog
--- scribus-1.6.2/ChangeLog	2024-06-15 16:21:21.000000000 +0200
+++ scribus16x/ChangeLog	2025-01-04 10:59:16.176171081 +0100
@@ -1,5 +1,47 @@
+Scribus - 1.6.3 (Released 2024-xx-xx)
+=========================================
+https://bugs.scribus.net/changelog_page.php?version_id=124
+
+0002064: [Import / Export]  Importing of cmyk tiffs with 16bit depth does not work
+0017333: [Color Management]  The CMYK image shows all wrong when added into Image Frame (jghali)
+0010166: [Usability]  Styles: Enter key in Name field opens New button drop-down menu (cbradney)
+0017354: [Styles]  [odt2im] ' fo:language' attribute of imported styles is not kept (cbradney)
+0014579: [Story Editor / Text Frames]  Characters with unicode code 65536+ (0x10000+) (cbradney)
+0017286: [Story Editor / Text Frames]  Text selection highlight has render issues (nitramr)
+0017347: [General]  Scribus crashes when saving document afer minor changes in a text block (jghali)
+0017350: [Canvas]  Auto guide grid messed up when changing document measurement unit (jghali)
+0017339: [General]  Scribus never read preferences of guide color and baseline color (nitramr)
+0017260: [Translation]  Portuguese language: keep only pt_PT and pt_BR, remove pt (cbradney)
+0017261: [General]  Update German Dictionary (cbradney)
+0017308: [Build System]  After poppler-update to 24.11 compilation stalls on importpdf (using revision 26402 ) (jghali)
+0017309: [User Interface]  shortcut for itemAttributes does not work (cbradney)
+0014770: [Undo/Redo]  Scribus crashes when undoing last Paragraph deletion in Story Editor (cbradney)
+0016895: [User Interface]  item > attribute is no more (cbradney)
+0016909: [Graphics / Image Frames]  SCRIBUS file manager cannot locate my external flash drives to get images from (cbradney)
+0016167: [Undo/Redo]  delete frame with bookmark: undo restores the frame but not the bookmark (cbradney)
+0017302: [Scripter]  Python functions for unit conversion (cbradney)
+0017272: [General]  Crash when opening PDF and selecting import text as text (jghali)
+0017287: [Import / Export]  Special characters are not converted properly when pasting tables from Calc (jghali)
+0017288: [Graphics / Image Frames]  "Update Image" does not work when the image is not available. (jghali)
+0017291: [Build System]  1.6.2 fails to build against poppler >= 24.10.0 (jghali)
+0017294: [Scripter]  Incorrect page size used by ImageExport() -> save() (jghali)
+0017296: [Scripter]  Add script method getBaseLine() to complement setBaseLine() (jghali)
+0017270: [PDF]  Corrupt PDF generated (jghali)
+0017237: [Translation]  Outdated trolltech url (jghali)
+0017238: [Translation]  Non https urls in language files (jghali)
+0012892: [Usability]  Color Management: Color Menu width increases with each use of Color Management feature (nitramr)
+0017251: [Scripter]  Scripter's ImageExporter ignores actual quality setting (jghali)
+0017255: [Undo/Redo]  Properties > Shape: The fill rule cannot be undone (jghali)
+0017256: [General]  In 1.6.2, the "fill rule" selection does not change when selecting a different item (jghali)
+0017258: [User Interface]  In menus (e.g. preferences or document setup) selecting empty field next to an entry doesn't activate dialog (cbradney)
+0017264: [User Interface]  ScrSpinBox: Alt key modifier doesn't work on Linux (nitramr)
+0017267: [OS-MacOSX]  New MacOS app and document icons (nitramr)
+0016804: [Scripter]  Improved autotypo script for french typographic rules (JLuc)
+
 Scribus - 1.6.2 (Released 2024-06-15)
 =========================================
+https://bugs.scribus.net/changelog_page.php?version_id=121
+
 0017167: [Typography] Non-breaking spaces not respected before punctuation mark (jghali)
 0017231: [Scripter] Memory leaks when parsing script functions arguments (jghali)
 0017229: [3rd Party] scribus fails to compile with boost 1.85.0 (jghali)
diff -Naupr scribus-1.6.2/OSX-package/inputs/Info.plist scribus16x/OSX-package/inputs/Info.plist
diff -Naupr scribus-1.6.2/OSX-package/inputs/Scribus.pkg-Info.plist scribus16x/OSX-package/inputs/Scribus.pkg-Info.plist
diff -Naupr scribus-1.6.2/Scribus.app/Contents/Info.plist scribus16x/Scribus.app/Contents/Info.plist
diff -Naupr scribus-1.6.2/Scribus.app/Contents/Resources/Scribus-doc.icns scribus16x/Scribus.app/Contents/Resources/Scribus-doc.icns
\ Manca newline alla fine del file
diff -Naupr scribus-1.6.2/Scribus.app/Contents/Resources/Scribus.icns scribus16x/Scribus.app/Contents/Resources/Scribus.icns
\ Manca newline alla fine del file
diff -Naupr scribus-1.6.2/cmake/modules/Findpoppler.cmake scribus16x/cmake/modules/Findpoppler.cmake
--- scribus-1.6.2/cmake/modules/Findpoppler.cmake	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/cmake/modules/Findpoppler.cmake	2025-01-04 10:59:16.534163614 +0100
@@ -1,8 +1,8 @@
 #include(FindPkgConfig)
 find_package(PkgConfig QUIET)
-pkg_search_module(poppler libpoppler>=0.62.0 poppler>=0.62.0)
+pkg_search_module(poppler libpoppler>=0.75.0 poppler>=0.75.0)
 if (poppler_FOUND)
-	pkg_search_module(poppler_cpp REQUIRED libpoppler-cpp>=0.62.0 poppler-cpp>=0.62.0)
+	pkg_search_module(poppler_cpp REQUIRED libpoppler-cpp>=0.75.0 poppler-cpp>=0.75.0)
 endif(poppler_FOUND)
  
 find_path(poppler_INCLUDE_DIR
diff -Naupr scribus-1.6.2/config.h.cmake scribus16x/config.h.cmake
--- scribus-1.6.2/config.h.cmake	2024-06-15 16:21:25.000000000 +0200
+++ scribus16x/config.h.cmake	2025-01-04 10:59:17.697139360 +0100
@@ -9,7 +9,7 @@
 #error "Include <scconfig.h> rather than using <config.h> directly"
 #endif
 
-#cmakedefine VERSION "1.6.2"
+#cmakedefine VERSION "1.6.3.svn"
 
 #cmakedefine BUILD_MAC_BUNDLE
 #cmakedefine DLL_USE_NATIVE_API 1
diff -Naupr scribus-1.6.2/resources/dicts/README_hyph_de_AT.txt scribus16x/resources/dicts/README_hyph_de_AT.txt
diff -Naupr scribus-1.6.2/resources/dicts/README_hyph_de_CH.txt scribus16x/resources/dicts/README_hyph_de_CH.txt
diff -Naupr scribus-1.6.2/resources/dicts/README_hyph_de_DE.txt scribus16x/resources/dicts/README_hyph_de_DE.txt
diff -Naupr scribus-1.6.2/resources/dicts/hyph_de.dic scribus16x/resources/dicts/hyph_de.dic
diff -Naupr scribus-1.6.2/resources/dicts/hyph_de_AT.dic scribus16x/resources/dicts/hyph_de_AT.dic
diff -Naupr scribus-1.6.2/resources/dicts/hyph_de_CH.dic scribus16x/resources/dicts/hyph_de_CH.dic
diff -Naupr scribus-1.6.2/resources/dicts/hyph_de_DE.dic scribus16x/resources/dicts/hyph_de_DE.dic
diff -Naupr scribus-1.6.2/resources/translations/scribus.af.ts scribus16x/resources/translations/scribus.af.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.ar.ts scribus16x/resources/translations/scribus.ar.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.az.ts scribus16x/resources/translations/scribus.az.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.be.ts scribus16x/resources/translations/scribus.be.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.bg.ts scribus16x/resources/translations/scribus.bg.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.bn_IN.ts scribus16x/resources/translations/scribus.bn_IN.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.br.ts scribus16x/resources/translations/scribus.br.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.ca.ts scribus16x/resources/translations/scribus.ca.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.cs_CZ.ts scribus16x/resources/translations/scribus.cs_CZ.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.cy.ts scribus16x/resources/translations/scribus.cy.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.da_DK.ts scribus16x/resources/translations/scribus.da_DK.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.de.ts scribus16x/resources/translations/scribus.de.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.de_1901.ts scribus16x/resources/translations/scribus.de_1901.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.de_CH.ts scribus16x/resources/translations/scribus.de_CH.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.el.ts scribus16x/resources/translations/scribus.el.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.en_AU.ts scribus16x/resources/translations/scribus.en_AU.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.en_GB.ts scribus16x/resources/translations/scribus.en_GB.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.en_US.ts scribus16x/resources/translations/scribus.en_US.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.eo.ts scribus16x/resources/translations/scribus.eo.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.es_AR.ts scribus16x/resources/translations/scribus.es_AR.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.es_ES.ts scribus16x/resources/translations/scribus.es_ES.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.et.ts scribus16x/resources/translations/scribus.et.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.eu.ts scribus16x/resources/translations/scribus.eu.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.fa_IR.ts scribus16x/resources/translations/scribus.fa_IR.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.fi.ts scribus16x/resources/translations/scribus.fi.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.fr.ts scribus16x/resources/translations/scribus.fr.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.gl.ts scribus16x/resources/translations/scribus.gl.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.he_IL.ts scribus16x/resources/translations/scribus.he_IL.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.hi_IN.ts scribus16x/resources/translations/scribus.hi_IN.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.hr_HR.ts scribus16x/resources/translations/scribus.hr_HR.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.hu.ts scribus16x/resources/translations/scribus.hu.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.id.ts scribus16x/resources/translations/scribus.id.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.it.ts scribus16x/resources/translations/scribus.it.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.ja.ts scribus16x/resources/translations/scribus.ja.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.kab.ts scribus16x/resources/translations/scribus.kab.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.kn_IN.ts scribus16x/resources/translations/scribus.kn_IN.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.ko.ts scribus16x/resources/translations/scribus.ko.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.lb.ts scribus16x/resources/translations/scribus.lb.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.lt_LT.ts scribus16x/resources/translations/scribus.lt_LT.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.ml.ts scribus16x/resources/translations/scribus.ml.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.mn_MN.ts scribus16x/resources/translations/scribus.mn_MN.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.ms_MY.ts scribus16x/resources/translations/scribus.ms_MY.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.nb_NO.ts scribus16x/resources/translations/scribus.nb_NO.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.nl.ts scribus16x/resources/translations/scribus.nl.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.nn_NO.ts scribus16x/resources/translations/scribus.nn_NO.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.oc.ts scribus16x/resources/translations/scribus.oc.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.pl_PL.ts scribus16x/resources/translations/scribus.pl_PL.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.pms.ts scribus16x/resources/translations/scribus.pms.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.pt.ts scribus16x/resources/translations/scribus.pt.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.pt_BR.ts scribus16x/resources/translations/scribus.pt_BR.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.pt_PT.ts scribus16x/resources/translations/scribus.pt_PT.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.ro.ts scribus16x/resources/translations/scribus.ro.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.ru.ts scribus16x/resources/translations/scribus.ru.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.sa.ts scribus16x/resources/translations/scribus.sa.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.si.ts scribus16x/resources/translations/scribus.si.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.sk_SK.ts scribus16x/resources/translations/scribus.sk_SK.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.sl.ts scribus16x/resources/translations/scribus.sl.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.so.ts scribus16x/resources/translations/scribus.so.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.sq.ts scribus16x/resources/translations/scribus.sq.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.sr.ts scribus16x/resources/translations/scribus.sr.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.sv.ts scribus16x/resources/translations/scribus.sv.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.ta.ts scribus16x/resources/translations/scribus.ta.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.te.ts scribus16x/resources/translations/scribus.te.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.th_TH.ts scribus16x/resources/translations/scribus.th_TH.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.tr.ts scribus16x/resources/translations/scribus.tr.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.uk.ts scribus16x/resources/translations/scribus.uk.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.untranslated.ts scribus16x/resources/translations/scribus.untranslated.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.zh_CN.ts scribus16x/resources/translations/scribus.zh_CN.ts
diff -Naupr scribus-1.6.2/resources/translations/scribus.zh_TW.ts scribus16x/resources/translations/scribus.zh_TW.ts
diff -Naupr scribus-1.6.2/scribus/actionmanager.cpp scribus16x/scribus/actionmanager.cpp
--- scribus-1.6.2/scribus/actionmanager.cpp	2024-06-15 16:22:34.000000000 +0200
+++ scribus16x/scribus/actionmanager.cpp	2025-01-04 10:59:08.781325361 +0100
@@ -19,9 +19,12 @@ for which a new license (GPL+exception)
 *                                                                         *
 ***************************************************************************/
 
+#include <array>
+
 #include "actionmanager.h"
-#include "appmodes.h"
 
+#include "appmodes.h"
+#include "iconmanager.h"
 #include "scribuscore.h"
 #include "scribusdoc.h"
 #include "scribusview.h"
@@ -29,7 +32,7 @@ for which a new license (GPL+exception)
 #include "text/storytext.h"
 #include "undomanager.h"
 #include "urllauncher.h"
-#include "iconmanager.h"
+#include "util_keyboard.h"
 
 QMap<QString, QKeySequence> ActionManager::defKeys;
 QVector< QPair<QString, QStringList> > ActionManager::defMenuNames;
@@ -296,12 +299,11 @@ void ActionManager::initStyleMenuActions
 	scrActions->insert(name, new ScrAction(ScrAction::DataInt, QString(), QString(), "", defaultKey(name), scrActionGroups->value("fontSize"), -1));
 	connect( (*scrActions)["fontSizeOther"], SIGNAL(triggeredData(int)), mainWindow, SLOT(setItemFontSize(int)));
 
-	int font_sizes[] = {7, 9, 10, 11, 12, 14, 18, 24, 36, 48, 60, 72};
-	size_t f_size = sizeof(font_sizes) / sizeof(*font_sizes);
-	for (uint s = 0; s < f_size; ++s)
+	std::array<int, 12> font_sizes = { 7, 9, 10, 11, 12, 14, 18, 24, 36, 48, 60, 72 };
+	for (auto fontSize : font_sizes)
 	{
-		QString fontSizeName = QString("fontSize%1").arg(font_sizes[s]);
-		scrActions->insert(fontSizeName, new ScrAction(ScrAction::DataInt, QString(), QString(), "", defaultKey(name), scrActionGroups->value("fontSize"), font_sizes[s]));
+		QString fontSizeName = QString("fontSize%1").arg(fontSize);
+		scrActions->insert(fontSizeName, new ScrAction(ScrAction::DataInt, QString(), QString(), "", defaultKey(name), scrActionGroups->value("fontSize"), fontSize));
 		(*scrActions)[fontSizeName]->setToggleAction(true);
 		connect( (*scrActions)[fontSizeName], SIGNAL(triggeredData(int)), mainWindow, SLOT(setItemFontSize(int)));
 	}
@@ -1008,15 +1010,15 @@ void ActionManager::initHelpMenuActions(
 	name = "helpManual";
 	scrActions->insert(name, new ScrAction("16/help-browser.png", QString(), "", defaultKey(name), mainWindow));
 	name = "helpOnlineWWW";
-	scrActions->insert(name, new ScrAction(ScrAction::DataQString, QString(), QString(), "", defaultKey(name), mainWindow, "http://www.scribus.net"));
+	scrActions->insert(name, new ScrAction(ScrAction::DataQString, QString(), QString(), "", defaultKey(name), mainWindow, "https://www.scribus.net"));
 	name = "helpOnlineDocs";
-	scrActions->insert(name, new ScrAction(ScrAction::DataQString, QString(), QString(), "", defaultKey(name), mainWindow, "http://docs.scribus.net"));
+	scrActions->insert(name, new ScrAction(ScrAction::DataQString, QString(), QString(), "", defaultKey(name), mainWindow, "https://docs.scribus.net"));
 	name = "helpOnlineWiki";
-	scrActions->insert(name, new ScrAction(ScrAction::DataQString, QString(), QString(), "", defaultKey(name), mainWindow, "http://wiki.scribus.net"));
+	scrActions->insert(name, new ScrAction(ScrAction::DataQString, QString(), QString(), "", defaultKey(name), mainWindow, "https://wiki.scribus.net"));
 	name = "helpOnlineTutorial1";
 	scrActions->insert(name, new ScrAction(ScrAction::DataQString, QString(), QString(), "", defaultKey(name), mainWindow, ""));
 	name = "helpChat";
-	scrActions->insert(name, new ScrAction(ScrAction::DataQString, QString(), QString(), "", defaultKey(name), mainWindow, "http://web.libera.chat/?channels=scribus"));
+	scrActions->insert(name, new ScrAction(ScrAction::DataQString, QString(), QString(), "", defaultKey(name), mainWindow, "https://web.libera.chat/?channels=scribus"));
 	name = "helpCheckUpdates";
 	scrActions->insert(name, new ScrAction("", defaultKey(name), mainWindow));
 
@@ -1542,12 +1544,11 @@ void ActionManager::languageChange()
 	(*scrActions)["editMasterPages"]->setTexts( tr("&Master Pages..."));
 	(*scrActions)["editJavascripts"]->setTexts( tr("&JavaScripts..."));
 
-	int font_sizes[] = {7, 9, 10, 11, 12, 14, 18, 24, 36, 48, 60, 72};
-	size_t f_size = sizeof(font_sizes) / sizeof(*font_sizes);
-	for (uint s = 0; s < f_size; ++s)
+	std::array<int, 12> font_sizes = { 7, 9, 10, 11, 12, 14, 18, 24, 36, 48, 60, 72 };
+	for (auto fontSize : font_sizes)
 	{
-		QString fontSizeName = QString("fontSize%1").arg(font_sizes[s]);
-		(*scrActions)[fontSizeName]->setTexts( tr("%1 pt").arg(font_sizes[s]));
+		QString fontSizeName = QString("fontSize%1").arg(fontSize);
+		(*scrActions)[fontSizeName]->setTexts( tr("%1 pt").arg(fontSize));
 	}
 	(*scrActions)["fontSizeOther"]->setTexts( tr("&Other..."));
 	(*scrActions)["alignLeft"]->setTexts( tr("&Left"));
@@ -1907,53 +1908,53 @@ void ActionManager::createDefaultShortcu
 	defKeys.clear();
 
 	defKeys.insert("fileNew", QKeySequence::New);
-	defKeys.insert("fileNewFromTemplate", Qt::CTRL+Qt::ALT+Qt::Key_N);
+	defKeys.insert("fileNewFromTemplate", Qt::CTRL + Qt::ALT + Qt::Key_N);
 	defKeys.insert("fileOpen", QKeySequence::Open);
 	defKeys.insert("fileClose", QKeySequence::Close);
 	defKeys.insert("fileSave", QKeySequence::Save);
-	defKeys.insert("fileSaveAs", Qt::CTRL+Qt::SHIFT+Qt::Key_S);
-	defKeys.insert("fileImportText", Qt::CTRL+Qt::Key_I);
-	defKeys.insert("fileImportImage", Qt::CTRL+Qt::Key_I);
+	defKeys.insert("fileSaveAs", Qt::CTRL + Qt::SHIFT + Qt::Key_S);
+	defKeys.insert("fileImportText", Qt::CTRL + Qt::Key_I);
+	defKeys.insert("fileImportImage", Qt::CTRL + Qt::Key_I);
 	defKeys.insert("filePrint", QKeySequence::Print);
-	defKeys.insert("fileExportAsPDF", Qt::CTRL+Qt::SHIFT+Qt::Key_P);
-	defKeys.insert("fileQuit", Qt::CTRL+Qt::Key_Q);
+	defKeys.insert("fileExportAsPDF", Qt::CTRL + Qt::SHIFT + Qt::Key_P);
+	defKeys.insert("fileQuit", Qt::CTRL + Qt::Key_Q);
 	//Edit Menu
 	defKeys.insert("editUndoAction", QKeySequence::Undo);
 	defKeys.insert("editRedoAction", QKeySequence::Redo);
 	defKeys.insert("editCut", QKeySequence::Cut);
 	defKeys.insert("editCopy", QKeySequence::Copy);
 	defKeys.insert("editPaste", QKeySequence::Paste);
-	defKeys.insert("editClearContents", Qt::CTRL+Qt::SHIFT+Qt::Key_Delete);
-	defKeys.insert("editCopyContents", Qt::CTRL+Qt::SHIFT+Qt::Key_C);
-	defKeys.insert("editPasteContents", Qt::CTRL+Qt::SHIFT+Qt::Key_V);
-	defKeys.insert("editPasteContentsAbs", Qt::CTRL+Qt::ALT+Qt::SHIFT+Qt::Key_V);
-	defKeys.insert("editSelectAll", Qt::CTRL+Qt::Key_A);
-	defKeys.insert("editSelectAllOnLayer", Qt::CTRL+Qt::ALT+Qt::Key_A);
-	defKeys.insert("editDeselectAll", Qt::CTRL+Qt::SHIFT+Qt::Key_A);
-	defKeys.insert("editSearchReplace", Qt::CTRL+Qt::Key_F);
+	defKeys.insert("editClearContents", Qt::CTRL + Qt::SHIFT + Qt::Key_Delete);
+	defKeys.insert("editCopyContents", Qt::CTRL + Qt::SHIFT + Qt::Key_C);
+	defKeys.insert("editPasteContents", Qt::CTRL + Qt::SHIFT + Qt::Key_V);
+	defKeys.insert("editPasteContentsAbs", Qt::CTRL + Qt::ALT + Qt::SHIFT + Qt::Key_V);
+	defKeys.insert("editSelectAll", Qt::CTRL + Qt::Key_A);
+	defKeys.insert("editSelectAllOnLayer", Qt::CTRL + Qt::ALT + Qt::Key_A);
+	defKeys.insert("editDeselectAll", Qt::CTRL + Qt::SHIFT + Qt::Key_A);
+	defKeys.insert("editSearchReplace", Qt::CTRL + Qt::Key_F);
 	defKeys.insert("editStyles", QKeySequence(Qt::Key_F4));
-	defKeys.insert("styleImageEffects", Qt::CTRL+Qt::Key_E);
+	defKeys.insert("styleImageEffects", Qt::CTRL + Qt::Key_E);
 
 	//Item Menu
-	defKeys.insert("itemDuplicate", Qt::CTRL+Qt::Key_D);
-	defKeys.insert("itemMulDuplicate", Qt::CTRL+Qt::SHIFT+Qt::Key_D);
+	defKeys.insert("itemDuplicate", Qt::CTRL + Qt::Key_D);
+	defKeys.insert("itemMulDuplicate", Qt::CTRL + Qt::SHIFT + Qt::Key_D);
 	defKeys.insert("itemDelete", QKeySequence::Delete);
-	defKeys.insert("itemGroup", Qt::CTRL+Qt::Key_G);
-	defKeys.insert("itemUngroup", Qt::CTRL+Qt::SHIFT+Qt::Key_G);
-	defKeys.insert("itemLock", Qt::CTRL+Qt::Key_L);
-	defKeys.insert("itemLockSize", Qt::CTRL+Qt::SHIFT+Qt::Key_L);
+	defKeys.insert("itemGroup", Qt::CTRL + Qt::Key_G);
+	defKeys.insert("itemUngroup", Qt::CTRL + Qt::SHIFT + Qt::Key_G);
+	defKeys.insert("itemLock", Qt::CTRL + Qt::Key_L);
+	defKeys.insert("itemLockSize", Qt::CTRL + Qt::SHIFT + Qt::Key_L);
 	defKeys.insert("itemLowerToBottom", Qt::Key_End);
 	defKeys.insert("itemRaiseToTop", Qt::Key_Home);
-	defKeys.insert("itemLower", Qt::CTRL+Qt::Key_End);
-	defKeys.insert("itemRaise", Qt::CTRL+Qt::Key_Home);
+	defKeys.insert("itemLower", Qt::CTRL + Qt::Key_End);
+	defKeys.insert("itemRaise", Qt::CTRL + Qt::Key_Home);
 
 	//Insert Menu
 	//Page menu
 	//View Menu
-	defKeys.insert("viewFitInWindow", Qt::CTRL+Qt::Key_0);
-	defKeys.insert("viewFit100", Qt::CTRL+Qt::Key_1);
-	defKeys.insert("viewPreviewMode", Qt::CTRL+Qt::ALT+Qt::Key_P);
-	defKeys.insert("viewShowRulers", Qt::CTRL+Qt::SHIFT+Qt::Key_R);
+	defKeys.insert("viewFitInWindow", Qt::CTRL + Qt::Key_0);
+	defKeys.insert("viewFit100", Qt::CTRL + Qt::Key_1);
+	defKeys.insert("viewPreviewMode", Qt::CTRL + Qt::ALT + Qt::Key_P);
+	defKeys.insert("viewShowRulers", Qt::CTRL + Qt::SHIFT + Qt::Key_R);
 	defKeys.insert("viewShowContextMenu", Qt::Key_Menu); //Context menu key on Windows. Do we have one to use on Linux/OSX? Super_L ?
 
 	//Tool menu
@@ -1975,10 +1976,10 @@ void ActionManager::createDefaultShortcu
 	defKeys.insert("toolsInsertRenderFrame", Qt::Key_D); //TODO: First free key. Select a meaningful
 	defKeys.insert("toolsRotate", Qt::Key_R);
 	defKeys.insert("toolsZoom", Qt::Key_Z);
-	defKeys.insert("toolsZoomIn", Qt::CTRL+Qt::Key_Plus);
-	defKeys.insert("toolsZoomOut", Qt::CTRL+Qt::Key_Minus);
+	defKeys.insert("toolsZoomIn", Qt::CTRL + Qt::Key_Plus);
+	defKeys.insert("toolsZoomOut", Qt::CTRL + Qt::Key_Minus);
 	defKeys.insert("toolsEditContents", Qt::Key_E);
-	defKeys.insert("toolsEditWithStoryEditor", Qt::CTRL+Qt::Key_T);
+	defKeys.insert("toolsEditWithStoryEditor", Qt::CTRL + Qt::Key_T);
 	defKeys.insert("toolsLinkTextFrame", Qt::Key_N);
 	defKeys.insert("toolsUnlinkTextFrame", Qt::Key_U);
 	defKeys.insert("toolsEyeDropper", Qt::Key_Y);
@@ -1987,29 +1988,29 @@ void ActionManager::createDefaultShortcu
 	//Extras Menu
 	//Windows Menu
 	//Help Menu
-	defKeys.insert("helpActionSearch", Qt::CTRL+Qt::Key_Slash);
+	defKeys.insert("helpActionSearch", Qt::CTRL + Qt::Key_Slash);
 	defKeys.insert("helpManual", Qt::Key_F1);
 
 	//GUI and specials
 	defKeys.insert("specialToggleAllPalettes", Qt::Key_F12);
 	defKeys.insert("specialToggleAllGuides", Qt::Key_F11);
-	defKeys.insert("specialUnicodeSequenceBegin", Qt::CTRL+Qt::SHIFT+Qt::Key_U);
+	defKeys.insert("specialUnicodeSequenceBegin", Qt::CTRL + Qt::SHIFT + Qt::Key_U);
 
 	//typography
-	defKeys.insert("unicodeFrameBreak", Qt::CTRL+Qt::Key_Return);
-	defKeys.insert("unicodeColumnBreak", Qt::CTRL+Qt::SHIFT+Qt::Key_Return);
+	defKeys.insert("unicodeFrameBreak", Qt::CTRL + Qt::Key_Return);
+	defKeys.insert("unicodeColumnBreak", Qt::CTRL + Qt::SHIFT + Qt::Key_Return);
 
-	defKeys.insert("unicodeSoftHyphen", Qt::CTRL+Qt::SHIFT+Qt::Key_Minus);
-	defKeys.insert("unicodeNonBreakingHyphen", Qt::CTRL+Qt::ALT+Qt::Key_Minus);
-	defKeys.insert("unicodeNonBreakingSpace", Qt::CTRL+Qt::Key_Space);
-	defKeys.insert("unicodeNarrowNoBreakSpace", Qt::CTRL+Qt::ALT+Qt::Key_Space);
-	defKeys.insert("unicodePageNumber", Qt::CTRL+Qt::SHIFT+Qt::ALT+Qt::Key_P);
-	defKeys.insert("unicodeNewLine", Qt::SHIFT+Qt::Key_Return);
+	defKeys.insert("unicodeSoftHyphen", Qt::CTRL + Qt::SHIFT + Qt::Key_Minus);
+	defKeys.insert("unicodeNonBreakingHyphen", Qt::CTRL + Qt::ALT + Qt::Key_Minus);
+	defKeys.insert("unicodeNonBreakingSpace", Qt::CTRL + Qt::Key_Space);
+	defKeys.insert("unicodeNarrowNoBreakSpace", Qt::CTRL + Qt::ALT + Qt::Key_Space);
+	defKeys.insert("unicodePageNumber", Qt::CTRL + Qt::SHIFT + Qt::ALT + Qt::Key_P);
+	defKeys.insert("unicodeNewLine", Qt::SHIFT + Qt::Key_Return);
 
 	//Plugins
-	defKeys.insert("ExportAsImage", Qt::CTRL+Qt::SHIFT+Qt::Key_E);
-	defKeys.insert("NewFromDocumentTemplate", Qt::CTRL+Qt::ALT+Qt::Key_N);
-	defKeys.insert("SaveAsDocumentTemplate", Qt::CTRL+Qt::ALT+Qt::Key_S);
+	defKeys.insert("ExportAsImage", Qt::CTRL + Qt::SHIFT + Qt::Key_E);
+	defKeys.insert("NewFromDocumentTemplate", Qt::CTRL + Qt::ALT + Qt::Key_N);
+	defKeys.insert("SaveAsDocumentTemplate", Qt::CTRL + Qt::ALT + Qt::Key_S);
 }
 
 void ActionManager::createDefaultMenuNames()
@@ -2123,10 +2124,9 @@ void ActionManager::createDefaultMenus()
 		<< "editJavascripts";
 	//Style
 	++itmenu;
-	int font_sizes[] = {7, 9, 10, 11, 12, 14, 18, 24, 36, 48, 60, 72};
-	size_t f_size = sizeof(font_sizes) / sizeof(*font_sizes);
-	for (uint s = 0; s < f_size; ++s)
-		itmenu->second << QString("fontSize%1").arg(font_sizes[s]);
+	std::array<int, 12> font_sizes = { 7, 9, 10, 11, 12, 14, 18, 24, 36, 48, 60, 72 };
+	for (auto fontSize : font_sizes)
+		itmenu->second << QString("fontSize%1").arg(fontSize);
 	itmenu->second
 		<< "fontSizeOther"
 		<< "alignLeft" 
diff -Naupr scribus-1.6.2/scribus/canvasmode.cpp scribus16x/scribus/canvasmode.cpp
--- scribus-1.6.2/scribus/canvasmode.cpp	2024-06-15 16:22:34.000000000 +0200
+++ scribus16x/scribus/canvasmode.cpp	2025-01-04 10:59:09.016320458 +0100
@@ -295,7 +295,6 @@ void CanvasMode::drawSelection(QPainter*
 				if (!m_doc->Items->contains(currItem))
 					continue;
 				psx->save();
-				double lineAdjust(psx->pen().width() / m_canvas->scale());
 				double x, y, w, h;
 				w = currItem->visualWidth() ;
 				h = currItem->visualHeight() ;
@@ -304,14 +303,14 @@ void CanvasMode::drawSelection(QPainter*
 					psx->setRenderHint(QPainter::Antialiasing);
 					psx->translate(currItem->xPos(), currItem->yPos());
 					psx->rotate(currItem->rotation());
-					x = currItem->asLine() ? 0 : (currItem->visualXPos() - currItem->xPos() - lineAdjust);
-					y = currItem->asLine() ? (h / -2.0) : (currItem->visualYPos() - currItem->yPos() - lineAdjust);
+					x = currItem->asLine() ? 0 : (currItem->visualXPos() - currItem->xPos());
+					y = currItem->asLine() ? (h / -2.0) : (currItem->visualYPos() - currItem->yPos());
 				}
 				else
 				{
 					psx->translate(currItem->visualXPos(), currItem->visualYPos());
-					x = currItem->asLine() ? 0 : -lineAdjust;
-					y = currItem->asLine() ? 0 : -lineAdjust;
+					x = 0;
+					y = 0;
 				}
 				psx->setBrush(Qt::NoBrush);
 				psx->setPen(ba);
@@ -324,13 +323,12 @@ void CanvasMode::drawSelection(QPainter*
 		}
 		psx->save();
 		psx->setPen(m_pen["selection-group"]);
-		double lineAdjust(psx->pen().width() / m_canvas->scale());
 		double x, y, w, h;
 		m_doc->m_Selection->getVisualGroupRect(&x, &y, &w, &h);
 
 		psx->translate(x,y);
-		x = -lineAdjust;
-		y = -lineAdjust;
+		x = 0;
+		y = 0;
 
 		psx->setBrush(Qt::NoBrush);
 		psx->setPen(ba);
@@ -354,7 +352,6 @@ void CanvasMode::drawSelection(QPainter*
 			psx->save();
 			psx->setPen(m_pen["selection"]);
 			psx->setBrush(m_brush["selection"]);
-			double lineAdjust(psx->pen().width() / m_canvas->scale());
 			double x, y, w, h;
 			if (currItem->isGroupChild())
 			{
@@ -399,14 +396,14 @@ void CanvasMode::drawSelection(QPainter*
 					psx->setRenderHint(QPainter::Antialiasing);
 					psx->translate(currItem->xPos(), currItem->yPos());
 					psx->rotate(currItem->rotation());
-					x = currItem->asLine() ? 0 : (currItem->visualXPos() - currItem->xPos() - lineAdjust);
-					y = currItem->asLine() ? (h / -2.0) : (currItem->visualYPos() - currItem->yPos() - lineAdjust);
+					x = currItem->asLine() ? 0 : (currItem->visualXPos() - currItem->xPos());
+					y = currItem->asLine() ? (h / -2.0) : (currItem->visualYPos() - currItem->yPos());
 				}
 				else
 				{
 					psx->translate(currItem->visualXPos(), currItem->visualYPos());
-					x = currItem->asLine() ? 0 : -lineAdjust;
-					y = currItem->asLine() ? 0 : -lineAdjust;
+					x = 0;
+					y = 0;
 				}
 				psx->setBrush(Qt::NoBrush);
 				if (m_doc->drawAsPreview && !m_doc->editOnPreview)
diff -Naupr scribus-1.6.2/scribus/canvasmode_editarc.h scribus16x/scribus/canvasmode_editarc.h
--- scribus-1.6.2/scribus/canvasmode_editarc.h	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/scribus/canvasmode_editarc.h	2025-01-04 10:59:09.014320499 +0100
@@ -61,14 +61,14 @@ public:
 
 private:
 
-	typedef enum 
+	enum eArcPoint
 	{
 		noPointDefined,
 		useControlStart,
 		useControlSweep,
 		useControlHeight,
 		useControlWidth
-	} eArcPoint;
+	};
 
 	inline bool GetItem(PageItem** pi);
 
diff -Naupr scribus-1.6.2/scribus/canvasmode_editgradient.cpp scribus16x/scribus/canvasmode_editgradient.cpp
--- scribus-1.6.2/scribus/canvasmode_editgradient.cpp	2024-06-15 16:22:36.000000000 +0200
+++ scribus16x/scribus/canvasmode_editgradient.cpp	2025-01-04 10:59:08.674327594 +0100
@@ -336,7 +336,7 @@ void CanvasMode_EditGradient::mouseMoveE
 				currItem->GrStrokeStartY -= np.y(); // (Myp - newY); // / m_canvas->scale();
 				currItem->GrStrokeFocalX -= np.x();
 				currItem->GrStrokeFocalY -= np.y();
-				if (currItem->strokeGradientType() == 7)
+				if (currItem->strokeGradientType() == Gradient_Radial)
 				{
 					double radEnd = distance(currItem->GrStrokeEndX - currItem->GrStrokeStartX, currItem->GrStrokeEndY - currItem->GrStrokeStartY);
 					double radFoc = distance(currItem->GrStrokeFocalX - currItem->GrStrokeStartX, currItem->GrStrokeFocalY - currItem->GrStrokeStartY);
@@ -375,7 +375,7 @@ void CanvasMode_EditGradient::mouseMoveE
 				QPointF shRe = m.map(shR - np);
 				currItem->GrStrokeFocalX = shRe.x();
 				currItem->GrStrokeFocalY = shRe.y();
-				if (currItem->strokeGradientType() == 7)
+				if (currItem->strokeGradientType() == Gradient_Radial)
 				{
 					double radEnd = distance(currItem->GrStrokeEndX - currItem->GrStrokeStartX, currItem->GrStrokeEndY - currItem->GrStrokeStartY);
 					double radFoc = distance(currItem->GrStrokeFocalX - currItem->GrStrokeStartX, currItem->GrStrokeFocalY - currItem->GrStrokeStartY);
@@ -411,7 +411,7 @@ void CanvasMode_EditGradient::mouseMoveE
 			{
 				currItem->GrStrokeEndX -= np.x(); // (Mxp - newX); // / m_canvas->scale();
 				currItem->GrStrokeEndY -= np.y(); // (Myp - newY); // / m_canvas->scale();
-				if (currItem->strokeGradientType() == 7)
+				if (currItem->strokeGradientType() == Gradient_Radial)
 				{
 					double radEnd = distance(currItem->GrStrokeEndX - currItem->GrStrokeStartX, currItem->GrStrokeEndY - currItem->GrStrokeStartY);
 					double radFoc = distance(currItem->GrStrokeFocalX - currItem->GrStrokeStartX, currItem->GrStrokeFocalY - currItem->GrStrokeStartY);
@@ -526,7 +526,7 @@ void CanvasMode_EditGradient::mouseMoveE
 				currItem->GrStartY -= np.y();
 				currItem->GrFocalX -= np.x();
 				currItem->GrFocalY -= np.y();
-				if ((currItem->gradientType() == 7) || (currItem->gradientType() == 13))
+				if ((currItem->gradientType() == Gradient_Radial) || (currItem->gradientType() == Gradient_Conical))
 				{
 					double radEnd = distance(currItem->GrEndX - currItem->GrStartX, currItem->GrEndY - currItem->GrStartY);
 					double radFoc = distance(currItem->GrFocalX - currItem->GrStartX, currItem->GrFocalY - currItem->GrStartY);
diff -Naupr scribus-1.6.2/scribus/canvasmode_editgradient.h scribus16x/scribus/canvasmode_editgradient.h
--- scribus-1.6.2/scribus/canvasmode_editgradient.h	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/scribus/canvasmode_editgradient.h	2025-01-04 10:59:09.014320499 +0100
@@ -54,7 +54,7 @@ class CanvasMode_EditGradient :  public
 
 	private:
 
-		typedef enum
+		enum eGradientPoint
 		{
 			noPointDefined,
 			useGradientStart,
@@ -66,7 +66,7 @@ class CanvasMode_EditGradient :  public
 			useControl3,
 			useControl4,
 			useControl5
-		} eGradientPoint;
+		};
 
 		inline bool GetItem(PageItem** pi);
 
diff -Naupr scribus-1.6.2/scribus/canvasmode_editmeshgradient.h scribus16x/scribus/canvasmode_editmeshgradient.h
--- scribus-1.6.2/scribus/canvasmode_editmeshgradient.h	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/scribus/canvasmode_editmeshgradient.h	2025-01-04 10:59:09.014320499 +0100
@@ -59,14 +59,14 @@ class CanvasMode_EditMeshGradient :  pub
 
 	private:
 
-		typedef enum
+		enum eMGradientPoint
 		{
 			noPointDefined,
 			useControlT,
 			useControlB,
 			useControlL,
 			useControlR
-		} eMGradientPoint;
+		};
 
 		inline bool GetItem(PageItem** pi);
 
diff -Naupr scribus-1.6.2/scribus/canvasmode_editmeshpatch.h scribus16x/scribus/canvasmode_editmeshpatch.h
--- scribus-1.6.2/scribus/canvasmode_editmeshpatch.h	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/scribus/canvasmode_editmeshpatch.h	2025-01-04 10:59:09.014320499 +0100
@@ -61,16 +61,17 @@ class CanvasMode_EditMeshPatch :  public
 
 	private:
 		void snapToOtherPatch(double &x, double &y);
-		typedef enum
+
+		enum eMPatchPoint
 		{
 			noPointDefined,
 			useTL,
 			useTR,
 			useBR,
 			useBL
-		} eMPatchPoint;
+		};
 
-		typedef enum
+		enum eMGradientPoint
 		{
 			noControlPointDefined,
 			useControlT,
@@ -78,7 +79,7 @@ class CanvasMode_EditMeshPatch :  public
 			useControlL,
 			useControlR,
 			useControlC
-		} eMGradientPoint;
+		};
 
 		inline bool GetItem(PageItem** pi);
 
diff -Naupr scribus-1.6.2/scribus/canvasmode_editpolygon.h scribus16x/scribus/canvasmode_editpolygon.h
--- scribus-1.6.2/scribus/canvasmode_editpolygon.h	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/scribus/canvasmode_editpolygon.h	2025-01-04 10:59:09.015320478 +0100
@@ -61,14 +61,14 @@ public:
 
 private:
 
-	typedef enum 
+	enum ePolygonPoint
 	{
 		noPointDefined,
 		useControlOuter,
 		useControlInner,
 		useControlInnerCurve,
 		useControlOuterCurve
-	} ePolygonPoint;
+	};
 
 	inline bool GetItem(PageItem** pi);
 	double GetZeroFactor();
diff -Naupr scribus-1.6.2/scribus/canvasmode_editspiral.h scribus16x/scribus/canvasmode_editspiral.h
--- scribus-1.6.2/scribus/canvasmode_editspiral.h	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/scribus/canvasmode_editspiral.h	2025-01-04 10:59:09.015320478 +0100
@@ -61,12 +61,12 @@ public:
 
 private:
 
-	typedef enum 
+	enum eSpiralPoint
 	{
 		noPointDefined,
 		useControlStart,
 		useControlEnd,
-	} eSpiralPoint;
+	};
 
 	inline bool GetItem(PageItem** pi);
 	QPointF getSegment(double angle);
diff -Naupr scribus-1.6.2/scribus/colormgmt/sccolorspacedata_cmyk.h scribus16x/scribus/colormgmt/sccolorspacedata_cmyk.h
--- scribus-1.6.2/scribus/colormgmt/sccolorspacedata_cmyk.h	2024-06-15 16:22:35.000000000 +0200
+++ scribus16x/scribus/colormgmt/sccolorspacedata_cmyk.h	2025-01-04 10:59:08.803324902 +0100
@@ -52,9 +52,9 @@ ScColorSpaceDataTempl_CMYK<T, COLORFORMA
 	}
 };
 
-typedef ScColorSpaceDataTempl_CMYK<unsigned char , Format_CMYK_8>  ScColorSpaceData_CMYK8;
-typedef ScColorSpaceDataTempl_CMYK<unsigned short, Format_CMYK_16> ScColorSpaceData_CMYK16;
-typedef ScColorSpaceDataTempl_CMYK<unsigned char , Format_YMCK_8>  ScColorSpaceData_YMCK8;
-typedef ScColorSpaceDataTempl_CMYK<unsigned short, Format_YMCK_16> ScColorSpaceData_YMCK16;
+using ScColorSpaceData_CMYK8	= ScColorSpaceDataTempl_CMYK<unsigned char, Format_CMYK_8>;
+using ScColorSpaceData_CMYK16	= ScColorSpaceDataTempl_CMYK<unsigned short, Format_CMYK_16>;
+using ScColorSpaceData_YMCK8	= ScColorSpaceDataTempl_CMYK<unsigned char, Format_YMCK_8>;
+using ScColorSpaceData_YMCK16	= ScColorSpaceDataTempl_CMYK<unsigned short, Format_YMCK_16>;
 
 #endif
diff -Naupr scribus-1.6.2/scribus/colormgmt/sccolorspacedata_cmyka.h scribus16x/scribus/colormgmt/sccolorspacedata_cmyka.h
--- scribus-1.6.2/scribus/colormgmt/sccolorspacedata_cmyka.h	2024-06-15 16:22:35.000000000 +0200
+++ scribus16x/scribus/colormgmt/sccolorspacedata_cmyka.h	2025-01-04 10:59:08.803324902 +0100
@@ -60,7 +60,7 @@ void ScColorSpaceDataTempl_CMYKA<T, COLO
 	};
 };
 
-typedef ScColorSpaceDataTempl_CMYKA<unsigned char , Format_CMYKA_8>  ScColorSpaceData_CMYKA8;
-typedef ScColorSpaceDataTempl_CMYKA<unsigned short, Format_CMYKA_16> ScColorSpaceData_CMYKA16;
+using ScColorSpaceData_CMYKA8	= ScColorSpaceDataTempl_CMYKA<unsigned char, Format_CMYKA_8>;
+using ScColorSpaceData_CMYKA16	= ScColorSpaceDataTempl_CMYKA<unsigned short, Format_CMYKA_16>;
 
 #endif
diff -Naupr scribus-1.6.2/scribus/colormgmt/sccolorspacedata_gray.h scribus16x/scribus/colormgmt/sccolorspacedata_gray.h
--- scribus-1.6.2/scribus/colormgmt/sccolorspacedata_gray.h	2024-06-15 16:22:35.000000000 +0200
+++ scribus16x/scribus/colormgmt/sccolorspacedata_gray.h	2025-01-04 10:59:08.803324902 +0100
@@ -29,7 +29,7 @@ ScColorSpaceDataTempl_Gray<T, COLORFORMA
 	}
 };
 
-typedef ScColorSpaceDataTempl_Gray<unsigned char , Format_GRAY_8>  ScColorSpaceData_GRAY8;
-typedef ScColorSpaceDataTempl_Gray<unsigned short, Format_GRAY_16> ScColorSpaceData_GRAY16;
+using ScColorSpaceData_GRAY8	= ScColorSpaceDataTempl_Gray<unsigned char, Format_GRAY_8>;
+using ScColorSpaceData_GRAY16	= ScColorSpaceDataTempl_Gray<unsigned short, Format_GRAY_16>;
 
 #endif
diff -Naupr scribus-1.6.2/scribus/colormgmt/sccolorspacedata_laba.h scribus16x/scribus/colormgmt/sccolorspacedata_laba.h
--- scribus-1.6.2/scribus/colormgmt/sccolorspacedata_laba.h	2024-06-15 16:22:35.000000000 +0200
+++ scribus16x/scribus/colormgmt/sccolorspacedata_laba.h	2025-01-04 10:59:08.803324902 +0100
@@ -58,6 +58,6 @@ void ScColorSpaceDataTempl_LabA<T, COLOR
 	};
 };
 
-typedef ScColorSpaceDataTempl_LabA<char, Format_LabA_8>  ScColorSpaceData_LabA8;
+using ScColorSpaceData_LabA8 = ScColorSpaceDataTempl_LabA<char, Format_LabA_8>;
 
 #endif
diff -Naupr scribus-1.6.2/scribus/colormgmt/sccolorspacedata_labdbl.h scribus16x/scribus/colormgmt/sccolorspacedata_labdbl.h
--- scribus-1.6.2/scribus/colormgmt/sccolorspacedata_labdbl.h	2024-06-15 16:22:35.000000000 +0200
+++ scribus16x/scribus/colormgmt/sccolorspacedata_labdbl.h	2025-01-04 10:59:08.803324902 +0100
@@ -43,6 +43,6 @@ ScColorSpaceDataTempl_LabDbl<T, COLORFOR
 	}
 };
 
-typedef ScColorSpaceDataTempl_LabDbl<char, Format_Lab_Dbl>  ScColorSpaceData_LabD;
+using ScColorSpaceData_LabD = ScColorSpaceDataTempl_LabDbl<char, Format_Lab_Dbl>;
 
 #endif
diff -Naupr scribus-1.6.2/scribus/colormgmt/sccolorspacedata_rgb.h scribus16x/scribus/colormgmt/sccolorspacedata_rgb.h
--- scribus-1.6.2/scribus/colormgmt/sccolorspacedata_rgb.h	2024-06-15 16:22:35.000000000 +0200
+++ scribus16x/scribus/colormgmt/sccolorspacedata_rgb.h	2025-01-04 10:59:08.803324902 +0100
@@ -43,7 +43,7 @@ ScColorSpaceDataTempl_RGB<T, COLORFORMAT
 	}
 };
 
-typedef ScColorSpaceDataTempl_RGB<unsigned char , Format_RGB_8>  ScColorSpaceData_RGB8;
-typedef ScColorSpaceDataTempl_RGB<unsigned short, Format_RGB_16> ScColorSpaceData_RGB16;
+using ScColorSpaceData_RGB8		= ScColorSpaceDataTempl_RGB<unsigned char, Format_RGB_8>;
+using ScColorSpaceData_RGB16	= ScColorSpaceDataTempl_RGB<unsigned short, Format_RGB_16>;
 
 #endif
diff -Naupr scribus-1.6.2/scribus/colormgmt/sccolorspacedata_rgba.h scribus16x/scribus/colormgmt/sccolorspacedata_rgba.h
--- scribus-1.6.2/scribus/colormgmt/sccolorspacedata_rgba.h	2024-06-15 16:22:35.000000000 +0200
+++ scribus16x/scribus/colormgmt/sccolorspacedata_rgba.h	2025-01-04 10:59:08.804324882 +0100
@@ -72,11 +72,11 @@ void ScColorSpaceDataTempl_RGBA<T, COLOR
 	};
 };
 
-typedef ScColorSpaceDataTempl_RGBA<unsigned char , Format_RGBA_8>  ScColorSpaceData_RGBA8;
-typedef ScColorSpaceDataTempl_RGBA<unsigned short, Format_RGBA_16> ScColorSpaceData_RGBA16;
-typedef ScColorSpaceDataTempl_RGBA<unsigned char , Format_ARGB_8>  ScColorSpaceData_ARGB8;
-typedef ScColorSpaceDataTempl_RGBA<unsigned short, Format_ARGB_16> ScColorSpaceData_ARGB16;
-typedef ScColorSpaceDataTempl_RGBA<unsigned char , Format_BGRA_8>  ScColorSpaceData_BGRA8;
-typedef ScColorSpaceDataTempl_RGBA<unsigned short, Format_BGRA_16> ScColorSpaceData_BGRA16;
+using ScColorSpaceData_RGBA8	= ScColorSpaceDataTempl_RGBA<unsigned char, Format_RGBA_8>;
+using ScColorSpaceData_RGBA16	= ScColorSpaceDataTempl_RGBA<unsigned short, Format_RGBA_16>;
+using ScColorSpaceData_ARGB8	= ScColorSpaceDataTempl_RGBA<unsigned char, Format_ARGB_8>;
+using ScColorSpaceData_ARGB16	= ScColorSpaceDataTempl_RGBA<unsigned short, Format_ARGB_16>;
+using ScColorSpaceData_BGRA8	= ScColorSpaceDataTempl_RGBA<unsigned char, Format_BGRA_8>;
+using ScColorSpaceData_BGRA16	= ScColorSpaceDataTempl_RGBA<unsigned short, Format_BGRA_16>;
 
 #endif
diff -Naupr scribus-1.6.2/scribus/colorsetmanager.cpp scribus16x/scribus/colorsetmanager.cpp
--- scribus-1.6.2/scribus/colorsetmanager.cpp	2024-06-15 16:22:35.000000000 +0200
+++ scribus16x/scribus/colorsetmanager.cpp	2025-01-04 10:59:09.016320458 +0100
@@ -48,7 +48,7 @@ void ColorSetManager::initialiseDefaultP
 		appPrefs.colorPrefs.DColors.insert("Red", ScColor(0, 255, 255, 0));
 		appPrefs.colorPrefs.DColors.insert("Yellow", ScColor(0, 0, 255, 0));
 		appPrefs.colorPrefs.DColors.insert("Magenta", ScColor(0, 255, 0, 0));
-		appPrefs.colorPrefs.DColorSet = "Scribus_Small";
+		appPrefs.colorPrefs.DColorSet = "Scribus Small";
 		return;
 	}
 
diff -Naupr scribus-1.6.2/scribus/desaxe/automata.h scribus16x/scribus/desaxe/automata.h
--- scribus-1.6.2/scribus/desaxe/automata.h	2024-06-15 16:22:34.000000000 +0200
+++ scribus16x/scribus/desaxe/automata.h	2025-01-04 10:59:08.783325320 +0100
@@ -24,7 +24,7 @@ public:
 	FA_base(const std::set<STATE>& states, const std::set<INPUT>& inputs, STATE start, STATE deflt);
 	virtual ~FA_base();
 
-	typedef std::map<INPUT, OUTPUT> Transitions;
+	using Transitions = std::map<INPUT, OUTPUT>;
 
 	const std::set<STATE>& states() const;
 	const std::set<INPUT>& inputs() const;
diff -Naupr scribus-1.6.2/scribus/desaxe/desaxe_conf.h scribus16x/scribus/desaxe/desaxe_conf.h
--- scribus-1.6.2/scribus/desaxe/desaxe_conf.h	2024-06-15 16:22:34.000000000 +0200
+++ scribus16x/scribus/desaxe/desaxe_conf.h	2025-01-04 10:59:08.783325320 +0100
@@ -24,8 +24,8 @@
 #include <QString>
 #include <QMap>
 
-typedef QString Xml_string;
-typedef QMap<Xml_string, Xml_string> Xml_attr;
+using Xml_string = QString;
+using Xml_attr = QMap<Xml_string, Xml_string>;
 
 inline Xml_string Xml_key(Xml_attr::iterator& it) { return it.key(); }
 inline Xml_string Xml_data(Xml_attr::iterator& it) { return it.value(); }
@@ -38,8 +38,8 @@ inline Xml_string fromSTLString(const st
 #include <utility>
 #include <map>
 
-typedef std::string Xml_string;
-typedef std::map<Xml_string, Xml_string> Xml_attr;
+using Xml_string = std::string;
+using Xml_attr = std::map<Xml_string, Xml_string>;
 
 inline Xml_string Xml_key(Xml_attr::iterator& it) { return it->first; }
 inline Xml_string Xml_data(Xml_attr::iterator& it) { return it->second; }
diff -Naupr scribus-1.6.2/scribus/desaxe/digester.cpp scribus16x/scribus/desaxe/digester.cpp
--- scribus-1.6.2/scribus/desaxe/digester.cpp	2024-06-15 16:22:34.000000000 +0200
+++ scribus16x/scribus/desaxe/digester.cpp	2025-01-04 10:59:08.782325341 +0100
@@ -7,37 +7,38 @@
  *
  */
 
-#include <iostream>
-#include <vector>
-#include <map>
-#include <utility>
+#include <cstdint>
 #include <deque>
 #include <functional>
+#include <iostream>
+#include <map>
 #include <set>
+#include <utility>
+#include <vector>
 
-#include "digester.h"
-#include "automata.h"
 #include "actions.h"
+#include "automata.h"
+#include "digester.h"
 
 namespace desaxe {
 
-typedef std::pair<Xml_string, Action> rule_t;
+using rule_t = std::pair<Xml_string, Action>;
 
-typedef unsigned short token_t;
-typedef std::vector<token_t> path_t;
+using token_t = unsigned short;
+using path_t = std::vector<token_t>;
 enum special_token { EMPTY = 0, START = 1, ANY = 2, REPEAT = 3 } ;
 
-typedef unsigned short nfa_state_t;
+using nfa_state_t = unsigned short;
 
 struct DFA_State
 {
-	unsigned int ID;
+	unsigned int ID { 0 };
 	std::vector<rule_t> rules;
 
-	DFA_State() : ID(0) {}
+	DFA_State() = default;
 };
 
-typedef DFA_State* dfa_state_t;
+using dfa_state_t = DFA_State*;
 
 
 /**
@@ -74,7 +75,7 @@ private:
 	/// lists the accepting (NFA) states for each rule (same sequence as rules)
 	std::vector<nfa_state_t> accepting;
 	/// the dfa corresponding to the rule patterns
-	automata::DFA<dfa_state_t, token_t> *dfa;
+	automata::DFA<dfa_state_t, token_t> *dfa { nullptr };
 	/// stack of dfa states
 	std::vector<dfa_state_t> stateStack;
 
@@ -88,7 +89,7 @@ private:
 	/// uses rules and createNFA() to create the DFA and assigns rules to states
 	void compileDFA();
 	/// is true after compileDFA has run
-	bool valid;
+	bool valid { false };
 };
 
 
@@ -100,7 +101,8 @@ Digester::Digester()
 }
 
 
-Digester::~Digester() {
+Digester::~Digester()
+{
 	delete m_state;
 	deletePatches(m_patches);
 }
@@ -162,8 +164,7 @@ void Digester::begin(const Xml_string& t
 {
 	m_state->open(tag);
 	const std::vector<rule_t>& rules (m_state->rulesForCurrentState());
-	std::vector<rule_t>::const_iterator it;
-	for(it = rules.begin(); it != rules.end(); ++it)
+	for (auto it = rules.begin(); it != rules.end(); ++it)
 	{
 #ifdef DESAXE_DEBUG
 		std::cerr << "B " << it->first.toStdString() << " " << typeid(it->second).name() << "\n";
@@ -175,8 +176,7 @@ void Digester::begin(const Xml_string& t
 void Digester::end(const Xml_string& tag)
 {
 	const std::vector<rule_t>& rules (m_state->rulesForCurrentState());
-	std::vector<rule_t>::const_reverse_iterator it;
-	for(it = rules.rbegin(); it != rules.rend(); ++it)
+	for (auto it = rules.rbegin(); it != rules.rend(); ++it)
 	{
 #ifdef DESAXE_DEBUG
 		std::cerr << "E " << it->first.toStdString() << " " << typeid(it->second).name() << "\n";
@@ -189,8 +189,7 @@ void Digester::end(const Xml_string& tag
 void Digester::chars(const Xml_string& text)
 {
 	const std::vector<rule_t>& rules (m_state->rulesForCurrentState());
-	std::vector<rule_t>::const_iterator it;
-	for(it = rules.begin(); it != rules.end(); ++it)
+	for (auto it = rules.begin(); it != rules.end(); ++it)
 	{
 #ifdef DESAXE_DEBUG
 		std::cerr << "C " << it->first.toStdString() << " " << typeid(it->second).name() << "\n";
@@ -216,10 +215,10 @@ Xml_string Digester::concat(const Xml_st
 }
 
 
-RuleState::RuleState() : dfa(nullptr), valid(false)
+RuleState::RuleState()
 {}
 
-RuleState::RuleState(const RuleState& other) : rules(other.rules), dfa(nullptr), valid(false)
+RuleState::RuleState(const RuleState& other) : rules(other.rules)
 {}
 
 RuleState::~RuleState()
@@ -235,7 +234,7 @@ RuleState::~RuleState()
 
 void RuleState::addRule(const Xml_string& pattern, Action action)
 {
-	rules.push_back(std::pair<Xml_string, Action>(pattern,action));
+	rules.emplace_back(pattern, action);
 	valid = false;
 }
 
@@ -243,8 +242,7 @@ void RuleState::addRule(const Xml_string
 inline
 void RuleState::reset()
 {
-	std::vector<rule_t>::iterator it;
-	for (it = rules.begin(); it != rules.end(); ++it)
+	for (auto it = rules.begin(); it != rules.end(); ++it)
 		it->second.reset();
 	stateStack.clear();
 	if (!valid)
@@ -259,20 +257,20 @@ void RuleState::dump()
 		std::cout << r << ":\t\"" << rules[r].first.toStdString() << "\" accepted in  (" << accepting[r] << ")\n";
 	}
 	std::cout << "\nTokens:\n";
-	for (std::map<Xml_string, token_t>::iterator it = tokens.begin(); it != tokens.end(); ++it) {
+	for (auto it = tokens.begin(); it != tokens.end(); ++it) {
 		std::cout << it->first.toStdString() << ":\t--> " << it->second << "\n";
 	}
 	std::cout << "\nAutomaton:\n";
 	const std::set<dfa_state_t>& states(dfa->states());
 	const std::set<token_t>& inputs(dfa->inputs());
 	std::cout << "STATE";
-	for (std::set<token_t>::const_iterator i = inputs.begin(); i != inputs.end(); ++i) {
+	for (auto i = inputs.begin(); i != inputs.end(); ++i) {
 		std::cout << "\t" << *i;
 	}
 	std::cout << "\tRULES\n\n";
-	for (std::set<dfa_state_t>::const_iterator s = states.begin(); s != states.end(); ++s) {
+	for (auto s = states.begin(); s != states.end(); ++s) {
 		std::cout << (*s)->ID;
-		for (std::set<token_t>::const_iterator i = inputs.begin(); i != inputs.end(); ++i) {
+		for (auto i = inputs.begin(); i != inputs.end(); ++i) {
 			dfa_state_t nstate = dfa->next(*s, *i);
 			std::cout << "\t";
 			if (nstate)
@@ -280,7 +278,7 @@ void RuleState::dump()
 			else
 				std::cout << "--";
 		}
-		for (std::vector<rule_t>::iterator rs = (*s)->rules.begin(); rs != (*s)->rules.end(); ++rs)
+		for (auto rs = (*s)->rules.begin(); rs != (*s)->rules.end(); ++rs)
 			std::cout << "\t\"" << rs->first.toStdString() << "\"";
 		std::cout << "\n";
 	}
@@ -356,17 +354,17 @@ automata::NFA<nfa_state_t, token_t>* Rul
 	std::set<nfa_state_t> deflt;
 	deflt.insert(EMPTY);
 
-	NFA<nfa_state_t, token_t> *nfa = new NFA<nfa_state_t, token_t>(START, deflt);
+	auto *nfa = new NFA<nfa_state_t, token_t>(START, deflt);
 
 	nfa->addState(EMPTY);
 	nfa->addInput(ANY);
 	nfa->addTransition(EMPTY, ANY, EMPTY);
 
-	for (unsigned int i = 0; i < rules.size(); ++i)
+	for (const auto& rule : rules)
 	{
-		const std::string currPattern(fromXMLString(rules[i].first));
-		const unsigned int len = currPattern.length();
-		int pos;
+		const std::string currPattern(fromXMLString(rule.first));
+		const size_t len = currPattern.length();
+		std::ptrdiff_t pos;
 		nfa_state_t lastState;
 
 		// determine if this is a start pattern
@@ -424,22 +422,22 @@ automata::NFA<nfa_state_t, token_t>* Rul
 
 		// copy all transition from EMPTY to all other states
 		const NFA<nfa_state_t, token_t>::Transitions& transFromEmpty(nfa->transitions(EMPTY));
-		std::set<nfa_state_t>::const_iterator it, st;
-		NFA<nfa_state_t, token_t>::Transitions::const_iterator tr;
-		for (it = nfa->states().begin(); it != nfa->states().end(); ++it) {
+		for (auto it = nfa->states().begin(); it != nfa->states().end(); ++it)
+		{
 			if (*it == EMPTY)
 				continue;
-			for (tr = transFromEmpty.begin(); tr != transFromEmpty.end(); ++tr)
-				for (st = tr->second.begin(); st != tr->second.end(); ++st)
+			for (auto tr = transFromEmpty.begin(); tr != transFromEmpty.end(); ++tr)
+				for (auto st = tr->second.begin(); st != tr->second.end(); ++st)
 					nfa->addTransition(*it, tr->first, *st);
 		}
 
 		// ANY transitions
 		const std::set<token_t>& inputs(nfa->inputs());
 		std::set<token_t>::const_iterator tok;
-		for (it = nfa->states().begin(); it != nfa->states().end(); ++it) {
+		for (auto it = nfa->states().begin(); it != nfa->states().end(); ++it)
+		{
 			const std::set<nfa_state_t>& anyStates(nfa->next(*it, ANY));
-			for (st = anyStates.begin(); st != anyStates.end(); ++st)
+			for (auto st = anyStates.begin(); st != anyStates.end(); ++st)
 				for (tok = inputs.begin(); tok != inputs.end(); ++tok)
 					if (*tok != ANY)
 						nfa->addTransition(*it, *tok, *st);
@@ -456,10 +454,10 @@ struct CreateDFAState
 
 	dfa_state_t operator()(const std::set<nfa_state_t>& combination)
 	{
-		dfa_state_t result = new DFA_State();
+		auto* result = new DFA_State();
 		result->ID = n++;
 		result->rules.clear();
-		for (unsigned int i=0; i < rules_.size(); ++i)
+		for (unsigned int i = 0; i < rules_.size(); ++i)
 			if (combination.find(accepting_[i]) != combination.end())
 				result->rules.push_back(rules_[i]);
 		return result;
diff -Naupr scribus-1.6.2/scribus/desaxe/digester.h scribus16x/scribus/desaxe/digester.h
--- scribus-1.6.2/scribus/desaxe/digester.h	2024-06-15 16:22:34.000000000 +0200
+++ scribus16x/scribus/desaxe/digester.h	2025-01-04 10:59:08.782325341 +0100
@@ -57,16 +57,15 @@ namespace PRIVATE {
 	void chkcell(const VarPtr& cell, std::vector<VarPtr>* stack = nullptr)
 	{
 		ObjType* dummy = nullptr;
-		if( cell.type != typeid(dummy).name() )
+		if (cell.type != typeid(dummy).name())
 		{
 			std::cerr << "requested type '" << typeid(dummy).name() << "' doesn't match cell type '" << cell.type << "'\n";
 			if (stack)
 			{
-				int i=0;
-				std::vector<VarPtr>::iterator it;
-				for (it = stack->begin(); it != stack->end(); ++it)
+				int i = 0;
+				for (auto it = stack->begin(); it != stack->end(); ++it)
 				{
-					std::cerr << i++ << "\t" << (*it).type << "\t" << (*it).ptr << "\n";
+					std::cerr << i++ << "\t" << it->type << "\t" << it->ptr << "\n";
 				}
 			}
 			assert (false);
@@ -82,7 +81,7 @@ public:
 	Patch* next { nullptr };
 	Patch(Patch* nxt) : next(nxt) {}
 
-	virtual void run(VarPtr lnk) = 0;
+	virtual void run(const VarPtr& lnk) = 0;
 	virtual ~Patch() {}
 };
 
@@ -102,7 +101,8 @@ class Digester : public SaxHandler {
 public:
 	Digester();
 	Digester& operator=(const Digester& other);
-	virtual ~Digester();
+	~Digester() override;
+
 	void reset();
 	void addRule(const Xml_string& pattern, Action action);
 
@@ -116,11 +116,11 @@ public:
 	const Xml_string &getError(int i) const;
 
 // called by SAX parser:
-	void beginDoc();
-	void endDoc();
-	void begin(const Xml_string& tag, Xml_attr attr);
-	void end(const Xml_string& tag);
-	void chars(const Xml_string& text);
+	void beginDoc() override;
+	void endDoc() override;
+	void begin(const Xml_string& tag, Xml_attr attr) override;
+	void end(const Xml_string& tag) override;
+	void chars(const Xml_string& text) override;
 
 // used by actions:
 	void fail();
@@ -157,23 +157,17 @@ public:
 	static Xml_string concat(const Xml_string& pattern1, const Xml_string& pattern2);
 
 private:
-	RuleState* 
-		m_state;
+	RuleState* m_state { nullptr };
 
-	std::vector<PRIVATE::VarPtr> 
-		m_objects;
+	std::vector<PRIVATE::VarPtr> m_objects;
 
-	std::map<Xml_string, PRIVATE::VarPtr> 
-		m_storage;
+	std::map<Xml_string, PRIVATE::VarPtr> m_storage;
 
-	std::map<Xml_string, PRIVATE::Patch*>
-		m_patches;
+	std::map<Xml_string, PRIVATE::Patch*> m_patches;
 
-	PRIVATE::VarPtr 
-		m_result_;
+	PRIVATE::VarPtr m_result_;
 
-	std::vector<Xml_string> 
-		m_errors;
+	std::vector<Xml_string> m_errors;
 };
 
 
@@ -245,7 +239,7 @@ void Digester::pop()
 inline
 void Digester::popn(unsigned int number)
 {
-	unsigned int count = (unsigned int) m_objects.size();
+	auto count = (unsigned int) m_objects.size();
 	assert (number <= count);
 	m_objects.resize(count - number);
 }
@@ -269,12 +263,12 @@ namespace PRIVATE {
 	template <class LinkType>
 	struct Patch1 : public Patch
 	{
-		typedef void (*FunType1)(LinkType*);
+		using FunType1 = void (*)(LinkType*);
 		FunType1 fun;
 
 		Patch1(FunType1 fn, Patch* nxt = nullptr) : Patch(nxt), fun(fn) {}
 
-		void run(VarPtr link) 
+		void run(const VarPtr& link) override 
 		{ 
 			fun( static_cast<LinkType*>(link.ptr) ); 
 		}
@@ -284,13 +278,13 @@ namespace PRIVATE {
 	template <class ObjType, class LinkType>
 		struct Patch2 : public Patch
 	{
-		typedef void (ObjType::*FunType2)(LinkType*);
+		using FunType2 = void (ObjType::*)(LinkType *);
 		ObjType* obj { nullptr };
 		FunType2 fun;
 		
 		Patch2(ObjType* ob, FunType2 fn, Patch* nxt = nullptr) : Patch(nxt), obj(ob), fun(fn) {}
 
-		void run(VarPtr link)
+		void run(const VarPtr& link) override
 		{
 			(obj->*fun)( static_cast<LinkType*>(link.ptr) ); 
 		}
@@ -298,7 +292,7 @@ namespace PRIVATE {
 
 
 	inline
-	void runPatches(Patch*& list, VarPtr link)
+	void runPatches(Patch*& list, const VarPtr& link)
 	{
 		while (list)
 		{
@@ -312,8 +306,7 @@ namespace PRIVATE {
 	inline
 	void deletePatches(std::map<Xml_string, Patch*>& patches)
 	{
-		std::map<Xml_string, Patch*>::iterator it;
-		for (it = patches.begin(); it != patches.end(); ++it)
+		for (auto it = patches.begin(); it != patches.end(); ++it)
 		{
 			Patch* list = it->second;
 			while (list)
diff -Naupr scribus-1.6.2/scribus/desaxe/digester_parse.cpp scribus16x/scribus/desaxe/digester_parse.cpp
--- scribus-1.6.2/scribus/desaxe/digester_parse.cpp	2024-06-15 16:22:34.000000000 +0200
+++ scribus16x/scribus/desaxe/digester_parse.cpp	2025-01-04 10:59:08.782325341 +0100
@@ -20,13 +20,14 @@ class DigesterParser : public QXmlDefaul
 {
 public:
 	DigesterParser(Digester* digester) : dig(digester) {}
-	bool startDocument()
+
+	bool startDocument() override
 	{
 		dig->beginDoc();
 		return true;
 	}
-	bool startElement( const QString& nsURI, const QString& locName, const QString& qName,
-	                   const QXmlAttributes& qattr)
+	bool startElement(const QString& nsURI, const QString& locName, const QString& qName,
+	                  const QXmlAttributes& qattr) override
 	{
 		Xml_attr attr;
 		for (int i=0; i < qattr.count(); ++i)
@@ -35,38 +36,38 @@ public:
 		return true;
 	}
 
-	bool endElement( const QString& nsURI, const QString& locName, const QString& qName)
+	bool endElement(const QString& nsURI, const QString& locName, const QString& qName) override
 	{
 		dig->end(qName);
 		return true;
 	}
 
-	bool characters ( const QString & ch ) 
+	bool characters(const QString& ch) override
 	{
 		dig->chars(ch);
 		return true;
 	}
 
-	bool error(const QXmlParseException& exception)
+	bool error(const QXmlParseException& exception) override
 	{
 		qDebug("error : line %d, column %d, %s\n", exception.lineNumber(), exception.columnNumber(), exception.message().toLocal8Bit().data());
 		return true;
 	}
 
-	bool fatalError(const QXmlParseException& exception)
+	bool fatalError(const QXmlParseException& exception) override
 	{
 		qDebug("fatal error : line %d, column %d, %s\n", exception.lineNumber(), exception.columnNumber(), exception.message().toLocal8Bit().data());
 		return true;
 	}
 
-	bool warning(const QXmlParseException& exception)
+	bool warning(const QXmlParseException& exception) override
 	{
 		qDebug("warning : line %d, column %d, %s\n", exception.lineNumber(), exception.columnNumber(), exception.message().toLocal8Bit().data());
 		return true;
 	}
 
 private:
-	Digester * dig;
+	Digester* dig { nullptr };
 };
 
 void Digester::parseFile(const Xml_string& filename)
diff -Naupr scribus-1.6.2/scribus/desaxe/saxXML.cpp scribus16x/scribus/desaxe/saxXML.cpp
--- scribus-1.6.2/scribus/desaxe/saxXML.cpp	2024-06-15 16:22:34.000000000 +0200
+++ scribus16x/scribus/desaxe/saxXML.cpp	2025-01-04 10:59:08.782325341 +0100
@@ -62,10 +62,9 @@ void SaxXML::begin(const Xml_string& tag
 			m_stream << " ";
 	}
 	m_stream << "<" << fromXMLString(tag);
-	Xml_attr::iterator it;
 	m_manyAttributes = false;
 	uint i = 0;
-	for (it = attr.begin(); it != attr.end(); ++it)
+	for (auto it = attr.begin(); it != attr.end(); ++it)
 	{
 		// newline and indent every 4 attributes
 		if (i > 0 && (i % 4) == 0 && m_pretty)
diff -Naupr scribus-1.6.2/scribus/desaxe/saxXML.h scribus16x/scribus/desaxe/saxXML.h
--- scribus-1.6.2/scribus/desaxe/saxXML.h	2024-06-15 16:22:34.000000000 +0200
+++ scribus16x/scribus/desaxe/saxXML.h	2025-01-04 10:59:08.783325320 +0100
@@ -16,25 +16,26 @@
 #include "saxhandler.h"
 #include "scribusapi.h"
 
-class SCRIBUS_API SaxXML : public SaxHandler {
+class SCRIBUS_API SaxXML : public SaxHandler
+{
 public:
 	SaxXML(std::ostream& file, bool pretty = false);
 	SaxXML(const char* filename, bool pretty = false);
-	~SaxXML();
+	~SaxXML() override;
 
-	void beginDoc();
-	void endDoc();
-	void begin(const Xml_string& tag, Xml_attr attr);
-	void end(const Xml_string& tag);
-	void chars(const Xml_string& text);
+	void beginDoc() override;
+	void endDoc() override;
+	void begin(const Xml_string& tag, Xml_attr attr) override;
+	void end(const Xml_string& tag) override;
+	void chars(const Xml_string& text) override;
 
 private:
 	std::ofstream m_file;
 	std::ostream& m_stream;
-	bool m_pretty;
-	int m_indentLevel;
-	bool m_manyAttributes;
-	bool m_pendingEmptyTag;
+	bool m_pretty { false };
+	int m_indentLevel { 0 };
+	bool m_manyAttributes { false };
+	bool m_pendingEmptyTag { false };
 	void finalizePendingEmptyTag();
 };
 
diff -Naupr scribus-1.6.2/scribus/desaxe/saxfilter.cpp scribus16x/scribus/desaxe/saxfilter.cpp
--- scribus-1.6.2/scribus/desaxe/saxfilter.cpp	2024-06-15 16:22:34.000000000 +0200
+++ scribus16x/scribus/desaxe/saxfilter.cpp	2025-01-04 10:59:08.783325320 +0100
@@ -81,11 +81,10 @@ AddAttributes::AddAttributes(SaxHandler*
 
 void AddAttributes::begin(const Xml_string& tag, Xml_attr attr)
 {
-	if ( !m_oneshot )
+	if (!m_oneshot)
 	{
 		m_oneshot = true;
-		Xml_attr::iterator it;
-		for (it = attr.begin(); it != attr.end(); ++it)
+		for (auto it = attr.begin(); it != attr.end(); ++it)
 			m_attributes[Xml_key(it)] = Xml_data(it);
 		SaxFilter::begin(tag, m_attributes);
 	}
diff -Naupr scribus-1.6.2/scribus/desaxe/saxfilter.h scribus16x/scribus/desaxe/saxfilter.h
--- scribus-1.6.2/scribus/desaxe/saxfilter.h	2024-06-15 16:22:34.000000000 +0200
+++ scribus16x/scribus/desaxe/saxfilter.h	2025-01-04 10:59:08.783325320 +0100
@@ -17,18 +17,20 @@
 /**
   Abstract super class for filtering a SAX stream.  
  */
-class SaxFilter : public SaxHandler {
+class SaxFilter : public SaxHandler 
+{
 public:
 	SaxFilter(SaxHandler* delegate)        : m_delegate(delegate)  {}
 	void setDelegate(SaxHandler* delegate) { m_delegate = delegate; }
 	SaxHandler* delegate()                 { return m_delegate; }
-	virtual void beginDoc();
-	virtual void endDoc();
-	virtual void begin(const Xml_string& tag, Xml_attr attr);
-	virtual void end(const Xml_string& tag);
-	virtual void chars(const Xml_string& text);
+	void beginDoc() override;
+	void endDoc() override;
+	void begin(const Xml_string& tag, Xml_attr attr) override;
+	void end(const Xml_string& tag) override;
+	void chars(const Xml_string& text) override;
+
 private:
-	SaxHandler* m_delegate;
+	SaxHandler* m_delegate { nullptr };
 };
 
 
@@ -41,14 +43,16 @@ private:
  *     more_output (myhandler);
  *     myhandler.end(keepOpenhandler.opentag());
  */
-class KeepOpen : public SaxFilter {
+class KeepOpen : public SaxFilter
+{
 public:
 	KeepOpen(SaxHandler* delegate);
-	virtual void begin(const Xml_string& tag, Xml_attr attr);
-	virtual void end(const Xml_string& tag);
+	void begin(const Xml_string& tag, Xml_attr attr) override;
+	void end(const Xml_string& tag) override;
 	Xml_string openTag();
+
 private:
-int m_level {0};
+	int m_level {0};
 	Xml_string m_tag;
 };
 
@@ -57,14 +61,16 @@ int m_level {0};
  *  Renames the next opening(and corresponding closing) tag.
  *  If oldname is not empty, it will also rename all inner tags with name oldname
  */
-class RenameElem : public SaxFilter {
+class RenameElem : public SaxFilter
+{
 public:
 	RenameElem(SaxHandler* delegate, const Xml_string& oldname, const Xml_string& newname);
 	RenameElem(SaxHandler* delegate, const Xml_string& newname);
-	virtual void begin(const Xml_string& tag, Xml_attr attr);
-	virtual void end(const Xml_string& tag);
+	void begin(const Xml_string& tag, Xml_attr attr) override;
+	void end(const Xml_string& tag) override;
+
 private:
-int m_level {0};
+	int m_level {0};
 	Xml_string m_old;
 	Xml_string m_new;
 };
@@ -73,12 +79,14 @@ int m_level {0};
 /**
  *  Adds more attributes to the next opening tag
  */
-class AddAttributes : public SaxFilter {
+class AddAttributes : public SaxFilter
+{
 public:
 	AddAttributes(SaxHandler* delegate, Xml_attr add);
-	virtual void begin(const Xml_string& tag, Xml_attr attr);
+	void begin(const Xml_string& tag, Xml_attr attr) override;
+
 private:
-bool m_oneshot {false};
+	bool m_oneshot {false};
 	Xml_attr m_attributes;
 };
 
@@ -92,11 +100,11 @@ bool m_oneshot {false};
 class SaxHandlerNull : public SaxHandler {
 public:
 	SaxHandlerNull() {}
-	virtual void beginDoc() {}
-	virtual void endDoc() {}
-	virtual void begin(const Xml_string& tag, Xml_attr attr) {}
-	virtual void end(const Xml_string& tag) {}
-	virtual void chars(const Xml_string& text) {}
+	void beginDoc() override {}
+	void endDoc() override {}
+	void begin(const Xml_string& tag, Xml_attr attr) override {}
+	void end(const Xml_string& tag) override {}
+	void chars(const Xml_string& text) override {}
 };
 
 
diff -Naupr scribus-1.6.2/scribus/desaxe/saxiohelper.cpp scribus16x/scribus/desaxe/saxiohelper.cpp
--- scribus-1.6.2/scribus/desaxe/saxiohelper.cpp	2024-06-15 16:22:34.000000000 +0200
+++ scribus16x/scribus/desaxe/saxiohelper.cpp	2025-01-04 10:59:08.783325320 +0100
@@ -137,51 +137,50 @@ Xml_string toXMLString(const Xml_string&
 Xml_string toXMLString(const QList<double>& doublelist)
 {
 	QString result;
-	QList<double>::const_iterator dax;
-	for (dax = doublelist.begin(); dax != doublelist.end(); ++dax)
-		result += toXMLString(*dax) + " ";
+	for (double dax : doublelist)
+		result += toXMLString(dax) + " ";
 	return result;
 }
 
 Xml_string toXMLString(const QList<float>& floatlist)
 {
 	QString result;
-	for (auto dax = floatlist.cbegin(); dax != floatlist.cend(); ++dax)
-		result += toXMLString(*dax) + " ";
+	for (float dax : floatlist)
+		result += toXMLString(dax) + " ";
 	return result;
 }
 
 QList<double> parseDoubleList(const Xml_string& str)
 {
-	QStringList strlist = str.split(' ', Qt::SkipEmptyParts);
+	const QStringList strlist = str.split(' ', Qt::SkipEmptyParts);
 	QList<double> result;
-	for (auto it = strlist.begin(); it != strlist.end(); ++it)
-		result.append(parseDouble(*it));
+	for (const QString& qStr : strlist)
+		result.append(parseDouble(qStr));
 	return result;
 }
 
 Xml_string toXMLString(const QVector<double>& doublelist)
 {
 	QString result;
-	for (auto dax = doublelist.cbegin(); dax != doublelist.cend(); ++dax)
-		result += toXMLString(*dax) + " ";
+	for (double dax : doublelist)
+		result += toXMLString(dax) + " ";
 	return result;
 }
 
 Xml_string toXMLString(const QVector<float>& floatlist)
 {
 	QString result;
-	for (auto dax = floatlist.cbegin(); dax != floatlist.cend(); ++dax)
-		result += toXMLString(*dax) + " ";
+	for (float dax : floatlist)
+		result += toXMLString(dax) + " ";
 	return result;
 }
 
 QVector<double> parseDoubleVector(const Xml_string& str)
 {
-	QStringList strlist = str.split(' ', Qt::SkipEmptyParts);
+	const QStringList strlist = str.split(' ', Qt::SkipEmptyParts);
 	QVector<double> result;
-	for (auto it = strlist.cbegin(); it != strlist.cend(); ++it)
-		result.append(parseDouble(*it));
+	for (const QString& qStr : strlist)
+		result.append(parseDouble(qStr));
 	return result;
 }
 
@@ -189,46 +188,46 @@ QVector<double> parseDoubleVector(const
 Xml_string toXMLString(const QList<int>& intlist)
 {
 	QString result;
-	for (auto dax = intlist.cbegin(); dax != intlist.cend(); ++dax)
-		result += toXMLString(*dax) + " ";
+	for (int dax : intlist)
+		result += toXMLString(dax) + " ";
 	return result;
 }
 
 
 QList<int> parseIntList(const Xml_string& str)
 {
-	QStringList strlist = str.split(' ', Qt::SkipEmptyParts);
+	const QStringList strlist = str.split(' ', Qt::SkipEmptyParts);
 	QList<int> result;
-	for (auto it = strlist.cbegin(); it != strlist.cend(); ++it)
-		result.append(parseInt(*it));
+	for (const QString& qStr : strlist)
+		result.append(parseInt(qStr));
 	return result;
 }
 
 Xml_string toXMLString(const QVector<int>& intlist)
 {
 	QString result;
-	for (auto dax = intlist.cbegin(); dax != intlist.cend(); ++dax)
-		result += toXMLString(*dax) + " ";
+	for (int dax : intlist)
+		result += toXMLString(dax) + " ";
 	return result;
 }
 
 
 QVector<int> parseIntVector(const Xml_string& str)
 {
-	QStringList strlist = str.split(' ', Qt::SkipEmptyParts);
+	const QStringList strlist = str.split(' ', Qt::SkipEmptyParts);
 	QVector<int> result;
-	for (auto it = strlist.cbegin(); it != strlist.cend(); ++it)
-		result.append(parseInt(*it));
+	for (const QString& qStr : strlist)
+		result.append(parseInt(qStr));
 	return result;
 }
 
 
 QStack<int> parseIntStack(const Xml_string& str)
 {
-	QStringList strlist = str.split(' ', Qt::SkipEmptyParts);
+	const QStringList strlist = str.split(' ', Qt::SkipEmptyParts);
 	QStack<int> result;
-	for (auto it = strlist.cbegin(); it != strlist.cend(); ++it)
-		result.append(parseInt(*it));
+	for (const QString& qStr : strlist)
+		result.append(parseInt(qStr));
 	return result;
 }
 
@@ -236,8 +235,8 @@ QStack<int> parseIntStack(const Xml_stri
 Xml_string toXMLString(const QStringList& list)
 {
 	QString result;
-	for (auto dax = list.cbegin(); dax != list.cend(); ++dax)
-		result += *dax + " ";
+	for (const QString& str : list)
+		result += str + " ";
 	return result;
 }
 
diff -Naupr scribus-1.6.2/scribus/exif.cpp scribus16x/scribus/exif.cpp
--- scribus-1.6.2/scribus/exif.cpp	2024-06-15 16:22:34.000000000 +0200
+++ scribus16x/scribus/exif.cpp	2025-01-04 10:59:08.843324068 +0100
@@ -928,7 +928,7 @@ bool ExifData::isThumbnailSane()
 // return a thumbnail that respects the orientation flag
 // only if it seems sane
 //--------------------------------------------------------------------------
-QImage ExifData::getThumbnail()
+QImage ExifData::getThumbnail() const
 {
 	if ( Thumbnail.isNull() )
 		return QImage(); // Qt4 NULL->QImage() is it sane?
diff -Naupr scribus-1.6.2/scribus/exif.h scribus16x/scribus/exif.h
--- scribus-1.6.2/scribus/exif.h	2024-06-15 16:22:35.000000000 +0200
+++ scribus16x/scribus/exif.h	2025-01-04 10:59:08.843324068 +0100
@@ -20,12 +20,12 @@ for which a new license (GPL+exception)
 #include <QFile>
 #include <QImage>
 
-typedef enum
+enum ReadMode_t
 {
 	READ_EXIF = 1,
 	READ_IMAGE = 2,
 	READ_ALL = 3
-} ReadMode_t;
+};
 
 //--------------------------------------------------------------------------
 // This structure is used to store jpeg file sections in memory.
@@ -38,7 +38,7 @@ typedef struct
 }
 Section_t;
 */
-typedef unsigned char uchar;
+using uchar = unsigned char;
 
 class TagTable
 {
@@ -57,29 +57,29 @@ class ExifData
 		ExifData() = default;
 
 		bool scan ( const QString & );
-		QString getCameraMake() { return CameraMake; }
-		QString getCameraModel() { return CameraModel; }
-		QString getDateTime() { return DateTime; }
-		int getOrientation() { return Orientation; }
-		int getHeight() { return Height; }
-		int getWidth() { return Width; }
-		int getIsColor() { return IsColor; }
-		int getProcess() { return Process; }
-		int getFlashUsed() { return FlashUsed; }
-		float getFocalLength() { return FocalLength; }
-		float getExposureTime() { return ExposureTime; }
-		float getApertureFNumber() { return ApertureFNumber; }
-		float getDistance() { return Distance; }
-		int getWhitebalance() { return Whitebalance; }
-		int getMeteringMode() { return MeteringMode; }
-		float getCCDWidth() { return CCDWidth; }
-		float getExposureBias() { return ExposureBias; }
-		int getExposureProgram() { return ExposureProgram; }
-		int getISOequivalent() { return ISOequivalent; }
-		int getCompressionLevel() { return CompressionLevel; }
-		QString getUserComment() { return UserComment; }
-		QString getComment() { return Comment; }
-		QImage getThumbnail();
+		QString getCameraMake() const { return CameraMake; }
+		QString getCameraModel() const { return CameraModel; }
+		QString getDateTime() const { return DateTime; }
+		int getOrientation() const { return Orientation; }
+		int getHeight() const { return Height; }
+		int getWidth() const { return Width; }
+		int getIsColor() const { return IsColor; }
+		int getProcess() const { return Process; }
+		int getFlashUsed() const { return FlashUsed; }
+		float getFocalLength() const { return FocalLength; }
+		float getExposureTime() const { return ExposureTime; }
+		float getApertureFNumber() const { return ApertureFNumber; }
+		float getDistance() const { return Distance; }
+		int getWhitebalance() const { return Whitebalance; }
+		int getMeteringMode() const { return MeteringMode; }
+		float getCCDWidth() const { return CCDWidth; }
+		float getExposureBias() const { return ExposureBias; }
+		int getExposureProgram() const { return ExposureProgram; }
+		int getISOequivalent() const { return ISOequivalent; }
+		int getCompressionLevel() const { return CompressionLevel; }
+		QString getUserComment() const { return UserComment; }
+		QString getComment() const { return Comment; }
+		QImage getThumbnail() const;
 		bool isThumbnailSane();
 		bool isNullThumbnail() { return !isThumbnailSane(); }
 
diff -Naupr scribus-1.6.2/scribus/fileloader.cpp scribus16x/scribus/fileloader.cpp
--- scribus-1.6.2/scribus/fileloader.cpp	2024-06-15 16:22:33.000000000 +0200
+++ scribus16x/scribus/fileloader.cpp	2025-01-04 10:59:08.679327490 +0100
@@ -4,25 +4,25 @@ to the COPYING file provided with the pr
 a copyright and/or license notice that predates the release of Scribus 1.3.2
 for which a new license (GPL+exception) is in place.
 */
+
+#include <cstdlib>
+#include <cmath>
+#include <zlib.h>
+
+#include <QCheckBox>
+#include <QCursor>
+#include <QDir>
 #include <QDomElement>
 #include <QFile>
 #include <QFileInfo>
-#include <QtAlgorithms>
-#include <QCursor>
-#include <QRegExp>
-#include <QDir>
-#include <QTextCodec>
-#include <QCheckBox>
+#include <QList>
 #include <QMessageBox>
 #include <QProgressBar>
-
-#include <QList>
-#include <cstdlib>
-#include <cmath>
+#include <QRegExp>
+#include <QtAlgorithms>
+#include <QTextCodec>
 #include <QTextStream>
 
-#include "scconfig.h"
-
 #include "commonstrings.h"
 #include "fileloader.h"
 #include "hyphenator.h"
@@ -32,6 +32,7 @@ for which a new license (GPL+exception)
 #include "prefsmanager.h"
 #include "resourcecollection.h"
 #include "scclocale.h"
+#include "scconfig.h"
 #include "scpage.h"
 #include "scribuscore.h"
 #include "scribusXml.h"
@@ -43,14 +44,6 @@ for which a new license (GPL+exception)
 #include "ui/fontreplacedialog.h"
 #include "ui/missing.h"
 
-// We need to include the headers for the plugins we support until we start
-// using LoadSavePlugin to pick them for us. We only use these headers to
-// get the format IDs, NOTHING ELSE.
-// #include "plugins/svgimplugin/svgplugin.h"
-// #include "plugins/psimport/importpsplugin.h"
-// #include "plugins/fileloader/oodraw/oodrawimp.h"
-#include <zlib.h>
-
 /*!
  \author Franz Schmid
  \date
diff -Naupr scribus-1.6.2/scribus/fonts/cff.h scribus16x/scribus/fonts/cff.h
--- scribus-1.6.2/scribus/fonts/cff.h	2024-06-15 16:22:33.000000000 +0200
+++ scribus16x/scribus/fonts/cff.h	2025-01-04 10:59:08.843324068 +0100
@@ -24,8 +24,8 @@
 
 namespace cff {
 	
-	typedef quint16 sid_type;
-	typedef uint operator_type;
+	using sid_type = quint16;
+	using operator_type = uint;
 	
 	enum sid_range {
 		sid_min = 0,
diff -Naupr scribus-1.6.2/scribus/fonts/scface.h scribus16x/scribus/fonts/scface.h
--- scribus-1.6.2/scribus/fonts/scface.h	2024-06-15 16:22:33.000000000 +0200
+++ scribus16x/scribus/fonts/scface.h	2025-01-04 10:59:08.843324068 +0100
@@ -84,16 +84,16 @@ public:
 		// handled by freetype:	PFB_MAC, DFONT, HQX, MACBIN,
 		SFNT, TTCF, UNKNOWN_FORMAT };
 
-	typedef uint cid_type;
-	typedef uint gid_type;
-	typedef uint ucs4_type;
+	using cid_type = uint;
+	using gid_type = uint;
+	using ucs4_type = uint;
 	struct GlyphEncoding
 	{
 		ucs4_type charcode {0};
 		QString glyphName;
 		QString toUnicode {"0000"};
 	};
-	typedef QMap<gid_type, GlyphEncoding> FaceEncoding;
+	using FaceEncoding = QMap<gid_type, GlyphEncoding>;
 
 	static const gid_type CONTROL_GLYPHS = 2000000000; // 2 billion
 
diff -Naupr scribus-1.6.2/scribus/gtaction.h scribus16x/scribus/gtaction.h
--- scribus-1.6.2/scribus/gtaction.h	2024-06-15 16:22:36.000000000 +0200
+++ scribus16x/scribus/gtaction.h	2025-01-04 10:59:08.863323650 +0100
@@ -51,7 +51,7 @@ class gtParagraphStyle;
 class gtFont;
 class gtFrameStyle;
 
-typedef QMap<QString, QString> FontFamilyMap;
+using FontFamilyMap = QMap<QString, QString>;
 
 class SCRIBUS_API gtAction
 {
diff -Naupr scribus-1.6.2/scribus/gtfont.h scribus16x/scribus/gtfont.h
--- scribus-1.6.2/scribus/gtfont.h	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/scribus/gtfont.h	2025-01-04 10:59:09.015320478 +0100
@@ -95,7 +95,7 @@ public:
 	gtFont(const gtFont& f);
 	~gtFont();
 
-	typedef enum
+	enum wasSetFlags
 	{
 		familyWasSet = 1,
 		weightWasSet = 2,
@@ -109,7 +109,7 @@ public:
 		strokeShadeWasSet = 512,
 		hscaleWasSet = 1024,
 		kerningWasSet = 2048
-	} wasSetFlags;
+	};
 
 	static const QString fontWeights[];
 	static const QString fontSlants[];
diff -Naupr scribus-1.6.2/scribus/gtgettext.cpp scribus16x/scribus/gtgettext.cpp
--- scribus-1.6.2/scribus/gtgettext.cpp	2024-06-15 16:22:34.000000000 +0200
+++ scribus16x/scribus/gtgettext.cpp	2025-01-04 10:59:08.864323629 +0100
@@ -36,13 +36,11 @@ for which a new license (GPL+exception)
 
 // Constructor
 gtGetText::gtGetText(ScribusDoc* doc)
+	     : m_Doc(doc)
 {
-	m_dias = nullptr;
-	// Attach to the active document
-	m_Doc = doc;
 	// Load the plugins array.
 	loadImporterPlugins();
-} // gtGetText::gtGetText(ScribusDoc* doc)
+}
 
 // Look at the results of the file selection dialog and figure out if you need to use an importer.
 // Prompt the user if the importer to use isn't obvious.
@@ -83,13 +81,14 @@ void gtGetText::launchImporter(int impor
 				ida = m_importers[m_dias->getImporter()];
 			// Destroy the diag
 			delete m_dias;
-		} // else - if (importerMap.find(fend) != importerMap.end())
+			m_dias = nullptr;
+		}
 	}
 	else // If we know which importer to use
 	{
 		// Copy the importer's struct to ida.
 		ida = m_importers[importer];
-	}	// else - if (importer == -1)
+	}
 	
 	// Create a target text frame for the imported text and assign it to the parameter "target"
 	PageItem* targetFrame = target;
@@ -103,8 +102,7 @@ void gtGetText::launchImporter(int impor
 	// Run the importer via "CallDLL" and pass it what it needs to know.
 	if (targetFrame != nullptr && callImporter)
 		CallDLL(ida, filename, encoding, textOnly, append, prefix, targetFrame);
-}  //void gtGetText::launchImporter(int importer, const QString& filename, bool textOnly, 
-   //						const QString& encoding, bool append, PageItem* target)
+}
 
 // Find the available plugins based on the environment, validate they load, and 
 // create quick lookup mappings.
@@ -142,12 +140,12 @@ void gtGetText::loadImporterPlugins()
 					ida.soFilePath = "/" + ida.soFilePath;
 				// Add the plugin data to the end of the importer's vector.
 				m_importers.push_back(ida);
-			}	// if (DLLName(d[dc], &ida.fileFormatName, &ida.fileEndings))
-		}  // for (uint dc = 0; dc < d.count(); ++dc)
-	}  // if ((d.exists()) && (d.count() != 0))
+			}
+		}
+	}
 	// Create the Importer Extension to Plugin data qmap.
 	createMap();
-}  // void gtGetText::loadImporterPlugins()
+}
 
 
 QStringList gtGetText::getSupportedTypes()
@@ -227,9 +225,10 @@ ImportSetup gtGetText::run()
 	}
 	// Destroy the dialog.
 	delete m_dias;
+	m_dias = nullptr;
 	// Return the ImportSetup struct.
 	return impsetup;
-}  // ImportSetup gtGetText::run()
+}
 
 // Loads, validates, and executes the Importer code.
 void gtGetText::CallDLL(const ImporterData& idata, const QString& filePath,
@@ -238,9 +237,9 @@ void gtGetText::CallDLL(const ImporterDa
 	// Pointer for the loaded plugin.
 	void* gtplugin;
 	// Type definition for GetText pointer in the function in question.
-	typedef void (*gt2ptr)(const QString& filename, const QString& encoding, bool textOnly, bool prefix, bool append, PageItem *textframe);
+	using gt2ptr = void (*)(const QString& filename, const QString& encoding, bool textOnly, bool prefix, bool append, PageItem *textframe);
 	// Type definition for GetText pointer in the function in question.
-	typedef void (*sdem)(const QString& filename, const QString& encoding, bool textOnly, gtWriter *writer);
+	using sdem = void (*)(const QString& filename, const QString& encoding, bool textOnly, gtWriter *writer);
 	// The point to the above.
 	gt2ptr fp_GetText2;
 	sdem fp_GetText;
@@ -253,7 +252,7 @@ void gtGetText::CallDLL(const ImporterDa
 	{
 		qWarning("Failed to load plugin %s", pluginFilePath.toLatin1().constData());
 		return;
-	} // if (!gtplugin)
+	}
 
 	fp_GetText2 = (gt2ptr) PluginManager::resolveSym(gtplugin,"GetText2");
 	if (fp_GetText2)
@@ -262,7 +261,7 @@ void gtGetText::CallDLL(const ImporterDa
 			importItem->itemText.clear();
 		// Execute the importer's "GetText2" method.
 		(*fp_GetText2)(filePath, encoding, textOnly, prefix, append, importItem);
-	}  // if (!fp_GetText2)        
+	}
 	else
 	{
 		// Attempt to map the old GetText method to to the pointer via the PluginManager. Store the result in fp_GetText.
@@ -271,12 +270,12 @@ void gtGetText::CallDLL(const ImporterDa
 		if (fp_GetText)
 		{
 			// Create a new writer object in "append"'s mode (true or false ) attached to the importItem
-			gtWriter *w = new gtWriter(append, importItem);
+			auto *w = new gtWriter(append, importItem);
 			// Execute the importer's "GetText" method.
 			(*fp_GetText)(filePath, encoding, textOnly, w);
 			// Destroy the writer
 			delete w;
-		}  // if (!fp_GetText)
+		}
 		else
 		{
 			qWarning("Failed to get GetText() from %s",pluginFilePath.toLatin1().constData());
@@ -286,8 +285,7 @@ void gtGetText::CallDLL(const ImporterDa
 	importItem->itemText.fixLegacyFormatting();
 	// Unload the plugin.
 	PluginManager::unloadDLL(gtplugin);
-}  // void gtGetText::CallDLL(const ImporterData& idata, const QString& filePath,
-   //                     const QString& encoding, bool textOnly, bool append, PageItem* importItem)
+}
 
 // Loads the "DLL", validates the importer is good, populates the passed parameters with 
 // the plugin information.
@@ -296,9 +294,9 @@ bool gtGetText::DLLName(const QString& n
 	// Pointer to the plugin, once loaded
 	void* gtplugin;
 	// typedef of Qstring to map the importer name (FileFormatName) method results to.
-	typedef QString (*sdem0)();
+	using sdem0 = QString (*)();
 	// typedef of QStringList to map the file extensions supported method results to.
-	typedef QStringList (*sdem1)();
+	using sdem1 = QStringList (*)();
 	// The actual importer name object
 	sdem0 fp_FileFormatName;
 	// The actual extensions supported object
@@ -341,23 +339,17 @@ bool gtGetText::DLLName(const QString& n
 	PluginManager::unloadDLL(gtplugin);
 	// Successfully return!
 	return true;
-}  // bool gtGetText::DLLName(QString name, QString *ffName, QStringList *fEndings)
+}
 
 // Create the importer Qmap.
 void gtGetText::createMap()
 {
 	// Loop through the importers Vector
-	for (uint i = 0; i < m_importers.size(); ++i)
+	for (ImporterData& importer : m_importers)
 	{
 		// Loop through each file extension the importer uses/importers and create an individual 
 		// Qmap entry for it.
-		for (int j = 0; j < m_importers[i].fileEndings.count(); ++j)
-				m_importerMap.insert(m_importers[i].fileEndings[j], &m_importers[i]);
-	}  // for (uint i = 0; i < importers.size(); ++i)
-}  // void gtGetText::createMap()
-
-// Destructor
-gtGetText::~gtGetText()
-{
-	// Nothing needs to happen here.
+		for (int j = 0; j < importer.fileEndings.count(); ++j)
+			m_importerMap.insert(importer.fileEndings[j], &importer);
+	}
 }
diff -Naupr scribus-1.6.2/scribus/gtgettext.h scribus16x/scribus/gtgettext.h
--- scribus-1.6.2/scribus/gtgettext.h	2024-06-15 16:22:34.000000000 +0200
+++ scribus16x/scribus/gtgettext.h	2025-01-04 10:59:08.864323629 +0100
@@ -66,6 +66,15 @@ struct ImportSetup {
 */
 class SCRIBUS_API gtGetText
 {
+public:
+	gtGetText(ScribusDoc* doc);					// Constructor
+
+	QStringList getSupportedTypes();			// get all Fileextensions we support
+	ImportSetup run();							// Creates the dialog for the user to import a file based on the supported file formats.
+	void launchImporter(int importer, const QString& filename, bool textOnly, const QString& encoding, bool append, bool prefix, PageItem* target = nullptr);
+	// Look at the results of the file selection dialog and figure out if you need to use an importer.
+	// Prompt the user if the importer to use isn't obvious.
+
 private:
 	std::vector<ImporterData> m_importers;		// Vector of the loaded importers
 	QMap<QString, ImporterData*> m_importerMap; 	// QMap of the supported extensions to their relevant importers entry for easy access
@@ -78,17 +87,10 @@ private:
 												// Loads the "DLL", validates the importer is good, populates the passed parameters with 
 												// the plugin information.
 	void createMap();							// Create the importer Qmap.
-	gtDialogs* m_dias;							// File Selection Dialog pointer.
-	QStringList m_ilist;							// List of supported importers, used with dialogs
-	ScribusDoc* m_Doc;							// Which document are we working with.
-public:
-	gtGetText(ScribusDoc* doc);					// Constructor
-	~gtGetText();								// Destructor
-	QStringList getSupportedTypes();			// get all Fileextensions we support
-	ImportSetup run();							// Creates the dialog for the user to import a file based on the supported file formats.
-	void launchImporter(int importer, const QString& filename, bool textOnly, const QString& encoding, bool append, bool prefix, PageItem* target = nullptr);
-												// Look at the results of the file selection dialog and figure out if you need to use an importer.
-												// Prompt the user if the importer to use isn't obvious.
+
+	gtDialogs* m_dias { nullptr };	// File Selection Dialog pointer.
+	QStringList m_ilist;			// List of supported importers, used with dialogs
+	ScribusDoc* m_Doc { nullptr };	// Which document are we working with.
 };
 
 #endif
diff -Naupr scribus-1.6.2/scribus/gtparagraphstyle.h scribus16x/scribus/gtparagraphstyle.h
--- scribus-1.6.2/scribus/gtparagraphstyle.h	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/scribus/gtparagraphstyle.h	2025-01-04 10:59:09.015320478 +0100
@@ -56,7 +56,7 @@ public:
 	gtParagraphStyle(const gtStyle& s);
 	~gtParagraphStyle() {};
 
-	typedef enum
+	enum wasSetFlags
 	{
 		lineSpacingWasSet = 1,
 		alignmentWasSet = 2,
@@ -72,7 +72,7 @@ public:
 		autoLineSpacingWasSet  = 2048,
 		bulletWasSet = 4096,
 		numWasSet = 8192
-	} wasSetFlags;
+	};
 
 	gtStyle& asGtStyle() { return dynamic_cast<gtStyle&>(*this); }
 	const gtStyle& asGtStyle() const { return dynamic_cast<const gtStyle&>(*this); }
diff -Naupr scribus-1.6.2/scribus/imagedataloaders/scimgdataloader.h scribus16x/scribus/imagedataloaders/scimgdataloader.h
--- scribus-1.6.2/scribus/imagedataloaders/scimgdataloader.h	2024-06-15 16:22:33.000000000 +0200
+++ scribus16x/scribus/imagedataloaders/scimgdataloader.h	2025-01-04 10:59:08.417332957 +0100
@@ -54,12 +54,12 @@ protected:
 	int             m_profileComponents;
 	eColorFormat    m_pixelFormat;
 
-	typedef enum
+	enum MsgType
 	{
 		noMsg = 0,
 		warningMsg = 1,
 		errorMsg = 2
-	} MsgType;
+	};
 	MsgType m_msgType;
 	QString m_message;
 
diff -Naupr scribus-1.6.2/scribus/imagedataloaders/scimgdataloader_jpeg.cpp scribus16x/scribus/imagedataloaders/scimgdataloader_jpeg.cpp
--- scribus-1.6.2/scribus/imagedataloaders/scimgdataloader_jpeg.cpp	2024-06-15 16:22:33.000000000 +0200
+++ scribus16x/scribus/imagedataloaders/scimgdataloader_jpeg.cpp	2025-01-04 10:59:08.417332957 +0100
@@ -120,15 +120,16 @@ bool ScImgDataLoader_JPEG::preloadAlphaC
 
 bool ScImgDataLoader_JPEG::loadPicture(const QString& fn, int /*page*/, int res, bool thumbnail)
 {
-//	bool isCMYK = false;
-	bool fromPS = false;
-	float xres = 72.0, yres = 72.0;
 	if (!QFile::exists(fn))
 		return false;
+
+	bool fromPS = false;
+	float xres = 72.0;
+	float yres = 72.0;
 	ExifData ExifInf;
 	struct jpeg_decompress_struct cinfo;
-	struct my_error_mgr         jerr;
-	FILE     *infile = nullptr;
+	struct my_error_mgr jerr;
+	FILE *infile = nullptr;
 	cinfo.err = jpeg_std_error (&jerr.pub);
 	jerr.pub.error_exit = my_error_exit;
 
@@ -150,11 +151,17 @@ bool ScImgDataLoader_JPEG::loadPicture(c
 	if ((infile = fopen (fn.toLocal8Bit(), "rb")) == nullptr)
 		return false;
 #endif
+
 	jpeg_stdio_src(&cinfo, infile);
 	jpeg_save_markers(&cinfo, ICC_MARKER, 0xFFFF);
 	jpeg_save_markers(&cinfo, PHOTOSHOP_MARKER, 0xFFFF);
 	jpeg_read_header(&cinfo, true);
+	// #17333: Some jpeg files present themselves as CMYK, but they are in fact YCCK encoded
+	// That case is not correctly handled by standard libjpeg, so workaround it
+	if ((cinfo.jpeg_color_space == JCS_CMYK) && (cinfo.saw_Adobe_marker) && (cinfo.Adobe_transform == 2))
+		cinfo.jpeg_color_space = JCS_YCCK;
 	jpeg_start_decompress(&cinfo);
+
 	bool exi = ExifInf.scan(fn);
 	if (exi && ExifInf.exifDataValid)
 	{
diff -Naupr scribus-1.6.2/scribus/langmgr.h scribus16x/scribus/langmgr.h
--- scribus-1.6.2/scribus/langmgr.h	2024-06-15 16:22:34.000000000 +0200
+++ scribus16x/scribus/langmgr.h	2025-01-04 10:59:08.864323629 +0100
@@ -30,7 +30,7 @@ for which a new license (GPL+exception)
 #include "langdef.h"
 #include "scribusapi.h"
 
-typedef std::pair<QString, QString> langPair;
+using langPair = std::pair<QString, QString>;
 
 class SCRIBUS_API LanguageManager
 {
diff -Naupr scribus-1.6.2/scribus/pageitem.cpp scribus16x/scribus/pageitem.cpp
--- scribus-1.6.2/scribus/pageitem.cpp	2024-06-15 16:22:32.000000000 +0200
+++ scribus16x/scribus/pageitem.cpp	2025-01-04 10:59:08.675327573 +0100
@@ -727,7 +727,7 @@ bool PageItem::isTableCell() const
 	return (dynamic_cast<PageItem_Table*>(Parent) != nullptr);
 }
 
-void PageItem::setXPos(const double newXPos, bool drawingOnly)
+void PageItem::setXPos(double newXPos, bool drawingOnly)
 {
 	m_xPos = newXPos;
 	if (drawingOnly || m_Doc->isLoading())
@@ -735,7 +735,7 @@ void PageItem::setXPos(const double newX
 	checkChanges();
 }
 
-void PageItem::setYPos(const double newYPos, bool drawingOnly)
+void PageItem::setYPos(double newYPos, bool drawingOnly)
 {
 	m_yPos = newYPos;
 	if (drawingOnly || m_Doc->isLoading())
@@ -743,7 +743,7 @@ void PageItem::setYPos(const double newY
 	checkChanges();
 }
 
-void PageItem::setXYPos(const double newXPos, const double newYPos, bool drawingOnly)
+void PageItem::setXYPos(double newXPos, double newYPos, bool drawingOnly)
 {
 	m_xPos = newXPos;
 	m_yPos = newYPos;
@@ -763,7 +763,7 @@ int PageItem::level() const
 	return (items->indexOf(thisItem) + 1);
 }
 
-void PageItem::moveBy(const double dX, const double dY, bool drawingOnly)
+void PageItem::moveBy(double dX, double dY, bool drawingOnly)
 {
 	//qDebug() << "pageitem::moveby" << dX << dY;
 	if (dX == 0.0 && dY == 0.0)
@@ -815,7 +815,7 @@ void PageItem::setWidthHeight(double new
 	checkChanges();
 }
 
-void PageItem::setWidthHeight(const double newWidth, const double newHeight)
+void PageItem::setWidthHeight(double newWidth, double newHeight)
 {
 	m_width = newWidth;
 	m_height = newHeight;
@@ -825,7 +825,7 @@ void PageItem::setWidthHeight(const doub
 	checkChanges();
 }
 
-void PageItem::resizeBy(const double dH, const double dW)
+void PageItem::resizeBy(double dH, double dW)
 {
 	if (dH == 0.0 && dW == 0.0)
 		return;
@@ -839,7 +839,7 @@ void PageItem::resizeBy(const double dH,
 	checkChanges();
 }
 
-void PageItem::setRotation(const double newRotation, bool drawingOnly)
+void PageItem::setRotation(double newRotation, bool drawingOnly)
 {
 	double dR = newRotation - m_rotation;
 	double oldRot = m_rotation;
@@ -854,7 +854,7 @@ void PageItem::setRotation(const double
 	checkChanges();
 }
 
-void PageItem::rotateBy(const double dR)
+void PageItem::rotateBy(double dR)
 {
 	if (dR==0.0)
 		return;
@@ -868,12 +868,12 @@ void PageItem::rotateBy(const double dR)
 	checkChanges();
 }
 
-void PageItem::setSelected(const bool toSelect)
+void PageItem::setSelected(bool toSelect)
 {
 	m_isSelected = toSelect;
 }
 
-void PageItem::setImageXScale(const double newImageXScale)
+void PageItem::setImageXScale(double newImageXScale)
 {
 	m_imageXScale = newImageXScale;
 	if (m_Doc->isLoading())
@@ -884,7 +884,7 @@ void PageItem::setImageXScale(const doub
 	checkChanges();
 }
 
-void PageItem::setImageYScale(const double newImageYScale)
+void PageItem::setImageYScale(double newImageYScale)
 {
 	m_imageYScale = newImageYScale;
 	if (m_Doc->isLoading())
@@ -895,7 +895,7 @@ void PageItem::setImageYScale(const doub
 	checkChanges();
 }
 
-void PageItem::setImageXYScale(const double newImageXScale, const double newImageYScale)
+void PageItem::setImageXYScale(double newImageXScale, double newImageYScale)
 {
 	m_imageXScale = newImageXScale;
 	m_imageYScale = newImageYScale;
@@ -908,7 +908,7 @@ void PageItem::setImageXYScale(const dou
 	checkChanges();
 }
 
-void PageItem::setImageXOffset(const double newImageXOffset)
+void PageItem::setImageXOffset(double newImageXOffset)
 {
 	m_imageXOffset = newImageXOffset;
 	if (m_Doc->isLoading())
@@ -919,7 +919,7 @@ void PageItem::setImageXOffset(const dou
 	checkChanges();
 }
 
-void PageItem::setImageYOffset(const double newImageYOffset)
+void PageItem::setImageYOffset(double newImageYOffset)
 {
 	m_imageYOffset = newImageYOffset;
 	if (m_Doc->isLoading())
@@ -930,7 +930,7 @@ void PageItem::setImageYOffset(const dou
 	checkChanges();
 }
 
-void PageItem::setImageXYOffset(const double newImageXOffset, const double newImageYOffset)
+void PageItem::setImageXYOffset(double newImageXOffset, double newImageYOffset)
 {
 	m_imageXOffset = newImageXOffset;
 	m_imageYOffset = newImageYOffset;
@@ -943,7 +943,7 @@ void PageItem::setImageXYOffset(const do
 	checkChanges();
 }
 
-void PageItem::moveImageXYOffsetBy(const double dX, const double dY)
+void PageItem::moveImageXYOffsetBy(double dX, double dY)
 {
 	if (dX==0.0 && dY==0.0)
 		return;
@@ -956,7 +956,7 @@ void PageItem::moveImageXYOffsetBy(const
 	checkChanges();
 }
 
-void PageItem::setImageRotation(const double newRotation)
+void PageItem::setImageRotation(double newRotation)
 {
 	if (m_imageRotation == newRotation)
 		return;
@@ -4176,6 +4176,20 @@ void PageItem::setImageScalingMode(bool
 	update();
 }
 
+void PageItem::setFillEvenOdd(bool val)
+{
+	if (fillRule == val)
+		return;
+
+	if (UndoManager::undoEnabled())
+	{
+		auto* ss = new SimpleState(Um::SetFillRule, nullptr, Um::IGroup);
+		ss->set("FILL_RULE", fillRule);
+		undoManager->action(this, ss);
+	}
+	fillRule = val;
+}
+
 void PageItem::setOverprint(bool val)
 {
 	if (doOverprint == val)
@@ -4855,6 +4869,8 @@ void PageItem::restore(UndoState *state,
 			restoreMove(ss, isUndo);
 		else if (ss->contains("FILL"))
 			restoreFill(ss, isUndo);
+		else if (ss->contains("FILL_RULE"))
+			restoreFillRule(ss, isUndo);
 		else if (ss->contains("SHADE"))
 			restoreShade(ss, isUndo);
 		else if (ss->contains("LINE_COLOR"))
@@ -6148,7 +6164,7 @@ void PageItem::restoreFillGradient(Simpl
 		fill_gradient = is->getOldState();
 	else
 		fill_gradient = is->getNewState();
-	if (gradientType() == 13)
+	if (gradientType() == Gradient_Conical)
 		createConicalMesh();
 	update();
 }
@@ -7285,6 +7301,16 @@ void PageItem::restoreFillTransparency(S
 	m_Doc->itemSelection_SetItemFillTransparency(tp, &tempSelection);
 }
 
+void PageItem::restoreFillRule(SimpleState* state, bool isUndo)
+{
+	bool oldFillRule = state->getBool("FILL_RULE");
+	if (isUndo)
+		fillRule = oldFillRule;
+	else
+		fillRule = !oldFillRule;
+	update();
+}
+
 void PageItem::restoreLineTP(SimpleState *state, bool isUndo)
 {
 	double tp = state->getDouble("OLD_TP");
diff -Naupr scribus-1.6.2/scribus/pageitem.h scribus16x/scribus/pageitem.h
--- scribus-1.6.2/scribus/pageitem.h	2024-06-15 16:22:32.000000000 +0200
+++ scribus16x/scribus/pageitem.h	2025-01-04 10:59:08.781325361 +0100
@@ -729,7 +729,7 @@ public: // Start public functions
 	void maskFlip(bool &flipX, bool &flipY) const;
 	//
 	bool fillEvenOdd() const { return fillRule; }
-	void setFillEvenOdd(bool val) { fillRule = val; }
+	void setFillEvenOdd(bool val);
 	//
 	bool overprint() const { return doOverprint; }
 	void setOverprint(bool val);
@@ -1570,6 +1570,7 @@ protected: // Start protected functions
 	void restoreFillPatternFlip(SimpleState *state, bool isUndo);
 	void restoreFillPatternTransform(SimpleState *state, bool isUndo);
 	void restoreFillTransparency(SimpleState *state, bool isUndo);
+	void restoreFillRule(SimpleState* state, bool isUndo);
 	void restoreFirstLineOffset(SimpleState *state, bool isUndo);
 	void restoreGetImage(UndoState *state, bool isUndo);
 	void restoreGradPos(SimpleState *state,bool isUndo);
diff -Naupr scribus-1.6.2/scribus/pageitem_textframe.cpp scribus16x/scribus/pageitem_textframe.cpp
--- scribus-1.6.2/scribus/pageitem_textframe.cpp	2024-06-15 16:22:32.000000000 +0200
+++ scribus16x/scribus/pageitem_textframe.cpp	2025-01-04 10:59:08.676327553 +0100
@@ -655,11 +655,21 @@ struct LineControl {
 		lineData.ascent = lineData.descent = 0;
 		if (glyphs.isEmpty())
 			return;
-		const CharStyle& cStyle(glyphs.at(0).style());
-		double scaleV = cStyle.scaleV() / 1000.0;
-		double offset = (cStyle.fontSize() / 10) * (cStyle.baselineOffset() / 1000.0);
-		lineData.ascent = cStyle.font().ascent(cStyle.fontSize() / 10.00) * scaleV + offset;
-		lineData.descent = cStyle.font().descent(cStyle.fontSize() / 10.00) * scaleV - offset;
+
+		// #17286 seek for largest glyph in line
+		for (int i = 0; i < glyphs.count(); i++)
+		{
+			const CharStyle& cStyle(glyphs.at(i).style());
+			double scaleV = cStyle.scaleV() / 1000.0;
+			double offset = (cStyle.fontSize() / 10) * (cStyle.baselineOffset() / 1000.0);
+			double tmpAscent = cStyle.font().ascent(cStyle.fontSize() / 10.00) * scaleV + offset;
+
+			if (lineData.ascent < tmpAscent)
+			{
+				lineData.ascent = tmpAscent;
+				lineData.descent = cStyle.font().descent(cStyle.fontSize() / 10.00) * scaleV;
+			}
+		}
 	}
 
 // yPos should not be changed when all line is already calculated - at new y position there can be overflow!!!
@@ -1508,9 +1518,9 @@ void PageItem_TextFrame::layout()
 			{
 				// unless at begin of par (eeks)
 				if ( (current.isEmpty) && (SpecialChars::isBreakingSpace(itemText.text(a)))
-					 && (a > 0 && ! SpecialChars::isBreak(itemText.text(a - 1)))
-					 && ! (a > 0 && SpecialChars::isBreakingSpace(itemText.text(a - 1))
-						   && (!glyphClusters[i - 1].hasFlag(ScLayout_SuppressSpace))))
+				     && (a > 0 && ! SpecialChars::isBreak(itemText.text(a - 1)))
+				     && ! (a > 0 && SpecialChars::isBreakingSpace(itemText.text(a - 1))
+				           && (i == 0 || !glyphClusters[i - 1].hasFlag(ScLayout_SuppressSpace))))
 				{
 					current.glyphs[currentIndex].setFlag(ScLayout_SuppressSpace);
 					continue;
diff -Naupr scribus-1.6.2/scribus/pagesize.h scribus16x/scribus/pagesize.h
--- scribus-1.6.2/scribus/pagesize.h	2024-06-15 16:22:36.000000000 +0200
+++ scribus16x/scribus/pagesize.h	2025-01-04 10:59:08.865323608 +0100
@@ -35,7 +35,7 @@ struct PageSizeInfo
 	int pageUnitIndex;
 };
 
-typedef QMap<QString, PageSizeInfo> PageSizeInfoMap;
+using PageSizeInfoMap = QMap<QString, PageSizeInfo>;
 
 class SCRIBUS_API PageSize
 {
diff -Naupr scribus-1.6.2/scribus/pagestructs.h scribus16x/scribus/pagestructs.h
--- scribus-1.6.2/scribus/pagestructs.h	2024-06-15 16:22:36.000000000 +0200
+++ scribus16x/scribus/pagestructs.h	2025-01-04 10:59:08.865323608 +0100
@@ -23,9 +23,9 @@ struct ObjectAttribute
 	QString autoaddto;
 };
 
-typedef QList<ObjectAttribute> ObjAttrVector;
+using ObjAttrVector = QList<ObjectAttribute>;
 
-typedef enum {Beginning, End, NotShown} TOCPageLocation;
+enum TOCPageLocation { Beginning, End, NotShown };
 
 struct ToCSetup
 {
@@ -39,7 +39,7 @@ struct ToCSetup
 	//QString pageNumberParaStyle; //Paragraph style for page numbers
 };
 
-typedef QList<ToCSetup> ToCSetupVector;
+using ToCSetupVector = QList<ToCSetup>;
 
 struct DocumentSection
 {
@@ -85,22 +85,22 @@ struct DocumentSection
 	}
 };
 
-typedef QMap<uint, DocumentSection> DocumentSectionMap;
+using DocumentSectionMap = QMap<uint, DocumentSection>;
 
-typedef enum
+enum PageLayout
 {
 	singlePage,
 	doublePage,
 	triplePage,
 	quadroPage
-} PageLayout;
+};
 
-typedef enum
+enum PageLocation
 {
 	LeftPage,
 	MiddlePage,
 	RightPage
-} PageLocation;
+};
 
 
 #endif
diff -Naupr scribus-1.6.2/scribus/palettes/cxfcolor.h scribus16x/scribus/palettes/cxfcolor.h
--- scribus-1.6.2/scribus/palettes/cxfcolor.h	2024-06-15 16:22:35.000000000 +0200
+++ scribus16x/scribus/palettes/cxfcolor.h	2025-01-04 10:59:08.865323608 +0100
@@ -34,11 +34,11 @@ public:
 	virtual void reset();
 	
 protected:
-	CxfDocument* m_cxfDoc;
-	const CxfColorSpecification* m_colorSpec;
+	CxfDocument* m_cxfDoc { nullptr };
+	const CxfColorSpecification* m_colorSpec { nullptr };
 };
 
-typedef QSharedPointer<CxfColor> CxfColorShPtr;
+using CxfColorShPtr = QSharedPointer<CxfColor>;
 
 class CxfColorRGB : public CxfColor
 {
@@ -51,10 +51,10 @@ public:
 	double  green() const { return m_values[1]; }
 	double  blue() const  { return m_values[2]; }
 	
-	virtual CxfColorType type() const { return cxfColorRGB; }
+	CxfColorType type() const override { return cxfColorRGB; }
 
-	virtual bool parse(QDomElement& colorElem);
-	virtual void reset();
+	bool parse(QDomElement& colorElem) override;
+	void reset() override;
 	
 protected:
 	double m_maxRange;
@@ -66,7 +66,7 @@ class CxfColorSRGB : public CxfColorRGB
 public:
 	CxfColorSRGB(CxfDocument* cxfDoc);
 
-	virtual CxfColorType type() const { return cxfColorSRGB; }
+	CxfColorType type() const override { return cxfColorSRGB; }
 };
 
 class CxfColorAdobeRGB : public CxfColorRGB
@@ -74,7 +74,7 @@ class CxfColorAdobeRGB : public CxfColor
 public:
 	CxfColorAdobeRGB(CxfDocument* cxfDoc);
 
-	virtual CxfColorType type() const { return cxfColorAdobeRGB; }
+	CxfColorType type() const override { return cxfColorAdobeRGB; }
 };
 
 class CxfColorHTML : public CxfColorRGB
@@ -82,8 +82,8 @@ class CxfColorHTML : public CxfColorRGB
 public:
 	CxfColorHTML(CxfDocument* cxfDoc);
 
-	virtual CxfColorType type() const { return cxfColorHTML; }
-	virtual bool parse(QDomElement& colorElem);
+	CxfColorType type() const override { return cxfColorHTML; }
+	bool parse(QDomElement& colorElem) override;
 };
 
 class CxfColorCMYK : public CxfColor
@@ -96,10 +96,10 @@ public:
 	double  yellow() const  { return m_values[2]; }
 	double  black() const   { return m_values[3]; }
 
-	virtual CxfColorType type() const { return cxfColorCMYK; }
+	CxfColorType type() const override { return cxfColorCMYK; }
 
-	virtual bool parse(QDomElement& colorElem);
-	virtual void reset();
+	bool parse(QDomElement& colorElem) override;
+	void reset() override;
 
 protected:
 	double m_values[4];
@@ -114,10 +114,10 @@ public:
 	double  a() const { return m_values[1]; }
 	double  b() const { return m_values[2]; }
 
-	virtual CxfColorType type() const { return cxfColorCIELab; }
+	CxfColorType type() const override { return cxfColorCIELab; }
 
-	virtual bool parse(QDomElement& colorElem);
-	virtual void reset();
+	bool parse(QDomElement& colorElem) override;
+	void reset() override;
 
 protected:
 	double m_values[3];
@@ -134,10 +134,10 @@ public:
 
 	ScLab lab() const;
 
-	virtual CxfColorType type() const { return cxfColorCIELCh; }
+	CxfColorType type() const override { return cxfColorCIELCh; }
 
-	virtual bool parse(QDomElement& colorElem);
-	virtual void reset();
+	bool parse(QDomElement& colorElem) override;
+	void reset() override;
 
 protected:
 	double m_values[3];
@@ -154,10 +154,10 @@ public:
 
 	ScLab lab() const;
 
-	virtual CxfColorType type() const { return cxfColorCIELCh; }
+	CxfColorType type() const override { return cxfColorCIELCh; }
 
-	virtual bool parse(QDomElement& colorElem);
-	virtual void reset();
+	bool parse(QDomElement& colorElem) override;
+	void reset() override;
 
 protected:
 	double m_values[3];
@@ -169,10 +169,10 @@ public:
 	CxfReflectanceSpectrum(CxfDocument* cxfDoc);
 
 	const QVector<double>& values() const { return m_values; }
-	virtual CxfColorType type() const { return cxfReflectanceSpectrum; }
+	CxfColorType type() const override { return cxfReflectanceSpectrum; }
 
-	virtual bool parse(QDomElement& colorElem);
-	virtual void reset();
+	bool parse(QDomElement& colorElem) override;
+	void reset() override;
 
 	int wavelengthStart() const;
 	int wavelengthIncrement() const;
diff -Naupr scribus-1.6.2/scribus/pdf_analyzer.cpp scribus16x/scribus/pdf_analyzer.cpp
--- scribus-1.6.2/scribus/pdf_analyzer.cpp	2024-06-15 16:22:35.000000000 +0200
+++ scribus16x/scribus/pdf_analyzer.cpp	2025-01-04 10:59:08.680327469 +0100
@@ -25,15 +25,36 @@ for which a new license (GPL+exception)
 #include <QtDebug>
 #include <QHash>
 #include <QStack>
+
 #include "pdf_analyzer.h"
 
 #ifdef HAVE_PODOFO
+
 using namespace PoDoFo;
 
 #if (PODOFO_VERSION < PODOFO_MAKE_VERSION(0, 10, 0))
 #define IsRealStrict IsReal
 #endif
 
+#if (PODOFO_VERSION >= PODOFO_MAKE_VERSION(1, 0, 0))
+#include <string_view>
+#include <utility>
+
+namespace std
+{
+	template<>
+	struct less<PoDoFo::PdfName>
+	{
+		bool operator()(const PoDoFo::PdfName& n1, const PoDoFo::PdfName& n2) const
+		{
+			std::string_view s1 = n1.GetRawData();
+			std::string_view s2 = n2.GetRawData();
+			return s1 < s2;
+		}
+	};
+}
+#endif
+
 static QHash<QString, PDFContentStreamKeyword> kwNameMap;
 
 // we gonna need a map from string values to the defined enum of pdf keywords
diff -Naupr scribus-1.6.2/scribus/pdflib_core.cpp scribus16x/scribus/pdflib_core.cpp
--- scribus-1.6.2/scribus/pdflib_core.cpp	2024-06-15 16:22:32.000000000 +0200
+++ scribus16x/scribus/pdflib_core.cpp	2025-01-04 10:59:08.780325382 +0100
@@ -612,10 +612,7 @@ bool PDFLibCore::doExport(const QString&
 		return false;
 	}
 
-	QMap<QString, QMap<uint, QString> > usedFonts;
-	doc.getUsedFonts(usedFonts);
-
-	if (PDF_Begin_Doc(fn, PrefsManager::instance().appPrefs.fontPrefs.AvailFonts, usedFonts, doc.scMW()->bookmarkPalette->BView))
+	if (PDF_Begin_Doc(fn, doc.scMW()->bookmarkPalette->BView))
 	{
 		QMap<int, int> pageNsMpa;
 		for (uint a = 0; a < pageNs.size(); ++a)
@@ -913,7 +910,7 @@ int PDFLibCore::WriteFlateImageToStream(
 	return (succeed ? bytesWritten : 0);
 }
 
-bool PDFLibCore::PDF_Begin_Doc(const QString& fn, SCFonts &AllFonts, const QMap<QString, QMap<uint, QString> >& DocFonts, BookmarkView* vi)
+bool PDFLibCore::PDF_Begin_Doc(const QString& fn, BookmarkView* vi)
 {
 	if (!writer.open(fn))
 		return false;
@@ -928,7 +925,7 @@ bool PDFLibCore::PDF_Begin_Doc(const QSt
 
 	PDF_Begin_Catalog();
 	PDF_Begin_MetadataAndEncrypt();
-	PDF_Begin_WriteUsedFonts(AllFonts, PDF_Begin_FindUsedFonts(DocFonts));
+	PDF_Begin_WriteUsedFonts(PDF_Begin_FindUsedFonts());
 	PDF_Begin_Colors();
 	PDF_Begin_Layers();
 	
@@ -1113,19 +1110,21 @@ void PDFLibCore::PDF_Begin_MetadataAndEn
 }
 
 QMap<QString, QMap<uint, QString> >
-PDFLibCore::PDF_Begin_FindUsedFonts(const QMap<QString, QMap<uint, QString> >& DocFonts)
+PDFLibCore::PDF_Begin_FindUsedFonts()
 {
-	QMap<QString, QMap<uint, QString> > usedFonts;
 	PageItem* pgit;
 	QMap<int, QByteArray> ind2PDFabr;
-	const QByteArray tmpf[] = {"/Courier", "/Courier-Bold", "/Courier-Oblique", "/Courier-BoldOblique",
-												"/Helvetica", "/Helvetica-Bold", "/Helvetica-Oblique", "/Helvetica-BoldOblique",
-												"/Times-Roman", "/Times-Bold", "/Times-Italic", "/Times-BoldItalic",
-												"/ZapfDingbats", "/Symbol"};
+	const QByteArray tmpf[] = { "/Courier", "/Courier-Bold", "/Courier-Oblique", "/Courier-BoldOblique",
+	                            "/Helvetica", "/Helvetica-Bold", "/Helvetica-Oblique", "/Helvetica-BoldOblique",
+	                            "/Times-Roman", "/Times-Bold", "/Times-Italic", "/Times-BoldItalic",
+	                            "/ZapfDingbats", "/Symbol" };
 	size_t ar = sizeof(tmpf) / sizeof(*tmpf);
 	for (uint ax = 0; ax < ar; ++ax)
 		ind2PDFabr[ax] = tmpf[ax];
 
+	QMap<QString, QMap<uint, QString> > usedFonts;
+	doc.getUsedFonts(usedFonts);
+
 	QList<PageItem*> allItems = doc.FrameItems.values();
 	while (allItems.count() > 0)
 	{
@@ -1135,29 +1134,18 @@ PDFLibCore::PDF_Begin_FindUsedFonts(cons
 			allItems = pgit->getChildren() + allItems;
 			continue;
 		}
-		if ((pgit->itemType() == PageItem::TextFrame) || (pgit->itemType() == PageItem::PathText))
+		if ((pgit->itemType() != PageItem::TextFrame) && (pgit->itemType() != PageItem::PathText))
+			continue;
+		if (!pgit->isAnnotation())
+			continue;
+		int annotType  = pgit->annotation().Type();
+		bool mustEmbed = ((annotType >= Annotation::Button) && (annotType <= Annotation::Listbox) && (annotType != Annotation::Checkbox));
+		if ((pgit->annotation().Type() == Annotation::Checkbox) || (pgit->annotation().Type() == Annotation::RadioButton))
+			StdFonts.insert("/ZapfDingbats", "");
+		if (pgit->itemText.length() > 0 || mustEmbed)
 		{
-			if (pgit->isAnnotation())
-			{
-				int annotType  = pgit->annotation().Type();
-				bool mustEmbed = ((annotType >= Annotation::Button) && (annotType <= Annotation::Listbox) && (annotType != Annotation::Checkbox));
-				if ((pgit->annotation().Type() == Annotation::Checkbox) || (pgit->annotation().Type() == Annotation::RadioButton))
-					StdFonts.insert("/ZapfDingbats", "");
-				if (pgit->itemText.length() > 0 || mustEmbed)
-				{
-					if (Options.Version < PDFVersion::PDF_14)
-						StdFonts.insert(ind2PDFabr[pgit->annotation().Font()], "");
-					QString replacementName = pgit->itemText.defaultStyle().charStyle().font().replacementName();
-					usedFonts.insert(replacementName, DocFonts[replacementName]);
-				}
-			}
-			uint start = pgit->isTextFrame() ? (uint) pgit->firstInFrame() : 0;
-			uint stop  = pgit->isTextFrame() ? (uint) pgit->lastInFrame() + 1 : (uint) pgit->itemText.length();
-			for (uint e = start; e < stop; ++e)
-			{
-				QString replacementName = pgit->itemText.charStyle(e).font().replacementName();
-				usedFonts.insert(replacementName, DocFonts[replacementName]);
-			}
+			if (Options.Version < PDFVersion::PDF_14)
+				StdFonts.insert(ind2PDFabr[pgit->annotation().Font()], "");
 		}
 	}
 
@@ -1170,29 +1158,18 @@ PDFLibCore::PDF_Begin_FindUsedFonts(cons
 			allItems = pgit->getChildren() + allItems;
 			continue;
 		}
-		if ((pgit->itemType() == PageItem::TextFrame) || (pgit->itemType() == PageItem::PathText))
+		if ((pgit->itemType() != PageItem::TextFrame) && (pgit->itemType() != PageItem::PathText))
+			continue;
+		if (!pgit->isAnnotation())
+			continue;
+		int annotType  = pgit->annotation().Type();
+		bool mustEmbed = ((annotType >= Annotation::Button) && (annotType <= Annotation::Listbox) && (annotType != Annotation::Checkbox));
+		if ((pgit->annotation().Type() == Annotation::Checkbox) || (pgit->annotation().Type() == Annotation::RadioButton))
+			StdFonts.insert("/ZapfDingbats", "");
+		if (pgit->itemText.length() > 0 || mustEmbed)
 		{
-			if (pgit->isAnnotation())
-			{
-				int annotType  = pgit->annotation().Type();
-				bool mustEmbed = ((annotType >= Annotation::Button) && (annotType <= Annotation::Listbox) && (annotType != Annotation::Checkbox));
-				if ((pgit->annotation().Type() == Annotation::Checkbox) || (pgit->annotation().Type() == Annotation::RadioButton))
-					StdFonts.insert("/ZapfDingbats", "");
-				if (pgit->itemText.length() > 0 || mustEmbed)
-				{
-					if (Options.Version < PDFVersion::PDF_14)
-						StdFonts.insert(ind2PDFabr[pgit->annotation().Font()], "");
-					QString replacementName = pgit->itemText.defaultStyle().charStyle().font().replacementName();
-					usedFonts.insert(replacementName, DocFonts[replacementName]);
-				}
-			}
-			uint start = pgit->isTextFrame() ? (uint) pgit->firstInFrame() : 0;
-			uint stop  = pgit->isTextFrame() ? (uint) pgit->lastInFrame() + 1 : (uint) pgit->itemText.length();
-			for (uint e = start; e < stop; ++e)
-			{
-				QString replacementName = pgit->itemText.charStyle(e).font().replacementName();
-				usedFonts.insert(replacementName, DocFonts[replacementName]);
-			}
+			if (Options.Version < PDFVersion::PDF_14)
+				StdFonts.insert(ind2PDFabr[pgit->annotation().Font()], "");
 		}
 	}
 
@@ -1205,35 +1182,21 @@ PDFLibCore::PDF_Begin_FindUsedFonts(cons
 			allItems = pgit->getChildren() + allItems;
 			continue;
 		}
-		if ((pgit->itemType() == PageItem::TextFrame) || (pgit->itemType() == PageItem::PathText))
+		if ((pgit->itemType() != PageItem::TextFrame) && (pgit->itemType() != PageItem::PathText))
+			continue;
+		if (!pgit->isAnnotation())
+			continue;
+		int annotType  = pgit->annotation().Type();
+		bool mustEmbed = ((annotType >= Annotation::Button) && (annotType <= Annotation::Listbox) && (annotType != Annotation::Checkbox));
+		if ((pgit->annotation().Type() == Annotation::Checkbox) || (pgit->annotation().Type() == Annotation::RadioButton))
+			StdFonts.insert("/ZapfDingbats", "");
+		if (pgit->itemText.length() > 0 || mustEmbed)
 		{
-			if (pgit->isAnnotation())
-			{
-				int annotType  = pgit->annotation().Type();
-				bool mustEmbed = ((annotType >= Annotation::Button) && (annotType <= Annotation::Listbox) && (annotType != Annotation::Checkbox));
-				if ((pgit->annotation().Type() == Annotation::Checkbox) || (pgit->annotation().Type() == Annotation::RadioButton))
-					StdFonts.insert("/ZapfDingbats", "");
-				if (pgit->itemText.length() > 0 || mustEmbed)
-				{
-					if (Options.Version < PDFVersion::PDF_14)
-						StdFonts.insert(ind2PDFabr[pgit->annotation().Font()], "");
-					QString replacementName = pgit->itemText.defaultStyle().charStyle().font().replacementName();
-					usedFonts.insert(replacementName, DocFonts[replacementName]);
-				}
-			}
-			uint start = pgit->isTextFrame() ? (uint) pgit->firstInFrame() : 0;
-			uint stop  = pgit->isTextFrame() ? (uint) pgit->lastInFrame() + 1 : (uint) pgit->itemText.length();
-			for (uint e = start; e < stop; ++e)
-			{
-				QString replacementName = pgit->itemText.charStyle(e).font().replacementName();
-				usedFonts.insert(replacementName, DocFonts[replacementName]);
-			}
+			if (Options.Version < PDFVersion::PDF_14)
+				StdFonts.insert(ind2PDFabr[pgit->annotation().Font()], "");
 		}
 	}
-/*	if (Options.docInfoMarks)
-	{
-		StdFonts.insert("/Helvetica", "");
-	} */
+
 	QStringList patterns = doc.getPatternDependencyList(doc.getUsedPatterns());
 	for (int c = 0; c < patterns.count(); ++c)
 	{
@@ -1247,27 +1210,16 @@ PDFLibCore::PDF_Begin_FindUsedFonts(cons
 				allItems = pgit->getChildren() + allItems;
 				continue;
 			}
-			if ((pgit->itemType() == PageItem::TextFrame) || (pgit->itemType() == PageItem::PathText))
+			if ((pgit->itemType() != PageItem::TextFrame) && (pgit->itemType() != PageItem::PathText))
+				continue;
+			if (!pgit->isAnnotation())
+				continue;
+			if ((pgit->annotation().Type() == Annotation::Checkbox) || (pgit->annotation().Type() == Annotation::RadioButton))
+				StdFonts.insert("/ZapfDingbats", "");
+			if (pgit->itemText.length() > 0)
 			{
-				if (pgit->isAnnotation())
-				{
-					if ((pgit->annotation().Type() == Annotation::Checkbox) || (pgit->annotation().Type() == Annotation::RadioButton))
-						StdFonts.insert("/ZapfDingbats", "");
-					if (pgit->itemText.length() > 0)
-					{
-						if (Options.Version < PDFVersion::PDF_14)
-							StdFonts.insert(ind2PDFabr[pgit->annotation().Font()], "");
-						QString replacementName = pgit->itemText.defaultStyle().charStyle().font().replacementName();
-						usedFonts.insert(replacementName, DocFonts[replacementName]);
-					}
-				}
-				uint start = pgit->isTextFrame() ? (uint) pgit->firstInFrame() : 0;
-				uint stop  = pgit->isTextFrame() ? (uint) pgit->lastInFrame() + 1 : (uint) pgit->itemText.length();
-				for (uint e = start; e < stop; ++e)
-				{
-					QString replacementName = pgit->itemText.charStyle(e).font().replacementName();
-					usedFonts.insert(replacementName, DocFonts[replacementName]);
-				}
+				if (Options.Version < PDFVersion::PDF_14)
+					StdFonts.insert(ind2PDFabr[pgit->annotation().Font()], "");
 			}
 		}
 	}
@@ -2323,16 +2275,18 @@ PdfId PDFLibCore::PDF_EmbedFontObject(co
 }
 
 
-void PDFLibCore::PDF_Begin_WriteUsedFonts(SCFonts &AllFonts, const QMap<QString, QMap<uint, QString> >& usedFonts)
+void PDFLibCore::PDF_Begin_WriteUsedFonts(const QMap<QString, QMap<uint, QString> >& usedFonts)
 {
 	qDebug() << "embed list:" << QStringList(Options.EmbedList).join(", ");
 	qDebug() << "subset list:" << QStringList(Options.SubsetList).join(", ");
 	qDebug() << "outline list:" << QStringList(Options.OutlineList).join(", ");
 
+	SCFonts& allFonts = PrefsManager::instance().appPrefs.fontPrefs.AvailFonts;
+
 	int a = 0;
 	for (auto it = usedFonts.cbegin(); it != usedFonts.cend(); ++it)
 	{
-		ScFace& face(AllFonts[it.key()]);
+		ScFace& face(allFonts[it.key()]);
 		ScFace::FontFormat fformat = face.format();
 		PdfFont pdfFont;
 		QByteArray fontName = QByteArray("Fo") + Pdf::toPdf(a);
diff -Naupr scribus-1.6.2/scribus/pdflib_core.h scribus16x/scribus/pdflib_core.h
--- scribus-1.6.2/scribus/pdflib_core.h	2024-06-15 16:22:33.000000000 +0200
+++ scribus16x/scribus/pdflib_core.h	2025-01-04 10:59:08.680327469 +0100
@@ -137,11 +137,11 @@ private:
 	bool PDF_IsPDFX() const;
 	bool PDF_IsPDFX(const PDFVersion& ver) const;
 
-	bool PDF_Begin_Doc(const QString& fn, SCFonts &AllFonts, const QMap<QString, QMap<uint, QString> >& DocFonts, BookmarkView* vi);
+	bool PDF_Begin_Doc(const QString& fn, BookmarkView* vi);
 	void PDF_Begin_Catalog();
 	void PDF_Begin_MetadataAndEncrypt();
-	QMap<QString, QMap<uint, QString> > PDF_Begin_FindUsedFonts(const QMap<QString, QMap<uint, QString> >& DocFonts);
-	void PDF_Begin_WriteUsedFonts(SCFonts &AllFonts, const QMap<QString, QMap<uint, QString> >& usedFonts);
+	QMap<QString, QMap<uint, QString> > PDF_Begin_FindUsedFonts();
+	void PDF_Begin_WriteUsedFonts(const QMap<QString, QMap<uint, QString> >& usedFonts);
 	void PDF_WriteStandardFonts();
 	PdfFont PDF_WriteType3Font(const QByteArray& name, ScFace& face, const QMap<uint, QString>& usedGlyphs);
 	PdfFont PDF_WriteGlyphsAsXForms(const QByteArray& fontName, const ScFace& face, const QMap<uint, QString>& usedGlyphs);
@@ -286,7 +286,7 @@ private:
 	PdfCatalog Catalog;
 	PdfPageData pageData;
 	PdfPageTree PageTree;
-	PdfOutlines Outlines;
+	PdfOutlinesIds Outlines;
 	Pdf::Writer writer;
 	QString baseDir;
 	
diff -Naupr scribus-1.6.2/scribus/pdfstructs.h scribus16x/scribus/pdfstructs.h
--- scribus-1.6.2/scribus/pdfstructs.h	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/scribus/pdfstructs.h	2025-01-04 10:59:08.680327469 +0100
@@ -17,10 +17,10 @@
 
 class PageItem;
 
-typedef uint PdfId;
+using PdfId = uint;
 
 namespace Pdf {
-	typedef QMap<QByteArray, PdfId> ResourceMap;
+	using ResourceMap = QMap<QByteArray, PdfId>;
 	
 	struct Resource
 	{
@@ -87,7 +87,7 @@ struct PdfPageData
 };
 
 
-struct PdfOutlines
+struct PdfOutlinesIds
 {
 	PdfId First;
 	PdfId Last;
diff -Naupr scribus-1.6.2/scribus/pluginmanager.h scribus16x/scribus/pluginmanager.h
--- scribus-1.6.2/scribus/pluginmanager.h	2024-06-15 16:22:35.000000000 +0200
+++ scribus16x/scribus/pluginmanager.h	2025-01-04 10:59:08.898322920 +0100
@@ -206,7 +206,7 @@ protected:
 	PrefsContext* prefs { nullptr };
 
 	/*! \brief Mapping of plugin names to plugin info structures. */
-	typedef QMap<QString,PluginData> PluginMap;
+	using PluginMap = QMap<QString, PluginData>;
 
 	/*! \brief Plugin mapping.
 	 * Each plugin has its record key() -> PluginData
diff -Naupr scribus-1.6.2/scribus/plugins/barcodegenerator/barcodegenerator.h scribus16x/scribus/plugins/barcodegenerator/barcodegenerator.h
--- scribus-1.6.2/scribus/plugins/barcodegenerator/barcodegenerator.h	2024-06-15 16:22:30.000000000 +0200
+++ scribus16x/scribus/plugins/barcodegenerator/barcodegenerator.h	2025-01-04 10:59:06.672369373 +0100
@@ -46,7 +46,7 @@ class BarcodeType
 
 
 //! \brief Type for BC name/BC type mapping.
-typedef QMap<QString, BarcodeType> BarcodeMap;
+using BarcodeMap = QMap<QString, BarcodeType>;
 
 
 /*! \brief Active tasts for BC GUI.
diff -Naupr scribus-1.6.2/scribus/plugins/colorwheel/colorwheelwidget.h scribus16x/scribus/plugins/colorwheel/colorwheelwidget.h
--- scribus-1.6.2/scribus/plugins/colorwheel/colorwheelwidget.h	2024-06-15 16:22:30.000000000 +0200
+++ scribus16x/scribus/plugins/colorwheel/colorwheelwidget.h	2025-01-04 10:59:06.686369081 +0100
@@ -16,7 +16,7 @@ for which a new license (GPL+exception)
 class ScribusDoc;
 
 /*! \brief Mapping angle - color in the color wheel */
-typedef QMap<int,ScColor> ColorMap;
+using ColorMap = QMap<int, ScColor>;
 
 /**
 \brief Widget ColorWheel graphically shows a color wheel for color theory.
@@ -199,11 +199,11 @@ class ColorWheel : public QLabel
 		\retval int index in the colorMap */
 		int valueFromPoint(const QPoint & p) const;
 
-		typedef struct
+		struct PaintPoint
 		{
 			int angle;
 			bool base;
-		} PaintPoint;
+		};
 		QList<PaintPoint> pointList;
 };
 
diff -Naupr scribus-1.6.2/scribus/plugins/fileloader/scribus134format/scribus134format.cpp scribus16x/scribus/plugins/fileloader/scribus134format/scribus134format.cpp
--- scribus-1.6.2/scribus/plugins/fileloader/scribus134format/scribus134format.cpp	2024-06-15 16:22:28.000000000 +0200
+++ scribus16x/scribus/plugins/fileloader/scribus134format/scribus134format.cpp	2025-01-04 10:59:05.819387176 +0100
@@ -2351,7 +2351,14 @@ bool Scribus134Format::readItemText(Page
 
 	if (attrs.hasAttribute(QLatin1String("Unicode")))
 	{
-		tmp2 = QChar(attrs.valueAsInt("Unicode"));
+		int uniValue = attrs.valueAsInt("Unicode");
+		if (uniValue >= 0 && uniValue <= 0xFFFF)
+			tmp2 = QChar(uniValue);
+		else
+		{
+			qDebug() << "scribus134format: invalid Unicode character detected:" << uniValue;
+			return true;
+		}
 	}
 	else
 	{
diff -Naupr scribus-1.6.2/scribus/plugins/fileloader/scribus150format/scribus150format.cpp scribus16x/scribus/plugins/fileloader/scribus150format/scribus150format.cpp
--- scribus-1.6.2/scribus/plugins/fileloader/scribus150format/scribus150format.cpp	2024-06-15 16:22:28.000000000 +0200
+++ scribus16x/scribus/plugins/fileloader/scribus150format/scribus150format.cpp	2025-01-04 10:59:05.947384505 +0100
@@ -587,8 +587,7 @@ bool Scribus150Format::loadElements(cons
 
 		if (itemNext.count() != 0)
 		{
-			QMap<int,int>::Iterator lc;
-			for (lc = itemNext.begin(); lc != itemNext.end(); ++lc)
+			for (auto lc = itemNext.begin(); lc != itemNext.end(); ++lc)
 			{
 				if (lc.value() >= 0)
 				{
@@ -696,8 +695,7 @@ bool Scribus150Format::loadElements(cons
 		// reestablish textframe links
 		if (itemNext.count() != 0)
 		{
-			QMap<int,int>::Iterator lc;
-			for (lc = itemNext.begin(); lc != itemNext.end(); ++lc)
+			for (auto lc = itemNext.begin(); lc != itemNext.end(); ++lc)
 			{
 				if (lc.value() >= 0)
 				{
@@ -1313,8 +1311,7 @@ bool Scribus150Format::loadPalette(const
 		}
 		if (itemNext.count() != 0)
 		{
-			QMap<int,int>::Iterator lc;
-			for (lc = itemNext.begin(); lc != itemNext.end(); ++lc)
+			for (auto lc = itemNext.begin(); lc != itemNext.end(); ++lc)
 			{
 				if (lc.value() >= 0)
 				{
@@ -1418,8 +1415,7 @@ bool Scribus150Format::loadPalette(const
 		// reestablish textframe links
 		if (itemNext.count() != 0)
 		{
-			QMap<int,int>::Iterator lc;
-			for (lc = itemNext.begin(); lc != itemNext.end(); ++lc)
+			for (auto lc = itemNext.begin(); lc != itemNext.end(); ++lc)
 			{
 				if (lc.value() >= 0)
 				{
@@ -1439,8 +1435,7 @@ bool Scribus150Format::loadPalette(const
 		}
 		if (itemNextM.count() != 0)
 		{
-			QMap<int,int>::Iterator lc;
-			for (lc = itemNextM.begin(); lc != itemNextM.end(); ++lc)
+			for (auto lc = itemNextM.begin(); lc != itemNextM.end(); ++lc)
 			{
 				if (lc.value() >= 0)
 				{
@@ -1983,8 +1978,7 @@ bool Scribus150Format::loadFile(const QS
 		return false;
 	}
 
-	QMap<int, ScribusDoc::BookMa>::Iterator it;
-	for (it = bookmarks.begin(); it != bookmarks.end(); ++it)
+	for (auto it = bookmarks.begin(); it != bookmarks.end(); ++it)
 	{
 		int elem = it.key();
 		PageItem* item = LinkID.value(elem, (PageItem*) nullptr);
@@ -2037,8 +2031,7 @@ bool Scribus150Format::loadFile(const QS
 		}
 		if (itemNext.count() != 0)
 		{
-			QMap<int,int>::Iterator lc;
-			for (lc = itemNext.begin(); lc != itemNext.end(); ++lc)
+			for (auto lc = itemNext.begin(); lc != itemNext.end(); ++lc)
 			{
 				if (lc.value() >= 0)
 				{
@@ -2141,8 +2134,7 @@ bool Scribus150Format::loadFile(const QS
 		}
 		if (itemNext.count() != 0)
 		{
-			QMap<int,int>::Iterator lc;
-			for (lc = itemNext.begin(); lc != itemNext.end(); ++lc)
+			for (auto lc = itemNext.begin(); lc != itemNext.end(); ++lc)
 			{
 				if (lc.value() >= 0)
 				{
@@ -2162,8 +2154,7 @@ bool Scribus150Format::loadFile(const QS
 		}
 		if (itemNextM.count() != 0)
 		{
-			QMap<int,int>::Iterator lc;
-			for (lc = itemNextM.begin(); lc != itemNextM.end(); ++lc)
+			for (auto lc = itemNextM.begin(); lc != itemNextM.end(); ++lc)
 			{
 				if (lc.value() >= 0)
 				{
@@ -5024,7 +5015,14 @@ bool Scribus150Format::readItemText(Stor
 
 	if (attrs.hasAttribute(QLatin1String("Unicode")))
 	{
-		tmp2 = QChar(attrs.valueAsInt("Unicode"));
+		int uniValue = attrs.valueAsInt("Unicode");
+		if (uniValue >= 0 && uniValue <= 0xFFFF)
+			tmp2 = QChar(uniValue);
+		else
+		{
+			qDebug() << "scribus150format: invalid Unicode character detected:" << uniValue;
+			return true;
+		}
 	}
 	else
 	{
@@ -5374,14 +5372,14 @@ PageItem* Scribus150Format::pasteItem(Sc
 	currItem->setGroupClipping(attrs.valueAsBool("groupClips", true));
 	currItem->FrameType = attrs.valueAsInt("FRTYPE", 0);
 	int startArrowIndex = attrs.valueAsInt("startArrowIndex", 0);
-	if ((startArrowIndex < 0) || (startArrowIndex > static_cast<int>(doc->arrowStyles().size())))
+	if ((startArrowIndex < 0) || (startArrowIndex > doc->arrowStyles().size()))
 	{
 		qDebug() << QString("scribus150format: invalid arrow index: %").arg(startArrowIndex);
 		startArrowIndex = 0;
 	}
 	currItem->setStartArrowIndex(startArrowIndex);
 	int endArrowIndex = attrs.valueAsInt("endArrowIndex", 0);
-	if ((endArrowIndex < 0) || (endArrowIndex > static_cast<int>(doc->arrowStyles().size())))
+	if ((endArrowIndex < 0) || (endArrowIndex > doc->arrowStyles().size()))
 	{
 		qDebug() << QString("scribus150format: invalid arrow index: %").arg(endArrowIndex);
 		endArrowIndex = 0;
@@ -5637,7 +5635,7 @@ PageItem* Scribus150Format::pasteItem(Sc
 		{
 			QStringList slRowHeights = rowHeights.split(" ");
 			int i = 0;
-			foreach(const QString& pos, slRowHeights)
+			for (const QString& pos : slRowHeights)
 			{
 				tableitem->resizeRow(i, pos.toDouble());
 				++i;
@@ -5649,7 +5647,7 @@ PageItem* Scribus150Format::pasteItem(Sc
 		{
 			QStringList slColWidths = colWidths.split(" ");
 			int i = 0;
-			foreach(const QString& pos, slColWidths)
+			for (const QString& pos : slColWidths)
 			{
 				tableitem->resizeColumn(i, pos.toDouble());
 				++i;
@@ -6819,8 +6817,7 @@ bool Scribus150Format::loadPage(const QS
 		return false;
 	}
 
-	QMap<int, ScribusDoc::BookMa>::Iterator it;
-	for (it = bookmarks.begin(); it != bookmarks.end(); ++it)
+	for (auto it = bookmarks.begin(); it != bookmarks.end(); ++it)
 	{
 		int elem = it.key();
 		PageItem* item = LinkID.value(elem, (PageItem*) nullptr);
@@ -6872,8 +6869,7 @@ bool Scribus150Format::loadPage(const QS
 		}
 		if (itemNext.count() != 0)
 		{
-			QMap<int,int>::Iterator lc;
-			for (lc = itemNext.begin(); lc != itemNext.end(); ++lc)
+			for (auto lc = itemNext.begin(); lc != itemNext.end(); ++lc)
 			{
 				if (lc.value() >= 0)
 				{
@@ -6931,8 +6927,7 @@ bool Scribus150Format::loadPage(const QS
 		// reestablish textframe links
 		if (itemNext.count() != 0 && !Mpage)
 		{
-			QMap<int,int>::Iterator lc;
-			for (lc = itemNext.begin(); lc != itemNext.end(); ++lc)
+			for (auto lc = itemNext.begin(); lc != itemNext.end(); ++lc)
 			{
 				if (itemRemap[lc.value()] >= 0)
 				{
@@ -6952,8 +6947,7 @@ bool Scribus150Format::loadPage(const QS
 		}
 		else if (itemNextM.count() != 0 && Mpage)
 		{
-			QMap<int,int>::Iterator lc;
-			for (lc = itemNextM.begin(); lc != itemNextM.end(); ++lc)
+			for (auto lc = itemNextM.begin(); lc != itemNextM.end(); ++lc)
 			{
 				if (itemRemapM[lc.value()] >= 0)
 				{
@@ -7395,9 +7389,8 @@ void Scribus150Format::updateNames2Ptr()
 {
 	if (!markeredItemsMap.isEmpty())
 	{
-		QMap<Mark*, int>::Iterator markIt;
 		QMap<Mark*, int>::Iterator end = markeredItemsMap.end();
-		for (markIt = markeredItemsMap.begin(); markIt != end; ++markIt)
+		for (auto markIt = markeredItemsMap.begin(); markIt != end; ++markIt)
 		{
 			Mark* mrk = markIt.key();
 			int ItemID = markIt.value();
@@ -7493,9 +7486,8 @@ void Scribus150Format::updateNames2Ptr()
 	if (!notesMasterMarks.isEmpty())
 	{
 		assert(!m_Doc->marksList().isEmpty() && !m_Doc->notesList().isEmpty());
-		QMap<QString, TextNote*>::Iterator it;
 		QMap<QString, TextNote*>::Iterator end = notesMasterMarks.end();
-		for (it = notesMasterMarks.begin(); it != end; ++it)
+		for (auto it = notesMasterMarks.begin(); it != end; ++it)
 		{
 			TextNote* note = it.value();
 			assert(note != nullptr);
diff -Naupr scribus-1.6.2/scribus/plugins/gettext/htmlim/htmlreader.h scribus16x/scribus/plugins/gettext/htmlim/htmlreader.h
--- scribus-1.6.2/scribus/plugins/gettext/htmlim/htmlreader.h	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/gettext/htmlim/htmlreader.h	2025-01-04 10:59:05.609391559 +0100
@@ -37,7 +37,7 @@ for which a new license (GPL+exception)
 #include <gtparagraphstyle.h>
 #include <gtwriter.h>
 
-typedef QMap<QString, QString> HTMLAttributesMap;
+using HTMLAttributesMap = QMap<QString, QString>;
 
 /*! \brief Parse and import a HTML file.
 Supported tags: P, CENTER, BR, A, UL, OL, LI, H1, H2, H3, H4,
diff -Naupr scribus-1.6.2/scribus/plugins/gettext/odt2im/importodt.cpp scribus16x/scribus/plugins/gettext/odt2im/importodt.cpp
--- scribus-1.6.2/scribus/plugins/gettext/odt2im/importodt.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/gettext/odt2im/importodt.cpp	2025-01-04 10:59:05.600391747 +0100
@@ -14,6 +14,7 @@ for which a new license (GPL+exception)
 
 #include <QApplication>
 #include <QByteArray>
+#include <QDebug>
 #include <QScopedPointer>
 
 #include "scribusdoc.h"
@@ -459,6 +460,7 @@ void ODTIm::parseStyles(const QDomElemen
 					currStyle.textStrikeThrough = AttributeValue(spe.attribute("style:text-line-through-style", ""));
 					currStyle.textShadow = AttributeValue(spe.attribute("fo:text-shadow", ""));
 					currStyle.fontVariant = AttributeValue(spe.attribute("fo:font-variant", ""));
+					currStyle.language = AttributeValue(spe.attribute("fo:language", ""));
 				}
 			}
 			if (spd.attribute("style:family") == "paragraph")
@@ -539,6 +541,7 @@ void ODTIm::parseStyles(const QDomElemen
 					currStyle.textStrikeThrough = AttributeValue(spe.attribute("style:text-line-through-style", ""));
 					currStyle.textShadow = AttributeValue(spe.attribute("fo:text-shadow", ""));
 					currStyle.fontVariant = AttributeValue(spe.attribute("fo:font-variant", ""));
+					currStyle.language = AttributeValue(spe.attribute("fo:language", ""));
 				}
 			}
 			currStyle.displayName = AttributeValue(spd.attribute("style:display-name", ""));
@@ -571,7 +574,7 @@ void ODTIm::parseStyles(const QDomElemen
 								parentName = pStyle.displayName.value;
 						}
 					}
-					if (m_prefixName)
+					if (m_prefixName && (parentName != CommonStrings::DefaultParagraphStyle))
 						newStyle.setParent(m_item->itemName() + "_" + parentName);
 					else
 						newStyle.setParent(parentName);
@@ -676,6 +679,27 @@ void ODTIm::parseTextSpan(const QDomElem
 	if (textStyleName.length() > 0)
 	{
 		resolveStyle(odtStyle, textStyleName);
+		if (m_Styles.contains(textStyleName))
+		{
+			DrawStyle currStyle = m_Styles[textStyleName];
+			if (currStyle.styleOrigin.value == "styles")
+			{
+				QString charStyleName;
+				if (m_prefixName)
+				{
+					charStyleName = m_item->itemName() + "_" + textStyleName;
+					if (currStyle.displayName.valid)
+						charStyleName = m_item->itemName() + "_" + currStyle.displayName.value;
+				}
+				else
+				{
+					charStyleName = textStyleName;
+					if (currStyle.displayName.valid)
+						charStyleName = currStyle.displayName.value;
+				}
+				cStyle.setParent(charStyleName);
+			}
+		}
 		m_textStylesStack.push(textStyleName);
 	}
 	
@@ -969,6 +993,7 @@ void ODTIm::applyCharacterStyle(CharStyl
 	tmpCStyle.setFontSize(oStyle.fontSize * 10);
 	tmpCStyle.setFillColor(oStyle.CurrColorText);
 	tmpCStyle.setBackColor(oStyle.CurrColorBText);
+	tmpCStyle.setLanguage(oStyle.language);
 	StyleFlag styleEffects = tmpCStyle.effects();
 	if ((oStyle.textPos.startsWith("super")) || (oStyle.textPos.startsWith("sub")))
 	{
@@ -1126,6 +1151,8 @@ void ODTIm::resolveStyle(ObjStyleODT &tm
 			actStyle.breakAfter = AttributeValue(currStyle.breakAfter.value);
 		if (currStyle.breakBefore.valid)
 			actStyle.breakBefore = AttributeValue(currStyle.breakBefore.value);
+		if (currStyle.language.valid)
+			actStyle.language = AttributeValue(currStyle.language.value);
 	}
 
 	if (actStyle.textBackgroundColor.valid)
@@ -1312,6 +1339,8 @@ void ODTIm::resolveStyle(ObjStyleODT &tm
 		tmpOStyle.breakAfter = actStyle.breakAfter.value;
 	if (actStyle.breakBefore.valid)
 		tmpOStyle.breakBefore = actStyle.breakBefore.value;
+	if (actStyle.language.valid)
+		tmpOStyle.language = actStyle.language.value;
 }
 
 double ODTIm::parseUnit(const QString &unit)
diff -Naupr scribus-1.6.2/scribus/plugins/gettext/odt2im/importodt.h scribus16x/scribus/plugins/gettext/odt2im/importodt.h
--- scribus-1.6.2/scribus/plugins/gettext/odt2im/importodt.h	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/gettext/odt2im/importodt.h	2025-01-04 10:59:05.600391747 +0100
@@ -61,6 +61,7 @@ public:
 	QList<ParagraphStyle::TabRecord> tabStops;
 	QString breakBefore {"auto"};
 	QString breakAfter {"auto"};
+	QString language;
 };
 
 class ODTIm
@@ -103,6 +104,7 @@ private:
 		AttributeValue tabTypes;
 		AttributeValue breakBefore;
 		AttributeValue breakAfter;
+		AttributeValue language;
 	};
 	bool parseRawDocReference(const QString& designMap);
 	bool parseRawDocReferenceXML(const QDomDocument &designMapDom);
diff -Naupr scribus-1.6.2/scribus/plugins/gettext/pdbim/pdbim.h scribus16x/scribus/plugins/gettext/pdbim/pdbim.h
--- scribus-1.6.2/scribus/plugins/gettext/pdbim/pdbim.h	2024-06-15 16:22:26.000000000 +0200
+++ scribus16x/scribus/plugins/gettext/pdbim/pdbim.h	2025-01-04 10:59:05.644390829 +0100
@@ -21,14 +21,14 @@ extern "C" PLUGIN_API QString FileFormat
 extern "C" PLUGIN_API QStringList FileExtensions();
 
 /*! \brief Abiword's internal data types */
-typedef unsigned int UT_uint32;
-typedef unsigned short UT_uint16;
+using UT_uint32 = unsigned int;
+using UT_uint16 = unsigned short;
 
 /*! \brief Define integral type Byte, Word, and DWord to match those on the
 Pilot being 8, 16, and 32 bits, respectively. Max  8-bit unsigned */
-typedef unsigned char Byte;
-typedef UT_uint16 Word;
-typedef UT_uint32 DWord;
+using Byte = unsigned char;
+using Word = UT_uint16;
+using DWord = UT_uint32;
 
 /*! \brief Pilots have a fixed 4K record size */
 #define RECORD_SIZE_MAX	4096
@@ -51,7 +51,7 @@ position  4 bytes  currently viewed posi
 sizes  2*records bytes  record size array
 78 bytes total
 */
-typedef struct
+struct pdb_header
 {
 	char	name[ dmDBNameLength ];
 	Word	attributes;
@@ -67,7 +67,7 @@ typedef struct
 	DWord	id_seed;
 	DWord	nextRecordList;
 	Word	numRecords;
-} pdb_header;
+};
 
 /*! \brief Some compilers pad structures out to DWord boundaries so using
 sizeof() doesn't give the intended result.
@@ -77,21 +77,23 @@ sizeof() doesn't give the intended resul
 
 /*! \brief PDB Document record.
 16 bytes total. */
-typedef struct {
+struct doc_record0
+{
 	Word    version; /* 1 = plain text, 2 = compressed */
 	Word    reserved1;
 	DWord   doc_size; /* in bytes, when uncompressed */
 	Word    numRecords; /* text rec's only; = pdb_header.numRecords-1 */
 	Word    rec_size; /* usually RECORD_SIZE_MAX */
 	DWord   reserved2;
-} doc_record0;
+};
 
 /*! \brief Binary buffer */
-typedef struct {
+struct buffer
+{
 	Byte buf[BUFFER_SIZE];
 	size_t   len;
 	size_t   position;
-} buffer;
+};
 
 #define GET_Word(f,n)   { size_t result = fread( &n, 2, 1, f ); if (result == 1) n = swap_Word ( n ); }
 #define GET_DWord(f,n)  { size_t result = fread( &n, 4, 1, f ); if (result == 1) n = swap_DWord( n ); }
diff -Naupr scribus-1.6.2/scribus/plugins/import/ai/importai.cpp scribus16x/scribus/plugins/import/ai/importai.cpp
--- scribus-1.6.2/scribus/plugins/import/ai/importai.cpp	2024-06-15 16:22:26.000000000 +0200
+++ scribus16x/scribus/plugins/import/ai/importai.cpp	2025-01-04 10:59:04.710410323 +0100
@@ -609,19 +609,19 @@ bool AIPlug::extractFromPDF(const QStrin
 					num = 99999;
 				QString name = "AIPrivateData%1";
 				QString Key = name.arg(1);
-				PoDoFo::PdfObject* data = privDict ? privDict->FindKey(PoDoFo::PdfName(Key.toUtf8().data())) : nullptr;
+				PoDoFo::PdfObject* data = privDict ? privDict->FindKey(PoDoFo::PdfName(Key.toUtf8().constData())) : nullptr;
 				if (data == nullptr)
 				{
 					name = "AIPDFPrivateData%1";
 					Key = name.arg(1);
-					data = privDict ? privDict->FindKey(PoDoFo::PdfName(Key.toUtf8().data())) : nullptr;
+					data = privDict ? privDict->FindKey(PoDoFo::PdfName(Key.toUtf8().constData())) : nullptr;
 				}
 				if (data != nullptr)
 				{
 					if (num == 2)
 					{
 						Key = name.arg(1);
-						data = privDict->FindKey(PoDoFo::PdfName(Key.toUtf8().data()));
+						data = privDict->FindKey(PoDoFo::PdfName(Key.toUtf8().constData()));
 						PoDoFo::PdfObjectStream const* stream = data->GetStream();
 						PoDoFo::charbuff strBuffer = stream->GetCopy(false);
 						qint64 bLen = strBuffer.size();
@@ -633,7 +633,7 @@ bool AIPlug::extractFromPDF(const QStrin
 						for (int a = 2; a < num; a++)
 						{
 							Key = name.arg(a);
-							data = privDict->FindKey(PoDoFo::PdfName(Key.toUtf8().data()));
+							data = privDict->FindKey(PoDoFo::PdfName(Key.toUtf8().constData()));
 							if (data == nullptr)
 								break;
 							PoDoFo::PdfObjectStream const* stream = data->GetStream();
diff -Naupr scribus-1.6.2/scribus/plugins/import/cdr/importcdr.cpp scribus16x/scribus/plugins/import/cdr/importcdr.cpp
--- scribus-1.6.2/scribus/plugins/import/cdr/importcdr.cpp	2024-06-15 16:22:26.000000000 +0200
+++ scribus16x/scribus/plugins/import/cdr/importcdr.cpp	2025-01-04 10:59:04.819408048 +0100
@@ -349,7 +349,7 @@ bool CdrPlug::convert(const QString& fn)
 			{
 				ScribusMainWindow* mw=(m_Doc==0) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 				qApp->changeOverrideCursor(QCursor(Qt::ArrowCursor));
-				ScMessageBox::warning(mw, CommonStrings::trWarning, tr("Parsing failed!\n\nPlease submit your file (if possible) to the\nDocument Liberation Project http://www.documentliberation.org"));
+				ScMessageBox::warning(mw, CommonStrings::trWarning, tr("Parsing failed!\n\nPlease submit your file (if possible) to the\nDocument Liberation Project https://www.documentliberation.org"));
 				qApp->changeOverrideCursor(QCursor(Qt::WaitCursor));
 			}*/
 			return false;
@@ -372,7 +372,7 @@ bool CdrPlug::convert(const QString& fn)
 			{
 				ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 				QGuiApplication::changeOverrideCursor(QCursor(Qt::ArrowCursor));
-				ScMessageBox::warning(mw, CommonStrings::trWarning, tr("Parsing failed!\n\nPlease submit your file (if possible) to the\nDocument Liberation Project http://www.documentliberation.org"));
+				ScMessageBox::warning(mw, CommonStrings::trWarning, tr("Parsing failed!\n\nPlease submit your file (if possible) to the\nDocument Liberation Project https://www.documentliberation.org"));
 				QGuiApplication::changeOverrideCursor(QCursor(Qt::WaitCursor));
 			}
 			return false;
diff -Naupr scribus-1.6.2/scribus/plugins/import/cdr/importcdrplugin.cpp scribus16x/scribus/plugins/import/cdr/importcdrplugin.cpp
--- scribus-1.6.2/scribus/plugins/import/cdr/importcdrplugin.cpp	2024-06-15 16:22:26.000000000 +0200
+++ scribus16x/scribus/plugins/import/cdr/importcdrplugin.cpp	2025-01-04 10:59:04.819408048 +0100
@@ -165,7 +165,7 @@ bool ImportCdrPlugin::import(QString fil
 		{
 			if (flags & LoadSavePlugin::lfCreateDoc)
 			{
-				ScMessageBox::warning(mw, CommonStrings::trWarning, tr("Parsing failed!\n\nPlease submit your file (if possible) to the\nDocument Liberation Project http://www.documentliberation.org"));
+				ScMessageBox::warning(mw, CommonStrings::trWarning, tr("Parsing failed!\n\nPlease submit your file (if possible) to the\nDocument Liberation Project https://www.documentliberation.org"));
 			}
 			return false;
 		}
diff -Naupr scribus-1.6.2/scribus/plugins/import/fh/importfh.cpp scribus16x/scribus/plugins/import/fh/importfh.cpp
--- scribus-1.6.2/scribus/plugins/import/fh/importfh.cpp	2024-06-15 16:22:26.000000000 +0200
+++ scribus16x/scribus/plugins/import/fh/importfh.cpp	2025-01-04 10:59:04.821408006 +0100
@@ -347,7 +347,7 @@ bool FhPlug::convert(const QString& fn)
 		{
 			ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 			qApp->changeOverrideCursor(QCursor(Qt::ArrowCursor));
-			QMessageBox::warning(mw, CommonStrings::trWarning, tr("Parsing failed!\n\nPlease submit your file (if possible) to the\nDocument Liberation Project http://www.documentliberation.org"), 1, 0, 0);
+			QMessageBox::warning(mw, CommonStrings::trWarning, tr("Parsing failed!\n\nPlease submit your file (if possible) to the\nDocument Liberation Project https://www.documentliberation.org"), 1, 0, 0);
 			qApp->changeOverrideCursor(QCursor(Qt::WaitCursor));
 		}
 		return false;
diff -Naupr scribus-1.6.2/scribus/plugins/import/odg/importodg.cpp scribus16x/scribus/plugins/import/odg/importodg.cpp
--- scribus-1.6.2/scribus/plugins/import/odg/importodg.cpp	2024-06-15 16:22:26.000000000 +0200
+++ scribus16x/scribus/plugins/import/odg/importodg.cpp	2025-01-04 10:59:04.661411346 +0100
@@ -137,7 +137,7 @@ bool OdgPlug::import(const QString& fNam
 	firstPage = true;
 	pagecount = 1;
 	mpagecount = 0;
-	QFileInfo fi = QFileInfo(fNameIn);
+	QFileInfo fi(fNameIn);
 	if (!ScCore->usingGUI())
 	{
 		interactive = false;
@@ -158,14 +158,14 @@ bool OdgPlug::import(const QString& fNam
 		progressDialog->setProgress("GI", 0);
 		progressDialog->show();
 		connect(progressDialog, SIGNAL(canceled()), this, SLOT(cancelRequested()));
-		qApp->processEvents();
+		QApplication::processEvents();
 	}
 	else
 		progressDialog = nullptr;
 	if (progressDialog)
 	{
 		progressDialog->setOverallProgress(1);
-		qApp->processEvents();
+		QApplication::processEvents();
 	}
 	/* Set default Page to size defined in Preferences */
 	docWidth = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
@@ -193,12 +193,12 @@ bool OdgPlug::import(const QString& fNam
 			baseY = m_Doc->currentPage()->yOffset() + m_Doc->currentPage()->height() / 2.0;
 		}
 	}
-	if ((!ret) && (interactive))
+	if (!ret && interactive)
 	{
 		baseX = m_Doc->currentPage()->xOffset();
 		baseY = m_Doc->currentPage()->yOffset() + m_Doc->currentPage()->height() / 2.0;
 	}
-	if ((ret) || (!interactive))
+	if (ret || !interactive)
 	{
 		if (docWidth > docHeight)
 			m_Doc->setPageOrientation(1);
@@ -214,7 +214,7 @@ bool OdgPlug::import(const QString& fNam
 	if ((!(flags & LoadSavePlugin::lfLoadAsPattern)) && (m_Doc->view() != nullptr))
 		m_Doc->view()->updatesOn(false);
 	m_Doc->scMW()->setScriptRunning(true);
-	qApp->setOverrideCursor(QCursor(Qt::WaitCursor));
+	QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
 	QString CurDirP = QDir::currentPath();
 	QDir::setCurrent(fi.path());
 	if (convert(fNameIn))
@@ -226,8 +226,8 @@ bool OdgPlug::import(const QString& fNam
 		m_Doc->DoDrawing = true;
 		m_Doc->scMW()->setScriptRunning(false);
 		m_Doc->setLoading(false);
-		qApp->changeOverrideCursor(QCursor(Qt::ArrowCursor));
-		if ((Elements.count() > 0) && (!ret) && (interactive))
+		QApplication::changeOverrideCursor(QCursor(Qt::ArrowCursor));
+		if ((Elements.count() > 0) && !ret && interactive)
 		{
 			if (flags & LoadSavePlugin::lfScripted)
 			{
@@ -279,7 +279,7 @@ bool OdgPlug::import(const QString& fNam
 				m_Doc->m_Selection->delaySignalsOff();
 				// We must copy the TransationSettings object as it is owned
 				// by handleObjectImport method afterwards
-				TransactionSettings* transacSettings = new TransactionSettings(trSettings);
+				auto* transacSettings = new TransactionSettings(trSettings);
 				m_Doc->view()->handleObjectImport(md, transacSettings);
 				m_Doc->DragP = false;
 				m_Doc->DraggedElem = nullptr;
@@ -302,7 +302,7 @@ bool OdgPlug::import(const QString& fNam
 		m_Doc->scMW()->setScriptRunning(false);
 		if (!(flags & LoadSavePlugin::lfLoadAsPattern))
 			m_Doc->view()->updatesOn(true);
-		qApp->changeOverrideCursor(QCursor(Qt::ArrowCursor));
+		QApplication::changeOverrideCursor(QCursor(Qt::ArrowCursor));
 		success = false;
 	}
 	if (interactive)
@@ -310,10 +310,10 @@ bool OdgPlug::import(const QString& fNam
 	//CB If we have a gui we must refresh it if we have used the progressbar
 	if (!(flags & LoadSavePlugin::lfLoadAsPattern))
 	{
-		if ((showProgress) && (!interactive))
+		if (showProgress && !interactive)
 			m_Doc->view()->DrawNew();
 	}
-	qApp->restoreOverrideCursor();
+	QApplication::restoreOverrideCursor();
 	return success;
 }
 
@@ -335,10 +335,10 @@ bool OdgPlug::convert(const QString& fn)
 	{
 		progressDialog->setOverallProgress(2);
 		progressDialog->setLabel("GI", tr("Generating Items"));
-		qApp->processEvents();
+		QApplication::processEvents();
 	}
 
-	QFileInfo fi = QFileInfo(fn);
+	QFileInfo fi(fn);
 	QString ext = fi.suffix().toLower();
 	if ((ext == "fodg") || (ext == "fodp"))
 	{
@@ -947,7 +947,7 @@ PageItem* OdgPlug::parseCustomShape(QDom
 					while (!allResOK)
 					{
 						allResOK = true;
-						QMap<QString, QString>::iterator itf = formulaMap.begin();
+						auto itf = formulaMap.begin();
 						while (itf != formulaMap.end())
 						{
 							double erg = 0;
@@ -1226,7 +1226,7 @@ PageItem* OdgPlug::parseMeasure(QDomElem
 	resovleStyle(tmpOStyle, getStyleName(e));
 	if (tmpOStyle.measureDist == 0)
 		tmpOStyle.measureDist = tmpOStyle.fontSize;
-	QLineF refLine = QLineF(x1, y1, x2, y2);
+	QLineF refLine(x1, y1, x2, y2);
 	QLineF normRef = refLine.normalVector();
 	normRef.setLength(tmpOStyle.measureDist);
 	double dx = normRef.p2().x() - refLine.p1().x();
@@ -1253,7 +1253,7 @@ PageItem* OdgPlug::parseMeasure(QDomElem
 		m_Doc->Items->removeLast();
 		GElements.append(retObj);
 	}
-	QLineF refLine2 = QLineF(x2, y2, x1, y1);
+	QLineF refLine2(x2, y2, x1, y1);
 	QLineF normRef2 = refLine2.normalVector();
 	normRef2.setAngle(normRef2.angle() + 180);
 	normRef2.setLength(tmpOStyle.measureDist + tmpOStyle.fontSize / 2.0);
@@ -1273,7 +1273,7 @@ PageItem* OdgPlug::parseMeasure(QDomElem
 		GElements.append(retObj);
 	}
 	normRef2.setLength(tmpOStyle.measureDist + tmpOStyle.fontSize * 1.2);
-	QLineF textLine = QLineF(normRef.p2(), normRef2.p2());
+	QLineF textLine(normRef.p2(), normRef2.p2());
 	if (textLine.length() != 0)
 	{
 		int z = m_Doc->itemAdd(PageItem::TextFrame, PageItem::Unspecified, baseX+normRef.p2().x(), baseY+normRef.p2().y(), textLine.length(), tmpOStyle.fontSize * 1.2, tmpOStyle.LineW, tmpOStyle.currColorFill, tmpOStyle.currColorStroke);
@@ -1543,7 +1543,7 @@ PageItem* OdgPlug::parseFrame(QDomElemen
 					if (uz->read(imagePath, f))
 					{
 						QFileInfo fi(imagePath);
-						QTemporaryFile *tempFile = new QTemporaryFile(QDir::tempPath() + "/scribus_temp_odg_XXXXXX." + fi.suffix());
+						auto *tempFile = new QTemporaryFile(QDir::tempPath() + "/scribus_temp_odg_XXXXXX." + fi.suffix());
 						tempFile->setAutoRemove(false);
 						if (tempFile->open())
 						{
@@ -1633,7 +1633,7 @@ PageItem* OdgPlug::parseFrame(QDomElemen
 								if (e.hasAttribute("draw:transform"))
 									retObj->setRotation(r, true);
 								finishItem(retObj, tmpOStyle);
-								QTemporaryFile *tempFile = new QTemporaryFile(QDir::tempPath() + "/scribus_temp_odg_XXXXXX." + ext);
+								auto *tempFile = new QTemporaryFile(QDir::tempPath() + "/scribus_temp_odg_XXXXXX." + ext);
 								tempFile->setAutoRemove(false);
 								if (tempFile->open())
 								{
@@ -1890,7 +1890,7 @@ void OdgPlug::applyCharacterStyle(CharSt
 	tmpCStyle.setFeatures(styleEffects.featureList());
 }
 
-void OdgPlug::applyParagraphStyle(ParagraphStyle &tmpStyle, ObjStyle &oStyle)
+void OdgPlug::applyParagraphStyle(ParagraphStyle &tmpStyle, ObjStyle &oStyle) const
 {
 	tmpStyle.setAlignment(oStyle.textAlign);
 	tmpStyle.setLeftMargin(oStyle.margin_left);
@@ -1900,7 +1900,7 @@ void OdgPlug::applyParagraphStyle(Paragr
 	tmpStyle.setGapBefore(oStyle.margin_top);
 }
 
-void OdgPlug::parseTransform(const QString &transform, double *rotation, double *transX, double *transY)
+void OdgPlug::parseTransform(const QString &transform, double *rotation, double *transX, double *transY) const
 {
 	double dx, dy;
 	QStringList subtransforms = transform.split(')', Qt::SkipEmptyParts);
@@ -1937,7 +1937,7 @@ void OdgPlug::parseTransform(const QStri
 	}
 }
 
-void OdgPlug::parseTransform(FPointArray *composite, const QString &transform)
+void OdgPlug::parseTransform(FPointArray *composite, const QString &transform) const
 {
 	double dx, dy;
 	QTransform result;
@@ -1990,7 +1990,7 @@ void OdgPlug::parseTransform(FPointArray
 	}
 }
 
-void OdgPlug::parseViewBox( const QDomElement& object, double *x, double *y, double *w, double *h )
+void OdgPlug::parseViewBox(const QDomElement& object, double *x, double *y, double *w, double *h) const
 {
 	if (!object.attribute( "svg:viewBox" ).isEmpty())
 	{
@@ -2019,7 +2019,7 @@ void OdgPlug::appendPoints(FPointArray *
 	QStringList ptList = object.attribute( "draw:points" ).split( ' ', Qt::SkipEmptyParts );
 	FPoint point, firstP;
 	bool bFirst = true;
-	for ( QStringList::Iterator it = ptList.begin(); it != ptList.end(); ++it)
+	for (auto it = ptList.begin(); it != ptList.end(); ++it)
 	{
 		point = FPoint(ScCLocale::toDoubleC((*it).section( ',', 0, 0 )), ScCLocale::toDoubleC((*it).section( ',', 1, 1 )));
 		if (bFirst)
@@ -2252,7 +2252,7 @@ void OdgPlug::parseStyles(QDomElement &s
 	}
 }
 
-QString OdgPlug::getStyleName(QDomElement &e)
+QString OdgPlug::getStyleName(QDomElement &e) const
 {
 	QString styleName = "standard";
 	if (e.hasAttribute("draw:style-name"))
@@ -2280,167 +2280,166 @@ void OdgPlug::resovleStyle(ObjStyle &tmp
 				break;
 		}
 		parents.append(pAttrs);
-		if (!parents.isEmpty())
+
+		for (int p = 0; p < parents.count(); p++)
 		{
-			for (int p = 0; p < parents.count(); p++)
-			{
-				currStyle = m_Styles[parents[p]];
-				if (currStyle.markerViewBox.valid)
-					actStyle.markerViewBox = AttributeValue(currStyle.markerViewBox.value);
-				if (currStyle.markerPath.valid)
-					actStyle.markerPath = AttributeValue(currStyle.markerPath.value);
-				if (currStyle.startMarkerName.valid)
-					actStyle.startMarkerName = AttributeValue(currStyle.startMarkerName.value);
-				if (currStyle.startMarkerWidth.valid)
-					actStyle.startMarkerWidth = AttributeValue(currStyle.startMarkerWidth.value);
-				if (currStyle.startMarkerCentered.valid)
-					actStyle.startMarkerCentered = AttributeValue(currStyle.startMarkerCentered.value);
-				if (currStyle.endMarkerName.valid)
-					actStyle.endMarkerName = AttributeValue(currStyle.endMarkerName.value);
-				if (currStyle.endMarkerWidth.valid)
-					actStyle.endMarkerWidth = AttributeValue(currStyle.endMarkerWidth.value);
-				if (currStyle.endMarkerCentered.valid)
-					actStyle.endMarkerCentered = AttributeValue(currStyle.endMarkerCentered.value);
-				if (currStyle.stroke_dash_distance.valid)
-					actStyle.stroke_dash_distance = AttributeValue(currStyle.stroke_dash_distance.value);
-				if (currStyle.stroke_dash_dots1.valid)
-					actStyle.stroke_dash_dots1 = AttributeValue(currStyle.stroke_dash_dots1.value);
-				if (currStyle.stroke_dash_dots1_length.valid)
-					actStyle.stroke_dash_dots1_length = AttributeValue(currStyle.stroke_dash_dots1_length.value);
-				if (currStyle.stroke_dash_dots2.valid)
-					actStyle.stroke_dash_dots2 = AttributeValue(currStyle.stroke_dash_dots2.value);
-				if (currStyle.stroke_dash_dots2_length.valid)
-					actStyle.stroke_dash_dots2_length = AttributeValue(currStyle.stroke_dash_dots2_length.value);
-				if (currStyle.stroke_dash_style.valid)
-					actStyle.stroke_dash_style = AttributeValue(currStyle.stroke_dash_style.value);
-				if (currStyle.fillMode.valid)
-					actStyle.fillMode = AttributeValue(currStyle.fillMode.value);
-				if (currStyle.currColorFill.valid)
-					actStyle.currColorFill = AttributeValue(currStyle.currColorFill.value);
-				if (currStyle.strokeMode.valid)
-					actStyle.strokeMode = AttributeValue(currStyle.strokeMode.value);
-				if (currStyle.currColorStroke.valid)
-					actStyle.currColorStroke = AttributeValue(currStyle.currColorStroke.value);
-				if (currStyle.currColorShadow.valid)
-					actStyle.currColorShadow = AttributeValue(currStyle.currColorShadow.value);
-				if (currStyle.hasShadow.valid)
-					actStyle.hasShadow = AttributeValue(currStyle.hasShadow.value);
-				if (currStyle.shadowX.valid)
-					actStyle.shadowX = AttributeValue(currStyle.shadowX.value);
-				if (currStyle.shadowY.valid)
-					actStyle.shadowY = AttributeValue(currStyle.shadowY.value);
-				if (currStyle.shadowTrans.valid)
-					actStyle.shadowTrans = AttributeValue(currStyle.shadowTrans.value);
-				if (currStyle.fillOpacity.valid)
-					actStyle.fillOpacity = AttributeValue(currStyle.fillOpacity.value);
-				if (currStyle.strokeOpacity.valid)
-					actStyle.strokeOpacity = AttributeValue(currStyle.strokeOpacity.value);
-				if (currStyle.LineW.valid)
-					actStyle.LineW = AttributeValue(currStyle.LineW.value);
-				if (currStyle.fontName.valid)
-					actStyle.fontName = AttributeValue(currStyle.fontName.value);
-				if (currStyle.fontSize.valid)
-					actStyle.fontSize = AttributeValue(currStyle.fontSize.value);
-				if (currStyle.margin_top.valid)
-					actStyle.margin_top = AttributeValue(currStyle.margin_top.value);
-				if (currStyle.margin_bottom.valid)
-					actStyle.margin_bottom = AttributeValue(currStyle.margin_bottom.value);
-				if (currStyle.margin_left.valid)
-					actStyle.margin_left = AttributeValue(currStyle.margin_left.value);
-				if (currStyle.margin_right.valid)
-					actStyle.margin_right = AttributeValue(currStyle.margin_right.value);
-				if (currStyle.page_width.valid)
-					actStyle.page_width = AttributeValue(currStyle.page_width.value);
-				if (currStyle.page_height.valid)
-					actStyle.page_height = AttributeValue(currStyle.page_height.value);
-				if (currStyle.page_layout_name.valid)
-					actStyle.page_layout_name = AttributeValue(currStyle.page_layout_name.value);
-				if (currStyle.textIndent.valid)
-					actStyle.textIndent = AttributeValue(currStyle.textIndent.value);
-				if (currStyle.textAlign.valid)
-					actStyle.textAlign = AttributeValue(currStyle.textAlign.value);
-				if (currStyle.textPos.valid)
-					actStyle.textPos = AttributeValue(currStyle.textPos.value);
-				if (currStyle.textOutline.valid)
-					actStyle.textOutline = AttributeValue(currStyle.textOutline.value);
-				if (currStyle.textUnderline.valid)
-					actStyle.textUnderline = AttributeValue(currStyle.textUnderline.value);
-				if (currStyle.textUnderlineWords.valid)
-					actStyle.textUnderlineWords = AttributeValue(currStyle.textUnderlineWords.value);
-				if (currStyle.textUnderlineColor.valid)
-					actStyle.textUnderlineColor = AttributeValue(currStyle.textUnderlineColor.value);
-				if (currStyle.textStrikeThrough.valid)
-					actStyle.textStrikeThrough = AttributeValue(currStyle.textStrikeThrough.value);
-				if (currStyle.textShadow.valid)
-					actStyle.textShadow = AttributeValue(currStyle.textShadow.value);
-				if (currStyle.lineHeight.valid)
-					actStyle.lineHeight = AttributeValue(currStyle.lineHeight.value);
-				if (currStyle.fontColor.valid)
-					actStyle.fontColor = AttributeValue(currStyle.fontColor.value);
-				if (currStyle.textBackgroundColor.valid)
-					actStyle.textBackgroundColor = AttributeValue(currStyle.textBackgroundColor.value);
-				if (currStyle.gradientAngle.valid)
-					actStyle.gradientAngle = AttributeValue(currStyle.gradientAngle.value);
-				if (currStyle.gradientBorder.valid)
-					actStyle.gradientBorder = AttributeValue(currStyle.gradientBorder.value);
-				if (currStyle.gradientEndColor.valid)
-					actStyle.gradientEndColor = AttributeValue(currStyle.gradientEndColor.value);
-				if (currStyle.gradientEndShade.valid)
-					actStyle.gradientEndShade = AttributeValue(currStyle.gradientEndShade.value);
-				if (currStyle.gradientStartColor.valid)
-					actStyle.gradientStartColor = AttributeValue(currStyle.gradientStartColor.value);
-				if (currStyle.gradientStartShade.valid)
-					actStyle.gradientStartShade = AttributeValue(currStyle.gradientStartShade.value);
-				if (currStyle.gradientCenterX.valid)
-					actStyle.gradientCenterX = AttributeValue(currStyle.gradientCenterX.value);
-				if (currStyle.gradientCenterY.valid)
-					actStyle.gradientCenterY = AttributeValue(currStyle.gradientCenterY.value);
-				if (currStyle.gradientType.valid)
-					actStyle.gradientType = AttributeValue(currStyle.gradientType.value);
-				if (currStyle.gradientName.valid)
-					actStyle.gradientName = AttributeValue(currStyle.gradientName.value);
-				if (currStyle.dashName.valid)
-					actStyle.dashName = AttributeValue(currStyle.dashName.value);
-				if (currStyle.measureDist.valid)
-					actStyle.measureDist = AttributeValue(currStyle.measureDist.value);
-				if (currStyle.patternName.valid)
-					actStyle.patternName = AttributeValue(currStyle.patternName.value);
-				if (currStyle.patternPath.valid)
-					actStyle.patternPath = AttributeValue(currStyle.patternPath.value);
-				if (currStyle.patternData.valid)
-					actStyle.patternData = AttributeValue(currStyle.patternData.value);
-				if (currStyle.patternWidth.valid)
-					actStyle.patternWidth = AttributeValue(currStyle.patternWidth.value);
-				if (currStyle.patternHeight.valid)
-					actStyle.patternHeight = AttributeValue(currStyle.patternHeight.value);
-				if (currStyle.patternX.valid)
-					actStyle.patternX = AttributeValue(currStyle.patternX.value);
-				if (currStyle.patternY.valid)
-					actStyle.patternY = AttributeValue(currStyle.patternY.value);
-				if (currStyle.patternStretch.valid)
-					actStyle.patternStretch = AttributeValue(currStyle.patternStretch.value);
-				if (currStyle.hatchName.valid)
-					actStyle.hatchName = AttributeValue(currStyle.hatchName.value);
-				if (currStyle.hatchColor.valid)
-					actStyle.hatchColor = AttributeValue(currStyle.hatchColor.value);
-				if (currStyle.hatchDistance.valid)
-					actStyle.hatchDistance = AttributeValue(currStyle.hatchDistance.value);
-				if (currStyle.hatchRotation.valid)
-					actStyle.hatchRotation = AttributeValue(currStyle.hatchRotation.value);
-				if (currStyle.hatchStyle.valid)
-					actStyle.hatchStyle = AttributeValue(currStyle.hatchStyle.value);
-				if (currStyle.hatchSolidFill.valid)
-					actStyle.hatchSolidFill = AttributeValue(currStyle.hatchSolidFill.value);
-				if (currStyle.opacityName.valid)
-					actStyle.opacityName = AttributeValue(currStyle.opacityName.value);
-				if (currStyle.opacityEnd.valid)
-					actStyle.opacityEnd = AttributeValue(currStyle.opacityEnd.value);
-				if (currStyle.opacityStart.valid)
-					actStyle.opacityStart = AttributeValue(currStyle.opacityStart.value);
-				if (currStyle.verticalAlignment.valid)
-					actStyle.verticalAlignment = AttributeValue(currStyle.verticalAlignment.value);
-			}
+			currStyle = m_Styles[parents[p]];
+			if (currStyle.markerViewBox.valid)
+				actStyle.markerViewBox = AttributeValue(currStyle.markerViewBox.value);
+			if (currStyle.markerPath.valid)
+				actStyle.markerPath = AttributeValue(currStyle.markerPath.value);
+			if (currStyle.startMarkerName.valid)
+				actStyle.startMarkerName = AttributeValue(currStyle.startMarkerName.value);
+			if (currStyle.startMarkerWidth.valid)
+				actStyle.startMarkerWidth = AttributeValue(currStyle.startMarkerWidth.value);
+			if (currStyle.startMarkerCentered.valid)
+				actStyle.startMarkerCentered = AttributeValue(currStyle.startMarkerCentered.value);
+			if (currStyle.endMarkerName.valid)
+				actStyle.endMarkerName = AttributeValue(currStyle.endMarkerName.value);
+			if (currStyle.endMarkerWidth.valid)
+				actStyle.endMarkerWidth = AttributeValue(currStyle.endMarkerWidth.value);
+			if (currStyle.endMarkerCentered.valid)
+				actStyle.endMarkerCentered = AttributeValue(currStyle.endMarkerCentered.value);
+			if (currStyle.stroke_dash_distance.valid)
+				actStyle.stroke_dash_distance = AttributeValue(currStyle.stroke_dash_distance.value);
+			if (currStyle.stroke_dash_dots1.valid)
+				actStyle.stroke_dash_dots1 = AttributeValue(currStyle.stroke_dash_dots1.value);
+			if (currStyle.stroke_dash_dots1_length.valid)
+				actStyle.stroke_dash_dots1_length = AttributeValue(currStyle.stroke_dash_dots1_length.value);
+			if (currStyle.stroke_dash_dots2.valid)
+				actStyle.stroke_dash_dots2 = AttributeValue(currStyle.stroke_dash_dots2.value);
+			if (currStyle.stroke_dash_dots2_length.valid)
+				actStyle.stroke_dash_dots2_length = AttributeValue(currStyle.stroke_dash_dots2_length.value);
+			if (currStyle.stroke_dash_style.valid)
+				actStyle.stroke_dash_style = AttributeValue(currStyle.stroke_dash_style.value);
+			if (currStyle.fillMode.valid)
+				actStyle.fillMode = AttributeValue(currStyle.fillMode.value);
+			if (currStyle.currColorFill.valid)
+				actStyle.currColorFill = AttributeValue(currStyle.currColorFill.value);
+			if (currStyle.strokeMode.valid)
+				actStyle.strokeMode = AttributeValue(currStyle.strokeMode.value);
+			if (currStyle.currColorStroke.valid)
+				actStyle.currColorStroke = AttributeValue(currStyle.currColorStroke.value);
+			if (currStyle.currColorShadow.valid)
+				actStyle.currColorShadow = AttributeValue(currStyle.currColorShadow.value);
+			if (currStyle.hasShadow.valid)
+				actStyle.hasShadow = AttributeValue(currStyle.hasShadow.value);
+			if (currStyle.shadowX.valid)
+				actStyle.shadowX = AttributeValue(currStyle.shadowX.value);
+			if (currStyle.shadowY.valid)
+				actStyle.shadowY = AttributeValue(currStyle.shadowY.value);
+			if (currStyle.shadowTrans.valid)
+				actStyle.shadowTrans = AttributeValue(currStyle.shadowTrans.value);
+			if (currStyle.fillOpacity.valid)
+				actStyle.fillOpacity = AttributeValue(currStyle.fillOpacity.value);
+			if (currStyle.strokeOpacity.valid)
+				actStyle.strokeOpacity = AttributeValue(currStyle.strokeOpacity.value);
+			if (currStyle.LineW.valid)
+				actStyle.LineW = AttributeValue(currStyle.LineW.value);
+			if (currStyle.fontName.valid)
+				actStyle.fontName = AttributeValue(currStyle.fontName.value);
+			if (currStyle.fontSize.valid)
+				actStyle.fontSize = AttributeValue(currStyle.fontSize.value);
+			if (currStyle.margin_top.valid)
+				actStyle.margin_top = AttributeValue(currStyle.margin_top.value);
+			if (currStyle.margin_bottom.valid)
+				actStyle.margin_bottom = AttributeValue(currStyle.margin_bottom.value);
+			if (currStyle.margin_left.valid)
+				actStyle.margin_left = AttributeValue(currStyle.margin_left.value);
+			if (currStyle.margin_right.valid)
+				actStyle.margin_right = AttributeValue(currStyle.margin_right.value);
+			if (currStyle.page_width.valid)
+				actStyle.page_width = AttributeValue(currStyle.page_width.value);
+			if (currStyle.page_height.valid)
+				actStyle.page_height = AttributeValue(currStyle.page_height.value);
+			if (currStyle.page_layout_name.valid)
+				actStyle.page_layout_name = AttributeValue(currStyle.page_layout_name.value);
+			if (currStyle.textIndent.valid)
+				actStyle.textIndent = AttributeValue(currStyle.textIndent.value);
+			if (currStyle.textAlign.valid)
+				actStyle.textAlign = AttributeValue(currStyle.textAlign.value);
+			if (currStyle.textPos.valid)
+				actStyle.textPos = AttributeValue(currStyle.textPos.value);
+			if (currStyle.textOutline.valid)
+				actStyle.textOutline = AttributeValue(currStyle.textOutline.value);
+			if (currStyle.textUnderline.valid)
+				actStyle.textUnderline = AttributeValue(currStyle.textUnderline.value);
+			if (currStyle.textUnderlineWords.valid)
+				actStyle.textUnderlineWords = AttributeValue(currStyle.textUnderlineWords.value);
+			if (currStyle.textUnderlineColor.valid)
+				actStyle.textUnderlineColor = AttributeValue(currStyle.textUnderlineColor.value);
+			if (currStyle.textStrikeThrough.valid)
+				actStyle.textStrikeThrough = AttributeValue(currStyle.textStrikeThrough.value);
+			if (currStyle.textShadow.valid)
+				actStyle.textShadow = AttributeValue(currStyle.textShadow.value);
+			if (currStyle.lineHeight.valid)
+				actStyle.lineHeight = AttributeValue(currStyle.lineHeight.value);
+			if (currStyle.fontColor.valid)
+				actStyle.fontColor = AttributeValue(currStyle.fontColor.value);
+			if (currStyle.textBackgroundColor.valid)
+				actStyle.textBackgroundColor = AttributeValue(currStyle.textBackgroundColor.value);
+			if (currStyle.gradientAngle.valid)
+				actStyle.gradientAngle = AttributeValue(currStyle.gradientAngle.value);
+			if (currStyle.gradientBorder.valid)
+				actStyle.gradientBorder = AttributeValue(currStyle.gradientBorder.value);
+			if (currStyle.gradientEndColor.valid)
+				actStyle.gradientEndColor = AttributeValue(currStyle.gradientEndColor.value);
+			if (currStyle.gradientEndShade.valid)
+				actStyle.gradientEndShade = AttributeValue(currStyle.gradientEndShade.value);
+			if (currStyle.gradientStartColor.valid)
+				actStyle.gradientStartColor = AttributeValue(currStyle.gradientStartColor.value);
+			if (currStyle.gradientStartShade.valid)
+				actStyle.gradientStartShade = AttributeValue(currStyle.gradientStartShade.value);
+			if (currStyle.gradientCenterX.valid)
+				actStyle.gradientCenterX = AttributeValue(currStyle.gradientCenterX.value);
+			if (currStyle.gradientCenterY.valid)
+				actStyle.gradientCenterY = AttributeValue(currStyle.gradientCenterY.value);
+			if (currStyle.gradientType.valid)
+				actStyle.gradientType = AttributeValue(currStyle.gradientType.value);
+			if (currStyle.gradientName.valid)
+				actStyle.gradientName = AttributeValue(currStyle.gradientName.value);
+			if (currStyle.dashName.valid)
+				actStyle.dashName = AttributeValue(currStyle.dashName.value);
+			if (currStyle.measureDist.valid)
+				actStyle.measureDist = AttributeValue(currStyle.measureDist.value);
+			if (currStyle.patternName.valid)
+				actStyle.patternName = AttributeValue(currStyle.patternName.value);
+			if (currStyle.patternPath.valid)
+				actStyle.patternPath = AttributeValue(currStyle.patternPath.value);
+			if (currStyle.patternData.valid)
+				actStyle.patternData = AttributeValue(currStyle.patternData.value);
+			if (currStyle.patternWidth.valid)
+				actStyle.patternWidth = AttributeValue(currStyle.patternWidth.value);
+			if (currStyle.patternHeight.valid)
+				actStyle.patternHeight = AttributeValue(currStyle.patternHeight.value);
+			if (currStyle.patternX.valid)
+				actStyle.patternX = AttributeValue(currStyle.patternX.value);
+			if (currStyle.patternY.valid)
+				actStyle.patternY = AttributeValue(currStyle.patternY.value);
+			if (currStyle.patternStretch.valid)
+				actStyle.patternStretch = AttributeValue(currStyle.patternStretch.value);
+			if (currStyle.hatchName.valid)
+				actStyle.hatchName = AttributeValue(currStyle.hatchName.value);
+			if (currStyle.hatchColor.valid)
+				actStyle.hatchColor = AttributeValue(currStyle.hatchColor.value);
+			if (currStyle.hatchDistance.valid)
+				actStyle.hatchDistance = AttributeValue(currStyle.hatchDistance.value);
+			if (currStyle.hatchRotation.valid)
+				actStyle.hatchRotation = AttributeValue(currStyle.hatchRotation.value);
+			if (currStyle.hatchStyle.valid)
+				actStyle.hatchStyle = AttributeValue(currStyle.hatchStyle.value);
+			if (currStyle.hatchSolidFill.valid)
+				actStyle.hatchSolidFill = AttributeValue(currStyle.hatchSolidFill.value);
+			if (currStyle.opacityName.valid)
+				actStyle.opacityName = AttributeValue(currStyle.opacityName.value);
+			if (currStyle.opacityEnd.valid)
+				actStyle.opacityEnd = AttributeValue(currStyle.opacityEnd.value);
+			if (currStyle.opacityStart.valid)
+				actStyle.opacityStart = AttributeValue(currStyle.opacityStart.value);
+			if (currStyle.verticalAlignment.valid)
+				actStyle.verticalAlignment = AttributeValue(currStyle.verticalAlignment.value);
 		}
+
 		tmpOStyle.stroke_dash_distance = -1;
 		tmpOStyle.stroke_dash_dots1_length = -1;
 		tmpOStyle.stroke_dash_dots2_length = -1;
@@ -2754,7 +2753,7 @@ void OdgPlug::resovleStyle(ObjStyle &tmp
 	}
 }
 
-double OdgPlug::parseUnit(const QString &unit)
+double OdgPlug::parseUnit(const QString &unit) const
 {
 	QString unitval = unit;
 	if (unit.isEmpty())
@@ -2787,7 +2786,7 @@ double OdgPlug::parseUnit(const QString
 	return value;
 }
 
-const char * OdgPlug::getCoord( const char *ptr, double &number )
+const char * OdgPlug::getCoord( const char *ptr, double &number ) const
 {
 	int integer, exponent;
 	double decimal, frac;
@@ -3047,7 +3046,7 @@ bool OdgPlug::parseEnhPath(const QString
 	return ret;
 }
 
-double OdgPlug::angleFromPoint(const QPointF &point)
+double OdgPlug::angleFromPoint(const QPointF &point) const
 {
 	double angle = atan2(point.y(), point.x());
 	if (angle < 0.0)
@@ -3055,7 +3054,7 @@ double OdgPlug::angleFromPoint(const QPo
 	return 2*M_PI - angle;
 }
 
-double OdgPlug::radSweepAngle(double start, double stop, bool clockwise)
+double OdgPlug::radSweepAngle(double start, double stop, bool clockwise) const
 {
 	double sweepAngle = stop - start;
 	if (fabs(sweepAngle) < 0.1) {
@@ -3074,7 +3073,7 @@ double OdgPlug::radSweepAngle(double sta
    return sweepAngle;
 }
 
-double OdgPlug::degSweepAngle(double start, double stop, bool clockwise)
+double OdgPlug::degSweepAngle(double start, double stop, bool clockwise) const
 {
 	double sweepAngle = stop - start;
 	if (fabs(sweepAngle) < 0.1) {
@@ -3092,7 +3091,7 @@ double OdgPlug::degSweepAngle(double sta
    return sweepAngle;
 }
 
-void OdgPlug::arcTo(QPainterPath &path, QPointF startpoint, double rx, double ry, double startAngle, double sweepAngle)
+void OdgPlug::arcTo(QPainterPath &path, QPointF startpoint, double rx, double ry, double startAngle, double sweepAngle) const
 {
 	QPointF curvePoints[12];
 	int pointCnt = arcToCurve(rx, ry, startAngle, sweepAngle, startpoint, curvePoints);
@@ -3102,7 +3101,7 @@ void OdgPlug::arcTo(QPainterPath &path,
 	}
 }
 
-int OdgPlug::arcToCurve(double rx, double ry, double startAngle, double sweepAngle, const QPointF & offset, QPointF * curvePoints)
+int OdgPlug::arcToCurve(double rx, double ry, double startAngle, double sweepAngle, const QPointF & offset, QPointF * curvePoints) const
 {
 	int pointCnt = 0;
 
@@ -3226,23 +3225,23 @@ QString OdgPlug::parseColor( const QStri
 	{
 		QString parse = s.trimmed();
 		QStringList colors = parse.split( ',', Qt::SkipEmptyParts );
-		QString r = colors[0].right( ( colors[0].length() - 4 ) );
+		QString r = colors[0].right( colors[0].length() - 4 );
 		QString g = colors[1];
-		QString b = colors[2].left( ( colors[2].length() - 1 ) );
+		QString b = colors[2].left( colors[2].length() - 1 );
 		if (r.contains( "%" ))
 		{
 			r.chop(1);
-			r = QString::number( static_cast<int>( ( static_cast<double>( 255 * ScCLocale::toDoubleC(r) ) / 100.0 ) ) );
+			r = QString::number( static_cast<int>(2.55 * ScCLocale::toDoubleC(r)) );
 		}
 		if (g.contains( "%" ))
 		{
 			g.chop(1);
-			g = QString::number( static_cast<int>( ( static_cast<double>( 255 * ScCLocale::toDoubleC(g) ) / 100.0 ) ) );
+			g = QString::number( static_cast<int>(2.55 * ScCLocale::toDoubleC(g)) );
 		}
 		if (b.contains( "%" ))
 		{
 			b.chop(1);
-			b = QString::number( static_cast<int>( ( static_cast<double>( 255 * ScCLocale::toDoubleC(b) ) / 100.0 ) ) );
+			b = QString::number( static_cast<int>(2.55 * ScCLocale::toDoubleC(b)) );
 		}
 		c = QColor(r.toInt(), g.toInt(), b.toInt());
 	}
@@ -3312,12 +3311,12 @@ QString OdgPlug::constructFontName(const
 				family += " " + fontStyle;
 			if (!PrefsManager::instance().appPrefs.fontPrefs.GFontSub.contains(family))
 			{
-				qApp->changeOverrideCursor(QCursor(Qt::ArrowCursor));
-				MissingFont *dia = new MissingFont(nullptr, family, m_Doc);
+				QApplication::changeOverrideCursor(QCursor(Qt::ArrowCursor));
+				auto *dia = new MissingFont(nullptr, family, m_Doc);
 				dia->exec();
 				fontName = dia->getReplacementFont();
 				delete dia;
-				qApp->changeOverrideCursor(QCursor(Qt::WaitCursor));
+				QApplication::changeOverrideCursor(QCursor(Qt::WaitCursor));
 				PrefsManager::instance().appPrefs.fontPrefs.GFontSub[family] = fontName;
 			}
 			else
@@ -3327,7 +3326,7 @@ QString OdgPlug::constructFontName(const
 	return fontName;
 }
 
-QPointF OdgPlug::intersectBoundingRect(PageItem *item, QLineF gradientVector)
+QPointF OdgPlug::intersectBoundingRect(PageItem *item, QLineF gradientVector) const
 {
 	QPointF interPoint;
 	QPointF gradEnd;
@@ -3624,7 +3623,7 @@ void OdgPlug::finishItem(PageItem* item,
 				item->GrEndX = item->width() / 2.0;
 				item->GrEndY = item->height();
 			}
-			QLineF gradientVectorE = QLineF(item->GrStartX, item->GrStartY, item->GrEndX, item->GrEndY);
+			QLineF gradientVectorE(item->GrStartX, item->GrStartY, item->GrEndX, item->GrEndY);
 			gradientVectorE.setAngle(gStyle.gradientAngle);
 			item->GrEndX = gradientVectorE.p2().x();
 			item->GrEndY = gradientVectorE.p2().y();
@@ -3641,15 +3640,15 @@ void OdgPlug::finishItem(PageItem* item,
 			item->fill_gradient.addStop(ScColorEngine::getRGBColor(gradC2, m_Doc), 1.0 - gStyle.gradientBorder, 0.5, 1.0, gStyle.gradientStartColor, gStyle.gradientStartShade);
 			if (gStyle.gradientBorder != 0)
 				item->fill_gradient.addStop(ScColorEngine::getRGBColor(gradC2, m_Doc), 1.0, 0.5, 1.0, gStyle.gradientStartColor, gStyle.gradientStartShade);
-			FPoint cp = FPoint(item->width() * gStyle.gradientCenterX, item->height()* gStyle.gradientCenterY);
+			FPoint cp(item->width() * gStyle.gradientCenterX, item->height()* gStyle.gradientCenterY);
 			double gLen = qMin(item->width(), item->height()) / 2.0;
-			QLineF p1 = QLineF(cp.x(), cp.y(), cp.x() - gLen, cp.y() - gLen);
+			QLineF p1(cp.x(), cp.y(), cp.x() - gLen, cp.y() - gLen);
 			p1.setAngle(p1.angle() + gStyle.gradientAngle);
-			QLineF p2 = QLineF(cp.x(), cp.y(), cp.x() + gLen, cp.y() - gLen);
+			QLineF p2(cp.x(), cp.y(), cp.x() + gLen, cp.y() - gLen);
 			p2.setAngle(p2.angle() + gStyle.gradientAngle);
-			QLineF p3 = QLineF(cp.x(), cp.y(), cp.x() + gLen, cp.y() + gLen);
+			QLineF p3(cp.x(), cp.y(), cp.x() + gLen, cp.y() + gLen);
 			p3.setAngle(p3.angle() + gStyle.gradientAngle);
-			QLineF p4 = QLineF(cp.x(), cp.y(), cp.x() - gLen, cp.y() + gLen);
+			QLineF p4(cp.x(), cp.y(), cp.x() - gLen, cp.y() + gLen);
 			p4.setAngle(p4.angle() + gStyle.gradientAngle);
 			item->setDiamondGeometry(FPoint(p1.p2().x(), p1.p2().y()), FPoint(p2.p2().x(), p2.p2().y()), FPoint(p3.p2().x(), p3.p2().y()), FPoint(p4.p2().x(), p4.p2().y()), cp);
 			item->GrType = Gradient_Diamond;
@@ -3667,20 +3666,20 @@ void OdgPlug::finishItem(PageItem* item,
 			item->fill_gradient.addStop(gradColor2, 1.0 - gStyle.gradientBorder, 0.5, 1.0, gStyle.gradientStartColor, gStyle.gradientStartShade);
 			if (gStyle.gradientBorder != 0)
 				item->fill_gradient.addStop(ScColorEngine::getRGBColor(gradC2, m_Doc), 1.0, 0.5, 1.0, gStyle.gradientStartColor, gStyle.gradientStartShade);
-			FPoint cp = FPoint(item->width() * gStyle.gradientCenterX, item->height()* gStyle.gradientCenterY);
+			FPoint cp(item->width() * gStyle.gradientCenterX, item->height()* gStyle.gradientCenterY);
 			double gLenW = item->width() / 2.0;
 			double gLenH = item->height() / 2.0;
 
-			QPointF P1 = QPointF(0.0, 0.0);
-			QPointF P2 = QPointF(item->width(), 0.0);
-			QPointF P3 = QPointF(item->width(), item->height());
-			QPointF P4 = QPointF(0.0, item->height());
-			QLineF L1 = QLineF(0.0, 0.0, item->width(), 0.0);
+			QPointF P1(0.0, 0.0);
+			QPointF P2(item->width(), 0.0);
+			QPointF P3(item->width(), item->height());
+			QPointF P4(0.0, item->height());
+			QLineF L1(0.0, 0.0, item->width(), 0.0);
 			L1.setAngle(-45);
-			QLineF LCW = QLineF(0.0, item->height() / 2.0, item->width(), item->height() / 2.0);
+			QLineF LCW (0.0, item->height() / 2.0, item->width(), item->height() / 2.0);
 			QPointF P5;
 			LCW.intersects(L1, &P5);
-			QPointF P6 = QPointF(item->width() - P5.x(), P5.y());
+			QPointF P6(item->width() - P5.x(), P5.y());
 			QPolygonF pPoints;
 			pPoints << P1 << P2 << P3 << P4 << P5 << P6;
 			QTransform mat;
@@ -3766,13 +3765,13 @@ void OdgPlug::finishItem(PageItem* item,
 			item->GrType = Gradient_PatchMesh;
 */
 
-			QLineF p1 = QLineF(cp.x(), cp.y(), cp.x() - gLenW, cp.y() - gLenH);
+			QLineF p1(cp.x(), cp.y(), cp.x() - gLenW, cp.y() - gLenH);
 			p1.setAngle(p1.angle() + gStyle.gradientAngle);
-			QLineF p2 = QLineF(cp.x(), cp.y(), cp.x() + gLenW, cp.y() - gLenH);
+			QLineF p2(cp.x(), cp.y(), cp.x() + gLenW, cp.y() - gLenH);
 			p2.setAngle(p2.angle() + gStyle.gradientAngle);
-			QLineF p3 = QLineF(cp.x(), cp.y(), cp.x() + gLenW, cp.y() + gLenH);
+			QLineF p3(cp.x(), cp.y(), cp.x() + gLenW, cp.y() + gLenH);
 			p3.setAngle(p3.angle() + gStyle.gradientAngle);
-			QLineF p4 = QLineF(cp.x(), cp.y(), cp.x() - gLenW, cp.y() + gLenH);
+			QLineF p4(cp.x(), cp.y(), cp.x() - gLenW, cp.y() + gLenH);
 			p4.setAngle(p4.angle() + gStyle.gradientAngle);
 			item->setDiamondGeometry(FPoint(p1.p2().x(), p1.p2().y()), FPoint(p2.p2().x(), p2.p2().y()), FPoint(p3.p2().x(), p3.p2().y()), FPoint(p4.p2().x(), p4.p2().y()), cp);
 			item->GrType = Gradient_Diamond;
@@ -3828,7 +3827,7 @@ void OdgPlug::finishItem(PageItem* item,
 				if (uz->read(gStyle.patternPath, f))
 				{
 					QFileInfo fi(gStyle.patternPath);
-					QTemporaryFile *tempFile = new QTemporaryFile(QDir::tempPath() + "/scribus_temp_odg_XXXXXX." + fi.suffix());
+					auto *tempFile = new QTemporaryFile(QDir::tempPath() + "/scribus_temp_odg_XXXXXX." + fi.suffix());
 					tempFile->setAutoRemove(false);
 					if (tempFile->open())
 					{
@@ -3923,7 +3922,7 @@ void OdgPlug::finishItem(PageItem* item,
 					ext = "svm";
 				if (!ext.isEmpty())
 				{
-					QTemporaryFile *tempFile = new QTemporaryFile(QDir::tempPath() + "/scribus_temp_odg_XXXXXX." + ext);
+					auto *tempFile = new QTemporaryFile(QDir::tempPath() + "/scribus_temp_odg_XXXXXX." + ext);
 					tempFile->setAutoRemove(false);
 					if (tempFile->open())
 					{
@@ -4105,7 +4104,7 @@ void OdgPlug::finishItem(PageItem* item,
 				GrEndX = item->width() / 2.0;
 				GrEndY = item->height();
 			}
-			QLineF gradientVectorE = QLineF(GrStartX, GrStartY, GrEndX, GrEndY);
+			QLineF gradientVectorE(GrStartX, GrStartY, GrEndX, GrEndY);
 			gradientVectorE.setAngle(gStyle.gradientAngle);
 			GrEndX = gradientVectorE.p2().x();
 			GrEndY = gradientVectorE.p2().y();
diff -Naupr scribus-1.6.2/scribus/plugins/import/odg/importodg.h scribus16x/scribus/plugins/import/odg/importodg.h
--- scribus-1.6.2/scribus/plugins/import/odg/importodg.h	2024-06-15 16:22:26.000000000 +0200
+++ scribus16x/scribus/plugins/import/odg/importodg.h	2025-01-04 10:59:04.661411346 +0100
@@ -257,26 +257,26 @@ private:
 	void parseText(QDomElement &elem, PageItem* item, ObjStyle& tmpOStyle);
 	void insertChars(PageItem *item, QString &txt, ParagraphStyle &tmpStyle, CharStyle &tmpCStyle, int &posC);
 	void applyCharacterStyle(CharStyle &tmpCStyle, ObjStyle &oStyle);
-	void applyParagraphStyle(ParagraphStyle &tmpStyle, ObjStyle &oStyle);
-	void parseTransform(const QString &transform, double *rotation, double *transX, double *transY);
-	void parseTransform(FPointArray *composite, const QString &transform);
-	void parseViewBox( const QDomElement& object, double *x, double *y, double *w, double *h );
+	void applyParagraphStyle(ParagraphStyle &tmpStyle, ObjStyle &oStyle) const;
+	void parseTransform(const QString &transform, double *rotation, double *transX, double *transY) const;
+	void parseTransform(FPointArray *composite, const QString &transform) const;
+	void parseViewBox(const QDomElement& object, double *x, double *y, double *w, double *h) const;
 	void appendPoints(FPointArray *composite, const QDomElement& object, bool closePath);
 	void parseStyles(QDomElement &sp);
-	QString getStyleName(QDomElement &e);
+	QString getStyleName(QDomElement &e) const;
 	void resovleStyle(ObjStyle &tmpOStyle, const QString& pAttrs);
-	double parseUnit(const QString &unit);
-	const char * getCoord( const char *ptr, double &number );
+	double parseUnit(const QString &unit) const;
+	const char * getCoord( const char *ptr, double &number ) const;
 	bool parseEnhPath(const QString& svgPath, FPointArray &result, bool &fill, bool &stroke);
-	double angleFromPoint(const QPointF &point);
-	double radSweepAngle(double start, double stop, bool clockwise);
-	double degSweepAngle(double start, double stop, bool clockwise);
-	void arcTo(QPainterPath &path, QPointF startpoint, double rx, double ry, double startAngle, double sweepAngle);
-	int arcToCurve(double rx, double ry, double startAngle, double sweepAngle, const QPointF & offset, QPointF * curvePoints);
+	double angleFromPoint(const QPointF &point) const;
+	double radSweepAngle(double start, double stop, bool clockwise) const;
+	double degSweepAngle(double start, double stop, bool clockwise) const;
+	void arcTo(QPainterPath &path, QPointF startpoint, double rx, double ry, double startAngle, double sweepAngle) const;
+	int arcToCurve(double rx, double ry, double startAngle, double sweepAngle, const QPointF & offset, QPointF * curvePoints) const;
 	QString modifyColor(const QString& name, bool darker, int amount);
 	QString parseColor( const QString &s );
 	QString constructFontName(const QString& fontBaseName, const QString& fontStyle);
-	QPointF intersectBoundingRect(PageItem *item, QLineF gradientVector);
+	QPointF intersectBoundingRect(PageItem *item, QLineF gradientVector) const;
 	PageItem* applyStartArrow(PageItem* item, ObjStyle &obState);
 	PageItem* applyEndArrow(PageItem* ite, ObjStyle &obState);
 	PageItem* groupObjects(QList<PageItem*> &GElements);
diff -Naupr scribus-1.6.2/scribus/plugins/import/oodraw/oodrawimp.cpp scribus16x/scribus/plugins/import/oodraw/oodrawimp.cpp
--- scribus-1.6.2/scribus/plugins/import/oodraw/oodrawimp.cpp	2024-06-15 16:22:26.000000000 +0200
+++ scribus16x/scribus/plugins/import/oodraw/oodrawimp.cpp	2025-01-04 10:59:04.561413433 +0100
@@ -61,14 +61,14 @@ int oodrawimp_getPluginAPIVersion()
 
 ScPlugin* oodrawimp_getPlugin()
 {
-	OODrawImportPlugin* plug = new OODrawImportPlugin();
+	auto* plug = new OODrawImportPlugin();
 	Q_CHECK_PTR(plug);
 	return plug;
 }
 
 void oodrawimp_freePlugin(ScPlugin* plugin)
 {
-	OODrawImportPlugin* plug = qobject_cast<OODrawImportPlugin*>(plugin);
+	auto* plug = qobject_cast<OODrawImportPlugin*>(plugin);
 	Q_ASSERT(plug);
 	delete plug;
 }
@@ -106,7 +106,7 @@ QString OODrawImportPlugin::fullTrName()
 
 const ScActionPlugin::AboutData* OODrawImportPlugin::getAboutData() const
 {
-	AboutData* about = new AboutData;
+	auto* about = new AboutData;
 	about->authors = "Franz Schmid <franz@scribus.info>";
 	about->shortDescription = tr("Imports OpenOffice.org Draw Files");
 	about->description = tr("Imports most OpenOffice.org Draw files into the current document, converting their vector data into Scribus objects.");
@@ -216,7 +216,7 @@ QImage OODrawImportPlugin::readThumbnail
 		return QImage();
 	UndoManager::instance()->setUndoEnabled(false);
 	m_Doc = nullptr;
-	OODPlug *dia = new OODPlug(m_Doc);
+	auto *dia = new OODPlug(m_Doc);
 	Q_CHECK_PTR(dia);
 	QImage ret = dia->readThumbnail(fileName);
 	UndoManager::instance()->setUndoEnabled(true);
@@ -254,7 +254,6 @@ QImage OODPlug::readThumbnail(const QStr
 	QByteArray f3;
 	if (pZip->contains("meta.xml"))
 		pZip->read("meta.xml", f3);
-
 	pZip.reset();
 
 	HaveMeta = inpMeta.setContent(f3);
@@ -329,7 +328,7 @@ QImage OODPlug::readThumbnail(const QStr
 	for (int ec = 0; ec < el.count(); ++ec)
 		Elements.append(el.at(ec));
 	tmpSel->clear();
-	QImage tmpImage = QImage();
+	QImage tmpImage;
 	if (Elements.count() > 0)
 	{
 		if (Elements.count() > 1)
@@ -382,7 +381,6 @@ bool OODPlug::import(const QString& file
 	QByteArray f3;
 	if (pZip->contains("meta.xml"))
 		pZip->read("meta.xml", f3);
-	
 	pZip.reset();
 
 	HaveMeta = inpMeta.setContent(f3);
@@ -461,7 +459,7 @@ bool OODPlug::convert(const TransactionS
 			ret = true;
 		}
 	}
-	if ((ret) || (!interactive))
+	if (ret || !interactive)
 	{
 		if (width > height)
 			m_Doc->setPageOrientation(1);
@@ -492,13 +490,13 @@ bool OODPlug::convert(const TransactionS
 		mpg = mp.namedItem( "meta:keywords" );
 		if (!mpg.isNull())
 		{
-			QString Keys = "";
+			QString keys;
 			for (QDomNode n = mpg.firstChild(); !n.isNull(); n = n.nextSibling())
 			{
-				Keys += n.toElement().text()+", ";
+				keys += n.toElement().text()+", ";
 			}
-			if (Keys.length() > 2)
-				m_Doc->documentInfo().setKeywords(Keys.left(Keys.length()-2));
+			if (keys.length() > 2)
+				m_Doc->documentInfo().setKeywords(keys.left(keys.length() - 2));
 		}
 	}
 	if (!(flags & LoadSavePlugin::lfLoadAsPattern))
@@ -509,7 +507,7 @@ bool OODPlug::convert(const TransactionS
 	if (!(flags & LoadSavePlugin::lfLoadAsPattern))
 		m_Doc->view()->updatesOn(false);
 	m_Doc->scMW()->setScriptRunning(true);
-	qApp->setOverrideCursor(QCursor(Qt::WaitCursor));
+	QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
 	if (!m_Doc->PageColors.contains("Black"))
 		m_Doc->PageColors.insert("Black", ScColor(0, 0, 0, 255));
 	for (QDomNode drawPag = drawPagePNode.firstChild(); !drawPag.isNull(); drawPag = drawPag.nextSibling())
@@ -526,7 +524,7 @@ bool OODPlug::convert(const TransactionS
 		QList<PageItem*> el = parseGroup( dpg );
 		for (int ec = 0; ec < el.count(); ++ec)
 			Elements.append(el.at(ec));
-		if ((interactive) && (PageCounter == 1))
+		if (interactive && (PageCounter == 1))
 			break;
 	}
 	tmpSel->clear();
@@ -548,8 +546,8 @@ bool OODPlug::convert(const TransactionS
 	m_Doc->scMW()->setScriptRunning(false);
 	if (interactive)
 		m_Doc->setLoading(false);
-	qApp->changeOverrideCursor(QCursor(Qt::ArrowCursor));
-	if ((Elements.count() > 0) && (!ret) && (interactive))
+	QApplication::changeOverrideCursor(QCursor(Qt::ArrowCursor));
+	if ((Elements.count() > 0) && !ret && interactive)
 	{
 		if (flags & LoadSavePlugin::lfScripted)
 		{
@@ -587,7 +585,7 @@ bool OODPlug::convert(const TransactionS
 			m_Doc->m_Selection->delaySignalsOff();
 			// We must copy the TransationSettings object as it is owned
 			// by handleObjectImport method afterwards
-			TransactionSettings* transacSettings = new TransactionSettings(trSettings);
+			auto* transacSettings = new TransactionSettings(trSettings);
 			m_Doc->view()->handleObjectImport(md, transacSettings);
 			m_Doc->DragP = false;
 			m_Doc->DraggedElem = nullptr;
@@ -604,7 +602,7 @@ bool OODPlug::convert(const TransactionS
 			m_Doc->view()->updatesOn(true);
 		m_Doc->setLoading(loadF);
 	}
-	qApp->restoreOverrideCursor();
+	QApplication::restoreOverrideCursor();
 	return true;
 }
 
@@ -613,13 +611,8 @@ QList<PageItem*> OODPlug::parseGroup(con
 	OODrawStyle oostyle;
 	FPointArray ImgClip;
 	QList<PageItem*> elements, cElements;
-//	double BaseX = m_Doc->currentPage()->xOffset();
-//	double BaseY = m_Doc->currentPage()->yOffset();
 	storeObjectStyles(e);
 	parseStyle(oostyle, e);
-//	QString drawID = e.attribute("draw:name");
-//	int zn = m_Doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, BaseX, BaseY, 1, 1, 0, CommonStrings::None, CommonStrings::None);
-//	PageItem *neu = m_Doc->Items->at(zn);
 	for (QDomNode n = e.firstChild(); !n.isNull(); n = n.nextSibling())
 	{
 		QDomElement b = n.toElement();
@@ -1026,9 +1019,8 @@ void OODPlug::parseStyle(OODrawStyle& oo
 						oostyle.gradientPointY = 0.5;
 					oostyle.gradientType = 2;
 				}
-				QString c, c2;
-				c = parseColor( draw->attribute( "draw:start-color" ) );
-				c2 = parseColor( draw->attribute( "draw:end-color" ) );
+				QString c = parseColor( draw->attribute( "draw:start-color" ) );
+				QString c2 = parseColor( draw->attribute( "draw:end-color" ) );
 				const ScColor& col1 = m_Doc->PageColors[c];
 				const ScColor& col2 = m_Doc->PageColors[c2];
 				if (((oostyle.gradientAngle > 90) && (oostyle.gradientAngle < 271)) || (oostyle.gradientType == 2))
@@ -1048,7 +1040,7 @@ void OODPlug::parseStyle(OODrawStyle& oo
 	}
 }
 
-void OODPlug::parseCharStyle(CharStyle& style, const QDomElement &e)
+void OODPlug::parseCharStyle(CharStyle& style, const QDomElement &e) const
 {
 	if (m_styleStack.hasAttribute("fo:font-size"))
 	{
@@ -1058,7 +1050,7 @@ void OODPlug::parseCharStyle(CharStyle&
 	}
 }
 
-void OODPlug::parseParagraphStyle(ParagraphStyle& style, const QDomElement &e)
+void OODPlug::parseParagraphStyle(ParagraphStyle& style, const QDomElement &e) const
 {
 	if (m_styleStack.hasAttribute("fo:text-align"))
 	{
@@ -1079,7 +1071,7 @@ void OODPlug::parseParagraphStyle(Paragr
 	}
 }
 
-PageItem* OODPlug::parseTextP (const QDomElement& elm, PageItem* item)
+PageItem* OODPlug::parseTextP(const QDomElement& elm, PageItem* item)
 {
 	for ( QDomNode n = elm.firstChild(); !n.isNull(); n = n.nextSibling() )
 	{
@@ -1373,23 +1365,23 @@ QString OODPlug::parseColor( const QStri
 	{
 		QString parse = s.trimmed();
 		QStringList colors = parse.split( ',', Qt::SkipEmptyParts );
-		QString r = colors[0].right( ( colors[0].length() - 4 ) );
+		QString r = colors[0].right(colors[0].length() - 4);
 		QString g = colors[1];
-		QString b = colors[2].left( ( colors[2].length() - 1 ) );
+		QString b = colors[2].left(colors[2].length() - 1);
 		if (r.contains( "%" ))
 		{
 			r.chop(1);
-			r = QString::number( static_cast<int>( ( static_cast<double>( 255 * ScCLocale::toDoubleC(r) ) / 100.0 ) ) );
+			r = QString::number( static_cast<int>(2.55 * ScCLocale::toDoubleC(r)) );
 		}
 		if (g.contains( "%" ))
 		{
 			g.chop(1);
-			g = QString::number( static_cast<int>( ( static_cast<double>( 255 * ScCLocale::toDoubleC(g) ) / 100.0 ) ) );
+			g = QString::number( static_cast<int>(2.55 * ScCLocale::toDoubleC(g)) );
 		}
 		if (b.contains( "%" ) )
 		{
 			b.chop(1);
-			b = QString::number( static_cast<int>( ( static_cast<double>( 255 * ScCLocale::toDoubleC(b) ) / 100.0 ) ) );
+			b = QString::number( static_cast<int>(2.55 * ScCLocale::toDoubleC(b)) );
 		}
 		c = QColor(r.toInt(), g.toInt(), b.toInt());
 	}
@@ -1407,7 +1399,7 @@ QString OODPlug::parseColor( const QStri
 	return ret;
 }
 
-void OODPlug::parseTransform(FPointArray *composite, const QString &transform)
+void OODPlug::parseTransform(FPointArray *composite, const QString &transform) const
 {
 	double dx, dy;
 	QTransform result;
@@ -1460,7 +1452,7 @@ void OODPlug::parseTransform(FPointArray
 	}
 }
 
-void OODPlug::parseViewBox(const QDomElement& object, double *x, double *y, double *w, double *h)
+void OODPlug::parseViewBox(const QDomElement& object, double *x, double *y, double *w, double *h) const
 {
 	if (!object.attribute( "svg:viewBox" ).isEmpty())
 	{
@@ -1473,7 +1465,7 @@ void OODPlug::parseViewBox(const QDomEle
 	}
 }
 
-void OODPlug::appendPoints(FPointArray *composite, const QDomElement& object, bool closePath)
+void OODPlug::appendPoints(FPointArray *composite, const QDomElement& object, bool closePath) const
 {
 	double x = parseUnit(object.attribute("svg:x"));
 	double y = parseUnit(object.attribute("svg:y")) ;
@@ -1489,7 +1481,7 @@ void OODPlug::appendPoints(FPointArray *
 	QStringList ptList = object.attribute( "draw:points" ).split( ' ', Qt::SkipEmptyParts );
 	FPoint point, firstP;
 	bool bFirst = true;
-	for (QStringList::Iterator it = ptList.begin(); it != ptList.end(); ++it)
+	for (auto it = ptList.begin(); it != ptList.end(); ++it)
 	{
 		point = FPoint(ScCLocale::toDoubleC((*it).section( ',', 0, 0 )), ScCLocale::toDoubleC((*it).section( ',', 1, 1 )));
 		if (bFirst)
@@ -1518,18 +1510,14 @@ void OODPlug::appendPoints(FPointArray *
 	composite->map(mat);
 }
 
-const char * OODPlug::getCoord( const char *ptr, double &number )
+const char * OODPlug::getCoord(const char *ptr, double &number) const
 {
-	int integer, exponent;
-	double decimal, frac;
-	int sign, expsign;
-
-	exponent = 0;
-	integer = 0;
-	frac = 1.0;
-	decimal = 0;
-	sign = 1;
-	expsign = 1;
+	int exponent = 0;
+	int integer = 0;
+	int sign = 1;
+	int expsign = 1;
+	double frac = 1.0;
+	double decimal = 0;
 
 	// read the sign
 	if (*ptr == '+')
@@ -1581,233 +1569,232 @@ const char * OODPlug::getCoord( const ch
 	return ptr;
 }
 
-bool OODPlug::parseSVG(const QString &s, FPointArray *ite)
+bool OODPlug::parseSVG(const QString &s, FPointArray *pts)
 {
 	QString d = s;
 	d = d.replace( QRegExp( "," ), " ");
+	if (d.isEmpty())
+		return false;
 	bool ret = false;
-	if (!d.isEmpty())
+
+	d = d.simplified();
+	QByteArray data = d.toLatin1();
+	const char *ptr = data.constData();
+	const char *end = data.constData() + data.length() + 1;
+	double contrlx, contrly, curx, cury, tox, toy, x1, y1, x2, y2, xc, yc;
+	double px1, py1, px2, py2, px3, py3;
+	bool relative;
+	char command = *(ptr++);
+	char lastCommand = ' ';
+
+	FirstM = true;
+	curx = cury = contrlx = contrly = 0.0;
+	while (ptr < end)
 	{
-		d = d.simplified();
-		QByteArray data = d.toLatin1();
-		const char *ptr = data.constData();
-		const char *end = data.constData() + data.length() + 1;
-		double contrlx, contrly, curx, cury, tox, toy, x1, y1, x2, y2, xc, yc;
-		double px1, py1, px2, py2, px3, py3;
-		bool relative;
-		FirstM = true;
-		char command = *(ptr++), lastCommand = ' ';
-		curx = cury = contrlx = contrly = 0.0;
-		while (ptr < end)
-		{
-			if (*ptr == ' ')
-				ptr++;
-			relative = false;
-			switch (command)
-			{
-			case 'm':
-				relative = true;
-			case 'M':
-				{
-					ptr = getCoord( ptr, tox );
-					ptr = getCoord( ptr, toy );
-					WasM = true;
-					curx = relative ? curx + tox : tox;
-					cury = relative ? cury + toy : toy;
-					svgMoveTo(curx, cury );
-					break;
-				}
-			case 'l':
-				relative = true;
-			case 'L':
-				{
-					ptr = getCoord( ptr, tox );
-					ptr = getCoord( ptr, toy );
-					curx = relative ? curx + tox : tox;
-					cury = relative ? cury + toy : toy;
-					svgLineTo(ite, curx, cury );
-					break;
-				}
-			case 'h':
-				{
-					ptr = getCoord( ptr, tox );
-					curx = curx + tox;
-					svgLineTo(ite, curx, cury );
-					break;
-				}
-			case 'H':
-				{
-					ptr = getCoord( ptr, tox );
-					curx = tox;
-					svgLineTo(ite, curx, cury );
-					break;
-				}
-			case 'v':
-				{
-					ptr = getCoord( ptr, toy );
-					cury = cury + toy;
-					svgLineTo(ite, curx, cury );
-					break;
-				}
-			case 'V':
-				{
-					ptr = getCoord( ptr, toy );
-					cury = toy;
-					svgLineTo(ite,  curx, cury );
-					break;
-				}
-			case 'z':
-			case 'Z':
-				{
-					svgClosePath(ite);
-					break;
-				}
-			case 'c':
-				relative = true;
-			case 'C':
-				{
-					ptr = getCoord( ptr, x1 );
-					ptr = getCoord( ptr, y1 );
-					ptr = getCoord( ptr, x2 );
-					ptr = getCoord( ptr, y2 );
-					ptr = getCoord( ptr, tox );
-					ptr = getCoord( ptr, toy );
-					px1 = relative ? curx + x1 : x1;
-					py1 = relative ? cury + y1 : y1;
-					px2 = relative ? curx + x2 : x2;
-					py2 = relative ? cury + y2 : y2;
-					px3 = relative ? curx + tox : tox;
-					py3 = relative ? cury + toy : toy;
-					svgCurveToCubic(ite, px1, py1, px2, py2, px3, py3 );
-					contrlx = relative ? curx + x2 : x2;
-					contrly = relative ? cury + y2 : y2;
-					curx = relative ? curx + tox : tox;
-					cury = relative ? cury + toy : toy;
-					break;
-				}
-			case 's':
-				relative = true;
-			case 'S':
-				{
-					ptr = getCoord( ptr, x2 );
-					ptr = getCoord( ptr, y2 );
-					ptr = getCoord( ptr, tox );
-					ptr = getCoord( ptr, toy );
-					px1 = 2 * curx - contrlx;
-					py1 = 2 * cury - contrly;
-					px2 = relative ? curx + x2 : x2;
-					py2 = relative ? cury + y2 : y2;
-					px3 = relative ? curx + tox : tox;
-					py3 = relative ? cury + toy : toy;
-					svgCurveToCubic(ite, px1, py1, px2, py2, px3, py3 );
-					contrlx = relative ? curx + x2 : x2;
-					contrly = relative ? cury + y2 : y2;
-					curx = relative ? curx + tox : tox;
-					cury = relative ? cury + toy : toy;
-					break;
-				}
-			case 'q':
-				relative = true;
-			case 'Q':
-				{
-					ptr = getCoord( ptr, x1 );
-					ptr = getCoord( ptr, y1 );
-					ptr = getCoord( ptr, tox );
-					ptr = getCoord( ptr, toy );
-					px1 = relative ? (curx + 2 * (x1 + curx)) * (1.0 / 3.0) : (curx + 2 * x1) * (1.0 / 3.0);
-					py1 = relative ? (cury + 2 * (y1 + cury)) * (1.0 / 3.0) : (cury + 2 * y1) * (1.0 / 3.0);
-					px2 = relative ? ((curx + tox) + 2 * (x1 + curx)) * (1.0 / 3.0) : (tox + 2 * x1) * (1.0 / 3.0);
-					py2 = relative ? ((cury + toy) + 2 * (y1 + cury)) * (1.0 / 3.0) : (toy + 2 * y1) * (1.0 / 3.0);
-					px3 = relative ? curx + tox : tox;
-					py3 = relative ? cury + toy : toy;
-					svgCurveToCubic(ite, px1, py1, px2, py2, px3, py3 );
-					contrlx = relative ? curx + x1 : (tox + 2 * x1) * (1.0 / 3.0);
-					contrly = relative ? cury + y1 : (toy + 2 * y1) * (1.0 / 3.0);
-					curx = relative ? curx + tox : tox;
-					cury = relative ? cury + toy : toy;
-					break;
-				}
-			case 't':
-				relative = true;
-			case 'T':
-				{
-					ptr = getCoord(ptr, tox);
-					ptr = getCoord(ptr, toy);
-					xc = 2 * curx - contrlx;
-					yc = 2 * cury - contrly;
-					px1 = relative ? (curx + 2 * xc) * (1.0 / 3.0) : (curx + 2 * xc) * (1.0 / 3.0);
-					py1 = relative ? (cury + 2 * yc) * (1.0 / 3.0) : (cury + 2 * yc) * (1.0 / 3.0);
-					px2 = relative ? ((curx + tox) + 2 * xc) * (1.0 / 3.0) : (tox + 2 * xc) * (1.0 / 3.0);
-					py2 = relative ? ((cury + toy) + 2 * yc) * (1.0 / 3.0) : (toy + 2 * yc) * (1.0 / 3.0);
-					px3 = relative ? curx + tox : tox;
-					py3 = relative ? cury + toy : toy;
-					svgCurveToCubic(ite, px1, py1, px2, py2, px3, py3 );
-					contrlx = xc;
-					contrly = yc;
-					curx = relative ? curx + tox : tox;
-					cury = relative ? cury + toy : toy;
-					break;
-				}
-			case 'a':
-				relative = true;
-			case 'A':
-				{
-					bool largeArc, sweep;
-					double angle, rx, ry;
-					ptr = getCoord( ptr, rx );
-					ptr = getCoord( ptr, ry );
-					ptr = getCoord( ptr, angle );
-					ptr = getCoord( ptr, tox );
-					largeArc = tox == 1;
-					ptr = getCoord( ptr, tox );
-					sweep = tox == 1;
-					ptr = getCoord( ptr, tox );
-					ptr = getCoord( ptr, toy );
-					calculateArc(ite, relative, curx, cury, angle, tox, toy, rx, ry, largeArc, sweep );
-				}
+		if (*ptr == ' ')
+			ptr++;
+		relative = false;
+		switch (command)
+		{
+		case 'm':
+			relative = true;
+		case 'M':
+			{
+				ptr = getCoord( ptr, tox );
+				ptr = getCoord( ptr, toy );
+				WasM = true;
+				curx = relative ? curx + tox : tox;
+				cury = relative ? cury + toy : toy;
+				svgMoveTo(curx, cury );
+				break;
 			}
-			lastCommand = command;
-			if (*ptr == '+' || *ptr == '-' || (*ptr >= '0' && *ptr <= '9'))
+		case 'l':
+			relative = true;
+		case 'L':
 			{
-				// there are still coords in this command
-				if (command == 'M')
-					command = 'L';
-				else if (command == 'm')
-					command = 'l';
+				ptr = getCoord( ptr, tox );
+				ptr = getCoord( ptr, toy );
+				curx = relative ? curx + tox : tox;
+				cury = relative ? cury + toy : toy;
+				svgLineTo(pts, curx, cury );
+				break;
 			}
-			else
-				command = *(ptr++);
-
-			if (lastCommand != 'C' && lastCommand != 'c' &&
-			        lastCommand != 'S' && lastCommand != 's' &&
-			        lastCommand != 'Q' && lastCommand != 'q' &&
-			        lastCommand != 'T' && lastCommand != 't')
+		case 'h':
+			{
+				ptr = getCoord( ptr, tox );
+				curx = curx + tox;
+				svgLineTo(pts, curx, cury );
+				break;
+			}
+		case 'H':
 			{
-				contrlx = curx;
-				contrly = cury;
+				ptr = getCoord( ptr, tox );
+				curx = tox;
+				svgLineTo(pts, curx, cury );
+				break;
+			}
+		case 'v':
+			{
+				ptr = getCoord( ptr, toy );
+				cury = cury + toy;
+				svgLineTo(pts, curx, cury );
+				break;
+			}
+		case 'V':
+			{
+				ptr = getCoord( ptr, toy );
+				cury = toy;
+				svgLineTo(pts,  curx, cury );
+				break;
+			}
+		case 'z':
+		case 'Z':
+			{
+				svgClosePath(pts);
+				break;
+			}
+		case 'c':
+			relative = true;
+		case 'C':
+			{
+				ptr = getCoord( ptr, x1 );
+				ptr = getCoord( ptr, y1 );
+				ptr = getCoord( ptr, x2 );
+				ptr = getCoord( ptr, y2 );
+				ptr = getCoord( ptr, tox );
+				ptr = getCoord( ptr, toy );
+				px1 = relative ? curx + x1 : x1;
+				py1 = relative ? cury + y1 : y1;
+				px2 = relative ? curx + x2 : x2;
+				py2 = relative ? cury + y2 : y2;
+				px3 = relative ? curx + tox : tox;
+				py3 = relative ? cury + toy : toy;
+				svgCurveToCubic(pts, px1, py1, px2, py2, px3, py3 );
+				contrlx = relative ? curx + x2 : x2;
+				contrly = relative ? cury + y2 : y2;
+				curx = relative ? curx + tox : tox;
+				cury = relative ? cury + toy : toy;
+				break;
+			}
+		case 's':
+			relative = true;
+		case 'S':
+			{
+				ptr = getCoord( ptr, x2 );
+				ptr = getCoord( ptr, y2 );
+				ptr = getCoord( ptr, tox );
+				ptr = getCoord( ptr, toy );
+				px1 = 2 * curx - contrlx;
+				py1 = 2 * cury - contrly;
+				px2 = relative ? curx + x2 : x2;
+				py2 = relative ? cury + y2 : y2;
+				px3 = relative ? curx + tox : tox;
+				py3 = relative ? cury + toy : toy;
+				svgCurveToCubic(pts, px1, py1, px2, py2, px3, py3 );
+				contrlx = relative ? curx + x2 : x2;
+				contrly = relative ? cury + y2 : y2;
+				curx = relative ? curx + tox : tox;
+				cury = relative ? cury + toy : toy;
+				break;
+			}
+		case 'q':
+			relative = true;
+		case 'Q':
+			{
+				ptr = getCoord( ptr, x1 );
+				ptr = getCoord( ptr, y1 );
+				ptr = getCoord( ptr, tox );
+				ptr = getCoord( ptr, toy );
+				px1 = relative ? (curx + 2 * (x1 + curx)) * (1.0 / 3.0) : (curx + 2 * x1) * (1.0 / 3.0);
+				py1 = relative ? (cury + 2 * (y1 + cury)) * (1.0 / 3.0) : (cury + 2 * y1) * (1.0 / 3.0);
+				px2 = relative ? ((curx + tox) + 2 * (x1 + curx)) * (1.0 / 3.0) : (tox + 2 * x1) * (1.0 / 3.0);
+				py2 = relative ? ((cury + toy) + 2 * (y1 + cury)) * (1.0 / 3.0) : (toy + 2 * y1) * (1.0 / 3.0);
+				px3 = relative ? curx + tox : tox;
+				py3 = relative ? cury + toy : toy;
+				svgCurveToCubic(pts, px1, py1, px2, py2, px3, py3 );
+				contrlx = relative ? curx + x1 : (tox + 2 * x1) * (1.0 / 3.0);
+				contrly = relative ? cury + y1 : (toy + 2 * y1) * (1.0 / 3.0);
+				curx = relative ? curx + tox : tox;
+				cury = relative ? cury + toy : toy;
+				break;
+			}
+		case 't':
+			relative = true;
+		case 'T':
+			{
+				ptr = getCoord(ptr, tox);
+				ptr = getCoord(ptr, toy);
+				xc = 2 * curx - contrlx;
+				yc = 2 * cury - contrly;
+				px1 = (curx + 2 * xc) * (1.0 / 3.0);
+				py1 = (cury + 2 * yc) * (1.0 / 3.0);
+				px2 = relative ? ((curx + tox) + 2 * xc) * (1.0 / 3.0) : (tox + 2 * xc) * (1.0 / 3.0);
+				py2 = relative ? ((cury + toy) + 2 * yc) * (1.0 / 3.0) : (toy + 2 * yc) * (1.0 / 3.0);
+				px3 = relative ? curx + tox : tox;
+				py3 = relative ? cury + toy : toy;
+				svgCurveToCubic(pts, px1, py1, px2, py2, px3, py3 );
+				contrlx = xc;
+				contrly = yc;
+				curx = relative ? curx + tox : tox;
+				cury = relative ? cury + toy : toy;
+				break;
+			}
+		case 'a':
+			relative = true;
+		case 'A':
+			{
+				bool largeArc, sweep;
+				double angle, rx, ry;
+				ptr = getCoord( ptr, rx );
+				ptr = getCoord( ptr, ry );
+				ptr = getCoord( ptr, angle );
+				ptr = getCoord( ptr, tox );
+				largeArc = tox == 1;
+				ptr = getCoord( ptr, tox );
+				sweep = tox == 1;
+				ptr = getCoord( ptr, tox );
+				ptr = getCoord( ptr, toy );
+				calculateArc(pts, relative, curx, cury, angle, tox, toy, rx, ry, largeArc, sweep );
 			}
 		}
-		if ((lastCommand != 'z') && (lastCommand != 'Z'))
-			ret = true;
-		if (ite->size() > 2)
+		lastCommand = command;
+		if (*ptr == '+' || *ptr == '-' || (*ptr >= '0' && *ptr <= '9'))
 		{
-			if ((ite->point(0).x() == ite->point(ite->size()-2).x()) && (ite->point(0).y() == ite->point(ite->size()-2).y()))
-				ret = false;
+			// there are still coords in this command
+			if (command == 'M')
+				command = 'L';
+			else if (command == 'm')
+				command = 'l';
+		}
+		else
+			command = *(ptr++);
+
+		if (lastCommand != 'C' && lastCommand != 'c' &&
+			    lastCommand != 'S' && lastCommand != 's' &&
+			    lastCommand != 'Q' && lastCommand != 'q' &&
+			    lastCommand != 'T' && lastCommand != 't')
+		{
+			contrlx = curx;
+			contrly = cury;
 		}
 	}
+	if ((lastCommand != 'z') && (lastCommand != 'Z'))
+		ret = true;
+	if (pts->size() > 2)
+	{
+		if ((pts->point(0).x() == pts->point(pts->size()-2).x()) && (pts->point(0).y() == pts->point(pts->size()-2).y()))
+			ret = false;
+	}
+
 	return ret;
 }
 
-void OODPlug::calculateArc(FPointArray *ite, bool relative, double &curx, double &cury, double angle, double x, double y, double r1, double r2, bool largeArcFlag, bool sweepFlag)
+void OODPlug::calculateArc(FPointArray *pts, bool relative, double &curx, double &cury, double angle, double x, double y, double r1, double r2, bool largeArcFlag, bool sweepFlag)
 {
-	double sin_th, cos_th;
-	double a00, a01, a10, a11;
-	double x0, y0, x1, y1, xc, yc;
-	double d, sfactor, sfactor_sq;
-	double th0, th1, th_arc;
-	int i, n_segs;
-	sin_th = sin(angle * (M_PI / 180.0));
-	cos_th = cos(angle * (M_PI / 180.0));
+	double x1, y1;
+	double sin_th = sin(angle * (M_PI / 180.0));
+	double cos_th = cos(angle * (M_PI / 180.0));
+
 	double dx;
 	if (!relative)
 		dx = (curx - x) / 2.0;
@@ -1818,6 +1805,7 @@ void OODPlug::calculateArc(FPointArray *
 		dy = (cury - y) / 2.0;
 	else
 		dy = -y / 2.0;
+
 	double _x1 =  cos_th * dx + sin_th * dy;
 	double _y1 = -sin_th * dx + cos_th * dy;
 	double Pr1 = r1 * r1;
@@ -1830,12 +1818,13 @@ void OODPlug::calculateArc(FPointArray *
 		r1 = r1 * sqrt(check);
 		r2 = r2 * sqrt(check);
 	}
-	a00 = cos_th / r1;
-	a01 = sin_th / r1;
-	a10 = -sin_th / r2;
-	a11 = cos_th / r2;
-	x0 = a00 * curx + a01 * cury;
-	y0 = a10 * curx + a11 * cury;
+
+	double a00 = cos_th / r1;
+	double a01 = sin_th / r1;
+	double a10 = -sin_th / r2;
+	double a11 = cos_th / r2;
+	double x0 = a00 * curx + a01 * cury;
+	double y0 = a10 * curx + a11 * cury;
 	if (!relative)
 		x1 = a00 * x + a01 * y;
 	else
@@ -1844,51 +1833,53 @@ void OODPlug::calculateArc(FPointArray *
 		y1 = a10 * x + a11 * y;
 	else
 		y1 = a10 * (curx + x) + a11 * (cury + y);
-	d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
-	sfactor_sq = 1.0 / d - 0.25;
+	double d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
+
+	double sfactor_sq = 1.0 / d - 0.25;
 	if (sfactor_sq < 0)
 		sfactor_sq = 0;
-	sfactor = sqrt(sfactor_sq);
+	double sfactor = sqrt(sfactor_sq);
 	if (sweepFlag == largeArcFlag)
 		sfactor = -sfactor;
-	xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
-	yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
 
-	th0 = atan2(y0 - yc, x0 - xc);
-	th1 = atan2(y1 - yc, x1 - xc);
-	th_arc = th1 - th0;
+	double xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
+	double yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
+
+	double th0 = atan2(y0 - yc, x0 - xc);
+	double th1 = atan2(y1 - yc, x1 - xc);
+	double th_arc = th1 - th0;
 	if (th_arc < 0 && sweepFlag)
 		th_arc += 2 * M_PI;
 	else if (th_arc > 0 && !sweepFlag)
 		th_arc -= 2 * M_PI;
-	n_segs = static_cast<int>(ceil(fabs(th_arc / (M_PI * 0.5 + 0.001))));
-	for (i = 0; i < n_segs; i++)
+
+	int n_segs = static_cast<int>(ceil(fabs(th_arc / (M_PI * 0.5 + 0.001))));
+	for (int i = 0; i < n_segs; i++)
 	{
-		{
-			double sin_th, cos_th;
-			double a00, a01, a10, a11;
-			double x1, y1, x2, y2, x3, y3;
-			double t;
-			double th_half;
-			double _th0 = th0 + i * th_arc / n_segs;
-			double _th1 = th0 + (i + 1) * th_arc / n_segs;
-			sin_th = sin(angle * (M_PI / 180.0));
-			cos_th = cos(angle * (M_PI / 180.0));
-			a00 = cos_th * r1;
-			a01 = -sin_th * r2;
-			a10 = sin_th * r1;
-			a11 = cos_th * r2;
-			th_half = 0.5 * (_th1 - _th0);
-			t = (8.0 / 3.0) * sin(th_half * 0.5) * sin(th_half * 0.5) / sin(th_half);
-			x1 = xc + cos(_th0) - t * sin(_th0);
-			y1 = yc + sin(_th0) + t * cos(_th0);
-			x3 = xc + cos(_th1);
-			y3 = yc + sin(_th1);
-			x2 = x3 + t * sin(_th1);
-			y2 = y3 - t * cos(_th1);
-			svgCurveToCubic(ite, a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3 );
-		}
+		double sin_th, cos_th;
+		double a00, a01, a10, a11;
+		double x1, y1, x2, y2, x3, y3;
+		double t;
+		double th_half;
+		double _th0 = th0 + i * th_arc / n_segs;
+		double _th1 = th0 + (i + 1) * th_arc / n_segs;
+		sin_th = sin(angle * (M_PI / 180.0));
+		cos_th = cos(angle * (M_PI / 180.0));
+		a00 = cos_th * r1;
+		a01 = -sin_th * r2;
+		a10 = sin_th * r1;
+		a11 = cos_th * r2;
+		th_half = 0.5 * (_th1 - _th0);
+		t = (8.0 / 3.0) * sin(th_half * 0.5) * sin(th_half * 0.5) / sin(th_half);
+		x1 = xc + cos(_th0) - t * sin(_th0);
+		y1 = yc + sin(_th0) + t * cos(_th0);
+		x3 = xc + cos(_th1);
+		y3 = yc + sin(_th1);
+		x2 = x3 + t * sin(_th1);
+		y2 = y3 - t * cos(_th1);
+		svgCurveToCubic(pts, a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3 );
 	}
+
 	if (!relative)
 		curx = x;
 	else
@@ -1908,76 +1899,76 @@ void OODPlug::svgMoveTo(double x1, doubl
 	PathLen = 0;
 }
 
-void OODPlug::svgLineTo(FPointArray *i, double x1, double y1)
+void OODPlug::svgLineTo(FPointArray *pts, double x1, double y1)
 {
-	if ((!FirstM) && (WasM))
+	if (!FirstM && WasM)
 	{
-		i->setMarker();
+		pts->setMarker();
 		PathLen += 4;
 	}
 	FirstM = false;
 	WasM = false;
-	if (i->size() > 3)
+	if (pts->size() > 3)
 	{
-		const FPoint& b1 = i->point(i->size()-4);
-		const FPoint& b2 = i->point(i->size()-3);
-		const FPoint& b3 = i->point(i->size()-2);
-		const FPoint& b4 = i->point(i->size()-1);
-		FPoint n1 = FPoint(CurrX, CurrY);
-		FPoint n2 = FPoint(x1, y1);
+		const FPoint& b1 = pts->point(pts->size() - 4);
+		const FPoint& b2 = pts->point(pts->size() - 3);
+		const FPoint& b3 = pts->point(pts->size() - 2);
+		const FPoint& b4 = pts->point(pts->size() - 1);
+		FPoint n1(CurrX, CurrY);
+		FPoint n2(x1, y1);
 		if ((b1 == n1) && (b2 == n1) && (b3 == n2) && (b4 == n2))
 			return;
 	}
-	i->addPoint(FPoint(CurrX, CurrY));
-	i->addPoint(FPoint(CurrX, CurrY));
-	i->addPoint(FPoint(x1, y1));
-	i->addPoint(FPoint(x1, y1));
+	pts->addPoint(FPoint(CurrX, CurrY));
+	pts->addPoint(FPoint(CurrX, CurrY));
+	pts->addPoint(FPoint(x1, y1));
+	pts->addPoint(FPoint(x1, y1));
 	CurrX = x1;
 	CurrY = y1;
 	PathLen += 4;
 }
 
-void OODPlug::svgCurveToCubic(FPointArray *i, double x1, double y1, double x2, double y2, double x3, double y3)
+void OODPlug::svgCurveToCubic(FPointArray *pts, double x1, double y1, double x2, double y2, double x3, double y3)
 {
-	if ((!FirstM) && (WasM))
+	if (!FirstM && WasM)
 	{
-		i->setMarker();
+		pts->setMarker();
 		PathLen += 4;
 	}
 	FirstM = false;
 	WasM = false;
 	if (PathLen > 3)
 	{
-		const FPoint& b1 = i->point(i->size()-4);
-		const FPoint& b2 = i->point(i->size()-3);
-		const FPoint& b3 = i->point(i->size()-2);
-		const FPoint& b4 = i->point(i->size()-1);
-		FPoint n1 = FPoint(CurrX, CurrY);
-		FPoint n2 = FPoint(x1, y1);
-		FPoint n3 = FPoint(x3, y3);
-		FPoint n4 = FPoint(x2, y2);
+		const FPoint& b1 = pts->point(pts->size() - 4);
+		const FPoint& b2 = pts->point(pts->size() - 3);
+		const FPoint& b3 = pts->point(pts->size() - 2);
+		const FPoint& b4 = pts->point(pts->size() - 1);
+		FPoint n1(CurrX, CurrY);
+		FPoint n2(x1, y1);
+		FPoint n3(x3, y3);
+		FPoint n4(x2, y2);
 		if ((b1 == n1) && (b2 == n2) && (b3 == n3) && (b4 == n4))
 			return;
 	}
-	i->addPoint(FPoint(CurrX, CurrY));
-	i->addPoint(FPoint(x1, y1));
-	i->addPoint(FPoint(x3, y3));
-	i->addPoint(FPoint(x2, y2));
+	pts->addPoint(FPoint(CurrX, CurrY));
+	pts->addPoint(FPoint(x1, y1));
+	pts->addPoint(FPoint(x3, y3));
+	pts->addPoint(FPoint(x2, y2));
 	CurrX = x3;
 	CurrY = y3;
 	PathLen += 4;
 }
 
-void OODPlug::svgClosePath(FPointArray *i)
+void OODPlug::svgClosePath(FPointArray *pts) const
 {
 	if (PathLen > 2)
 	{
-		if ((PathLen == 4) || (i->point(i->size()-2).x() != StartX) || (i->point(i->size()-2).y() != StartY))
+		if ((PathLen == 4) || (pts->point(pts->size() - 2).x() != StartX) || (pts->point(pts->size() - 2).y() != StartY))
 		{
-			i->addPoint(i->point(i->size()-2));
-			i->addPoint(i->point(i->size()-3));
-			i->addPoint(FPoint(StartX, StartY));
-			i->addPoint(FPoint(StartX, StartY));
+			pts->addPoint(pts->point(pts->size() - 2));
+			pts->addPoint(pts->point(pts->size() - 3));
+			pts->addPoint(FPoint(StartX, StartY));
+			pts->addPoint(FPoint(StartX, StartY));
 		}
 	}
 }
diff -Naupr scribus-1.6.2/scribus/plugins/import/oodraw/oodrawimp.h scribus16x/scribus/plugins/import/oodraw/oodrawimp.h
--- scribus-1.6.2/scribus/plugins/import/oodraw/oodrawimp.h	2024-06-15 16:22:26.000000000 +0200
+++ scribus16x/scribus/plugins/import/oodraw/oodrawimp.h	2025-01-04 10:59:04.561413433 +0100
@@ -109,8 +109,8 @@ protected:
 	QList<PageItem*> parseFrame(const QDomElement &e);
 	QList<PageItem*> parseConnector(const QDomElement &e);
 	void parseStyle(OODrawStyle& style, const QDomElement &e);
-	void parseCharStyle(CharStyle& style, const QDomElement &e);
-	void parseParagraphStyle(ParagraphStyle& style, const QDomElement &e);
+	void parseCharStyle(CharStyle& style, const QDomElement &e) const;
+	void parseParagraphStyle(ParagraphStyle& style, const QDomElement &e) const;
 	PageItem* parseTextP(const QDomElement& e, PageItem* item);
 	PageItem* parseTextSpans(const QDomElement& elm, PageItem* item);
 	PageItem* finishNodeParsing(const QDomElement &elm, PageItem* item, OODrawStyle& oostyle);
@@ -121,16 +121,16 @@ protected:
 	void addStyles( const QDomElement* style );
 	void storeObjectStyles( const QDomElement& object );
 	QString parseColor( const QString &s );
-	void parseTransform(FPointArray *composite, const QString &transform);
-	void parseViewBox( const QDomElement& object, double *x, double *y, double *w, double *h );
-	void appendPoints(FPointArray *composite, const QDomElement& object, bool closePath);
-	const char * getCoord( const char *ptr, double &number );
-	bool parseSVG( const QString &s, FPointArray *ite );
-	void calculateArc(FPointArray *ite, bool relative, double &curx, double &cury, double angle, double x, double y, double r1, double r2, bool largeArcFlag, bool sweepFlag);
-	void svgClosePath(FPointArray *i);
+	void parseTransform(FPointArray *composite, const QString &transform) const;
+	void parseViewBox(const QDomElement& object, double *x, double *y, double *w, double *h) const;
+	void appendPoints(FPointArray *composite, const QDomElement& object, bool closePath) const;
+	const char * getCoord(const char *ptr, double &number) const;
+	bool parseSVG(const QString &s, FPointArray *pts);
+	void calculateArc(FPointArray *pts, bool relative, double &curx, double &cury, double angle, double x, double y, double r1, double r2, bool largeArcFlag, bool sweepFlag);
+	void svgClosePath(FPointArray *pts) const;
 	void svgMoveTo(double x1, double y1);
-	void svgLineTo(FPointArray *i, double x1, double y1);
-	void svgCurveToCubic(FPointArray *i, double x1, double y1, double x2, double y2, double x3, double y3);
+	void svgLineTo(FPointArray *pts, double x1, double y1);
+	void svgCurveToCubic(FPointArray *pts, double x1, double y1, double x2, double y2, double x3, double y3);
 
 	QDomDocument inpContents;
 	QDomDocument inpStyles;
diff -Naupr scribus-1.6.2/scribus/plugins/import/pages/importpages.cpp scribus16x/scribus/plugins/import/pages/importpages.cpp
--- scribus-1.6.2/scribus/plugins/import/pages/importpages.cpp	2024-06-15 16:22:26.000000000 +0200
+++ scribus16x/scribus/plugins/import/pages/importpages.cpp	2025-01-04 10:59:04.557413517 +0100
@@ -11,409 +11,13 @@ for which a new license (GPL+exception)
 	email                : Franz.Schmid@altmuehlnet.de
  ***************************************************************************/
 
-
-#if 0
-#include <QByteArray>
-#include <QCursor>
-#include <QDrag>
-#include <QFile>
-#include <QList>
-#include <QMessageBox>
-#include <QMimeData>
-#include <QRegExp>
-#include <QStack>
-#include <QDebug>
-
+#include <climits>
 #include <cstdlib>
-#include "importpages.h"
-#include "../revenge/rawpainter.h"
-#include <libetonyek/libetonyek.h>
-#include <boost/shared_ptr.hpp>
-
-#include "commonstrings.h"
-#include "ui/customfdialog.h"
-#include "fileloader.h"
-#include "loadsaveplugin.h"
-#include "ui/missing.h"
-#include "ui/multiprogressdialog.h"
-#include "pagesize.h"
-#include "prefscontext.h"
-#include "prefsfile.h"
-#include "prefsmanager.h"
-#include "prefstable.h"
-#include "ui/propertiespalette.h"
-#include "rawimage.h"
-#include "scclocale.h"
-#include "sccolorengine.h"
-#include "scconfig.h"
-#include "scmimedata.h"
-#include "scpaths.h"
-#include "scpattern.h"
-#include "scribus.h"
-#include "scribusXml.h"
-#include "scribuscore.h"
-#include "scribusview.h"
-#include "sctextstream.h"
-#include "selection.h"
-#include "undomanager.h"
-#include "util.h"
-#include "util_formats.h"
-#include "util_math.h"
-
-extern SCRIBUS_API ScribusQApp * ScQApp;
-
-PagesPlug::PagesPlug(ScribusDoc* doc, int flags) :
-	baseX(0.0),
-	baseY(0.0),
-	docWidth(0.0),
-	docHeight(0.0),
-	cancel(false),
-	firstPage(false),
-	pagecount(0),
-	mpagecount(0),
-	topMargin(0.0),
-	leftMargin(0.0),
-	rightMargin(0.0),
-	bottomMargin(0.0),
-	pgCols(0.0),
-	pgGap(0.0)
-{
-	tmpSel = new Selection(this, false);
-	m_Doc = doc;
-	importerFlags = flags;
-	interactive = (flags & LoadSavePlugin::lfInteractive);
-	progressDialog = nullptr;
-}
-
-QImage PagesPlug::readThumbnail(QString fName)
-{
-	QFileInfo fi = QFileInfo(fName);
-	double b, h;
-	b = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
-	h = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
-	docWidth = b;
-	docHeight = h;
-	progressDialog = nullptr;
-	m_Doc = new ScribusDoc();
-	m_Doc->setup(0, 1, 1, 1, 1, "Custom", "Custom");
-	m_Doc->setPage(docWidth, docHeight, 0, 0, 0, 0, 0, 0, false, false);
-	m_Doc->addPage(0);
-	m_Doc->setGUI(false, ScCore->primaryMainWindow(), 0);
-	baseX = m_Doc->currentPage()->xOffset();
-	baseY = m_Doc->currentPage()->yOffset();
-	Elements.clear();
-	m_Doc->setLoading(true);
-	m_Doc->DoDrawing = false;
-	m_Doc->scMW()->setScriptRunning(true);
-	QString CurDirP = QDir::currentPath();
-	QDir::setCurrent(fi.path());
-	if (convert(fName))
-	{
-		tmpSel->clear();
-		QDir::setCurrent(CurDirP);
-		if (Elements.count() > 1)
-			m_Doc->groupObjectsList(Elements);
-		m_Doc->DoDrawing = true;
-		m_Doc->m_Selection->delaySignalsOn();
-		QImage tmpImage;
-		if (Elements.count() > 0)
-		{
-			for (int dre=0; dre<Elements.count(); ++dre)
-			{
-				tmpSel->addItem(Elements.at(dre), true);
-			}
-			tmpSel->setGroupRect();
-			double xs = tmpSel->width();
-			double ys = tmpSel->height();
-			tmpImage = Elements.at(0)->DrawObj_toImage(500);
-			tmpImage.setText("XSize", QString("%1").arg(xs));
-			tmpImage.setText("YSize", QString("%1").arg(ys));
-		}
-		m_Doc->scMW()->setScriptRunning(false);
-		m_Doc->setLoading(false);
-		m_Doc->m_Selection->delaySignalsOff();
-		delete m_Doc;
-		return tmpImage;
-	}
-	else
-	{
-		QDir::setCurrent(CurDirP);
-		m_Doc->DoDrawing = true;
-		m_Doc->scMW()->setScriptRunning(false);
-		delete m_Doc;
-	}
-	return QImage();
-}
-
-bool PagesPlug::import(QString fNameIn, const TransactionSettings& trSettings, int flags, bool showProgress)
-{
-	QString fName = fNameIn;
-	bool success = false;
-	interactive = (flags & LoadSavePlugin::lfInteractive);
-	importerFlags = flags;
-	cancel = false;
-	double b, h;
-	bool ret = false;
-	QFileInfo fi = QFileInfo(fName);
-	if ( !ScCore->usingGUI() )
-	{
-		interactive = false;
-		showProgress = false;
-	}
-	if ( showProgress )
-	{
-		ScribusMainWindow* mw=(m_Doc==0) ? ScCore->primaryMainWindow() : m_Doc->scMW();
-		progressDialog = new MultiProgressDialog( tr("Importing: %1").arg(fi.fileName()), CommonStrings::tr_Cancel, mw );
-		QStringList barNames, barTexts;
-		barNames << "GI";
-		barTexts << tr("Analyzing File:");
-		QList<bool> barsNumeric;
-		barsNumeric << false;
-		progressDialog->addExtraProgressBars(barNames, barTexts, barsNumeric);
-		progressDialog->setOverallTotalSteps(3);
-		progressDialog->setOverallProgress(0);
-		progressDialog->setProgress("GI", 0);
-		progressDialog->show();
-		connect(progressDialog, SIGNAL(canceled()), this, SLOT(cancelRequested()));
-		qApp->processEvents();
-	}
-	else
-		progressDialog = nullptr;
-/* Set default Page to size defined in Preferences */
-	b = 0.0;
-	h = 0.0;
-	if (progressDialog)
-	{
-		progressDialog->setOverallProgress(1);
-		qApp->processEvents();
-	}
-	if (b == 0.0)
-		b = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
-	if (h == 0.0)
-		h = PrefsManager::instance().appPrefs.docSetupPrefs.pageHeight;
-	docWidth = b;
-	docHeight = h;
-	baseX = 0;
-	baseY = 0;
-	if (!interactive || (flags & LoadSavePlugin::lfInsertPage))
-	{
-		m_Doc->setPage(docWidth, docHeight, 0, 0, 0, 0, 0, 0, false, false);
-		m_Doc->addPage(0);
-		m_Doc->view()->addPage(0, true);
-		baseX = 0;
-		baseY = 0;
-	}
-	else
-	{
-		if (!m_Doc || (flags & LoadSavePlugin::lfCreateDoc))
-		{
-			m_Doc = ScCore->primaryMainWindow()->doFileNew(docWidth, docHeight, 0, 0, 0, 0, 0, 0, false, false, 0, false, 0, 1, "Custom", true);
-			ScCore->primaryMainWindow()->HaveNewDoc();
-			ret = true;
-			baseX = 0;
-			baseY = 0;
-			baseX = m_Doc->currentPage()->xOffset();
-			baseY = m_Doc->currentPage()->yOffset();
-		}
-	}
-	if ((!ret) && (interactive))
-	{
-		baseX = m_Doc->currentPage()->xOffset();
-		baseY = m_Doc->currentPage()->yOffset();
-	}
-	if ((ret) || (!interactive))
-	{
-		if (docWidth > docHeight)
-			m_Doc->setPageOrientation(1);
-		else
-			m_Doc->setPageOrientation(0);
-		m_Doc->setPageSize("Custom");
-	}
-	if ((!(flags & LoadSavePlugin::lfLoadAsPattern)) && (m_Doc->view() != nullptr))
-		m_Doc->view()->Deselect();
-	Elements.clear();
-	m_Doc->setLoading(true);
-	m_Doc->DoDrawing = false;
-	if ((!(flags & LoadSavePlugin::lfLoadAsPattern)) && (m_Doc->view() != nullptr))
-		m_Doc->view()->updatesOn(false);
-	m_Doc->scMW()->setScriptRunning(true);
-	qApp->setOverrideCursor(QCursor(Qt::WaitCursor));
-	QString CurDirP = QDir::currentPath();
-	QDir::setCurrent(fi.path());
-	if (convert(fName))
-	{
-		tmpSel->clear();
-		QDir::setCurrent(CurDirP);
-		if ((Elements.count() > 1) && (!(importerFlags & LoadSavePlugin::lfCreateDoc)))
-			m_Doc->groupObjectsList(Elements);
-		m_Doc->DoDrawing = true;
-		m_Doc->scMW()->setScriptRunning(false);
-		m_Doc->setLoading(false);
-		qApp->changeOverrideCursor(QCursor(Qt::ArrowCursor));
-		if ((Elements.count() > 0) && (!ret) && (interactive))
-		{
-			if (flags & LoadSavePlugin::lfScripted)
-			{
-				bool loadF = m_Doc->isLoading();
-				m_Doc->setLoading(false);
-				m_Doc->changed();
-				m_Doc->setLoading(loadF);
-				if (!(flags & LoadSavePlugin::lfLoadAsPattern))
-				{
-					m_Doc->m_Selection->delaySignalsOn();
-					for (int dre=0; dre<Elements.count(); ++dre)
-					{
-						m_Doc->m_Selection->addItem(Elements.at(dre), true);
-					}
-					m_Doc->m_Selection->delaySignalsOff();
-					m_Doc->m_Selection->setGroupRect();
-					if (m_Doc->view() != nullptr)
-						m_Doc->view()->updatesOn(true);
-				}
-			}
-			else
-			{
-				m_Doc->DragP = true;
-				m_Doc->DraggedElem = 0;
-				m_Doc->DragElements.clear();
-				m_Doc->m_Selection->delaySignalsOn();
-				for (int dre=0; dre<Elements.count(); ++dre)
-				{
-					tmpSel->addItem(Elements.at(dre), true);
-				}
-				tmpSel->setGroupRect();
-				ScElemMimeData* md = ScriXmlDoc::writeToMimeData(m_Doc, tmpSel);
-				m_Doc->itemSelection_DeleteItem(tmpSel);
-				m_Doc->view()->updatesOn(true);
-				if (importedPatterns.count() != 0)
-				{
-					for (int cd = 0; cd < importedPatterns.count(); cd++)
-					{
-						m_Doc->docPatterns.remove(importedPatterns[cd]);
-					}
-				}
-				if (importedColors.count() != 0)
-				{
-					for (int cd = 0; cd < importedColors.count(); cd++)
-					{
-						m_Doc->PageColors.remove(importedColors[cd]);
-					}
-				}
-				m_Doc->m_Selection->delaySignalsOff();
-				// We must copy the TransationSettings object as it is owned
-				// by handleObjectImport method afterwards
-				TransactionSettings* transacSettings = new TransactionSettings(trSettings);
-				m_Doc->view()->handleObjectImport(md, transacSettings);
-				m_Doc->DragP = false;
-				m_Doc->DraggedElem = 0;
-				m_Doc->DragElements.clear();
-			}
-		}
-		else
-		{
-			m_Doc->changed();
-			m_Doc->reformPages();
-			if (!(flags & LoadSavePlugin::lfLoadAsPattern))
-				m_Doc->view()->updatesOn(true);
-		}
-		success = true;
-	}
-	else
-	{
-		QDir::setCurrent(CurDirP);
-		m_Doc->DoDrawing = true;
-		m_Doc->scMW()->setScriptRunning(false);
-		m_Doc->view()->updatesOn(true);
-		qApp->changeOverrideCursor(QCursor(Qt::ArrowCursor));
-	}
-	if (interactive)
-		m_Doc->setLoading(false);
-	//CB If we have a gui we must refresh it if we have used the progressbar
-	if (!(flags & LoadSavePlugin::lfLoadAsPattern))
-	{
-		if ((showProgress) && (!interactive))
-			m_Doc->view()->DrawNew();
-	}
-	qApp->restoreOverrideCursor();
-	return success;
-}
-
-PagesPlug::~PagesPlug()
-{
-	if (progressDialog)
-		delete progressDialog;
-	delete tmpSel;
-}
-
-using boost::shared_ptr;
-using libetonyek::EtonyekDocument;
-
-bool PagesPlug::convert(QString fn)
-{
-	importedColors.clear();
-	importedPatterns.clear();
-
-	QFile file(fn);
-	if (!file.exists())
-	{
-		qDebug() << "File " << QFile::encodeName(fn).data() << " does not exist";
-		return false;
-	}
-
-	shared_ptr<librevenge::RVNGInputStream> input;
-	if (librevenge::RVNGDirectoryStream::isDirectory(QFile::encodeName(fn).data()))
-		input.reset(new librevenge::RVNGDirectoryStream(QFile::encodeName(fn).data()));
-	else
-	input.reset(new librevenge::RVNGFileStream(QFile::encodeName(fn).data()));
-	EtonyekDocument::Type type = EtonyekDocument::TYPE_UNKNOWN;
-	const EtonyekDocument::Confidence confidence = EtonyekDocument::isSupported(input.get(), &type);
-	if ((EtonyekDocument::CONFIDENCE_NONE == confidence) || (EtonyekDocument::TYPE_PAGES != type))
-	{
-		qDebug() << "ERROR: Unsupported file format!";
-		return false;
-	}
-	if (EtonyekDocument::CONFIDENCE_SUPPORTED_PART == confidence)
-	  input.reset(librevenge::RVNGDirectoryStream::createForParent(QFile::encodeName(fn).data()));
-	RawPainterPres painter(m_Doc, baseX, baseY, docWidth, docHeight, importerFlags, &Elements, &importedColors, &importedPatterns, tmpSel, "pages");
-	if (!EtonyekDocument::parse(input.get(), &painter))
-	{
-		qDebug() << "ERROR: Import failed!";
-		if (progressDialog)
-			progressDialog->close();
-		if (importerFlags & LoadSavePlugin::lfCreateDoc)
-		{
-			ScribusMainWindow* mw=(m_Doc==0) ? ScCore->primaryMainWindow() : m_Doc->scMW();
-			qApp->changeOverrideCursor(QCursor(Qt::ArrowCursor));
-			QMessageBox::warning(mw, CommonStrings::trWarning, tr("Parsing failed!\n\nPlease submit your file (if possible) to the\nDocument Liberation Project http://www.documentliberation.org"), 1, 0, 0);
-			qApp->changeOverrideCursor(QCursor(Qt::WaitCursor));
-		}
-		return false;
-	}
-	if (Elements.count() == 0)
-	{
-		if (importedColors.count() != 0)
-		{
-			for (int cd = 0; cd < importedColors.count(); cd++)
-			{
-				m_Doc->PageColors.remove(importedColors[cd]);
-			}
-		}
-		if (importedPatterns.count() != 0)
-		{
-			for (int cd = 0; cd < importedPatterns.count(); cd++)
-			{
-				m_Doc->docPatterns.remove(importedPatterns[cd]);
-			}
-		}
-	}
-	if (progressDialog)
-		progressDialog->close();
-	return true;
-}
-#else
+#include <limits>
 
 #include <QByteArray>
 #include <QCursor>
+#include <QDebug>
 #include <QDrag>
 #include <QFile>
 #include <QList>
@@ -421,21 +25,14 @@ bool PagesPlug::convert(QString fn)
 #include <QRegExp>
 #include <QStack>
 #include <QUrl>
-#include <QDebug>
 
 #if defined(_MSC_VER) && !defined(_USE_MATH_DEFINES)
 #define _USE_MATH_DEFINES
 #endif
 
-#include <cstdlib>
-#include <climits>
-#include <limits>
-
-#include "commonstrings.h"
-
 #include "importpages.h"
 
-
+#include "commonstrings.h"
 #include "loadsaveplugin.h"
 #include "pageitem_table.h"
 #include "pagesize.h"
@@ -467,24 +64,8 @@ bool PagesPlug::convert(QString fn)
 #include "util_math.h"
 
 PagesPlug::PagesPlug(ScribusDoc* doc, int flags)
-	: baseX(0.0),
-	  baseY(0.0),
-	  docWidth(0.0),
-	  docHeight(0.0),
-	  m_Doc(doc),
-	  importerFlags(flags),
-	  progressDialog(nullptr),
-	  cancel(false),
-	  firstPage(false),
-	  pagecount(0),
-	  mpagecount(0),
-	  topMargin(0.0),
-	  leftMargin(0.0),
-	  rightMargin(0.0),
-	  bottomMargin(0.0),
-	  pgCols(0.0),
-	  pgGap(0.0),
-	  uz(nullptr)
+	: m_Doc(doc),
+	  importerFlags(flags)
 {
 	tmpSel = new Selection(this, false);
 	interactive = (flags & LoadSavePlugin::lfInteractive);
@@ -613,7 +194,7 @@ bool PagesPlug::import(const QString& fN
 	firstPage = true;
 	pagecount = 1;
 	mpagecount = 0;
-	QFileInfo fi = QFileInfo(fNameIn);
+	QFileInfo fi(fNameIn);
 	if ( !ScCore->usingGUI() )
 	{
 		interactive = false;
@@ -633,14 +214,14 @@ bool PagesPlug::import(const QString& fN
 		progressDialog->setProgress("GI", 0);
 		progressDialog->show();
 		connect(progressDialog, SIGNAL(canceled()), this, SLOT(cancelRequested()));
-		qApp->processEvents();
+		QApplication::processEvents();
 	}
 	else
 		progressDialog = nullptr;
 	if (progressDialog)
 	{
 		progressDialog->setOverallProgress(1);
-		qApp->processEvents();
+		QApplication::processEvents();
 	}
 	/* Set default Page to size defined in Preferences */
 	docWidth = PrefsManager::instance().appPrefs.docSetupPrefs.pageWidth;
@@ -668,12 +249,12 @@ bool PagesPlug::import(const QString& fN
 			baseY = m_Doc->currentPage()->yOffset() + m_Doc->currentPage()->height() / 2.0;
 		}
 	}
-	if ((!ret) && (interactive))
+	if (!ret && interactive)
 	{
 		baseX = m_Doc->currentPage()->xOffset();
 		baseY = m_Doc->currentPage()->yOffset() + m_Doc->currentPage()->height() / 2.0;
 	}
-	if ((ret) || (!interactive))
+	if (ret || !interactive)
 	{
 		if (docWidth > docHeight)
 			m_Doc->setPageOrientation(1);
@@ -689,7 +270,7 @@ bool PagesPlug::import(const QString& fN
 	if ((!(flags & LoadSavePlugin::lfLoadAsPattern)) && (m_Doc->view() != nullptr))
 		m_Doc->view()->updatesOn(false);
 	m_Doc->scMW()->setScriptRunning(true);
-	qApp->setOverrideCursor(QCursor(Qt::WaitCursor));
+	QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
 	QString CurDirP = QDir::currentPath();
 	QDir::setCurrent(fi.path());
 	if (convert(fNameIn))
@@ -701,8 +282,8 @@ bool PagesPlug::import(const QString& fN
 		m_Doc->DoDrawing = true;
 		m_Doc->scMW()->setScriptRunning(false);
 		m_Doc->setLoading(false);
-		qApp->changeOverrideCursor(QCursor(Qt::ArrowCursor));
-		if ((Elements.count() > 0) && (!ret) && (interactive))
+		QApplication::changeOverrideCursor(QCursor(Qt::ArrowCursor));
+		if ((Elements.count() > 0) && !ret && interactive)
 		{
 			if (flags & LoadSavePlugin::lfScripted)
 			{
@@ -777,7 +358,7 @@ bool PagesPlug::import(const QString& fN
 		m_Doc->scMW()->setScriptRunning(false);
 		if (!(flags & LoadSavePlugin::lfLoadAsPattern))
 			m_Doc->view()->updatesOn(true);
-		qApp->changeOverrideCursor(QCursor(Qt::ArrowCursor));
+		QApplication::changeOverrideCursor(QCursor(Qt::ArrowCursor));
 		success = false;
 	}
 	if (interactive)
@@ -785,10 +366,10 @@ bool PagesPlug::import(const QString& fN
 	//CB If we have a gui we must refresh it if we have used the progressbar
 	if (!(flags & LoadSavePlugin::lfLoadAsPattern))
 	{
-		if ((showProgress) && (!interactive))
+		if (showProgress && !interactive)
 			m_Doc->view()->DrawNew();
 	}
-	qApp->restoreOverrideCursor();
+	QApplication::restoreOverrideCursor();
 	return success;
 }
 
@@ -808,7 +389,7 @@ bool PagesPlug::convert(const QString& f
 	{
 		progressDialog->setOverallProgress(2);
 		progressDialog->setLabel("GI", tr("Generating Items"));
-		qApp->processEvents();
+		QApplication::processEvents();
 	}
 
 	uz = new ScZipHandler();
@@ -837,6 +418,7 @@ bool PagesPlug::parseDocReference(const
 	QDomDocument designMapDom;
 	if (!uz->read(designMap, f))
 		return false;
+
 	if (compressed)
 	{
 		QTemporaryFile *tmpFile = new QTemporaryFile(QDir::tempPath() + "/scribus_temp_zip_XXXXXX.dat");
@@ -859,7 +441,7 @@ bool PagesPlug::parseDocReference(const
 		}
 		delete tmpFile;
 	}
-	QString errorMsg = "";
+	QString errorMsg;
 	int errorLine = 0;
 	int errorColumn = 0;
 	if (!designMapDom.setContent(f, &errorMsg, &errorLine, &errorColumn))
@@ -1152,7 +734,6 @@ void PagesPlug::parseStyleSheets(QDomEle
 											QString type = spg.attribute("xsi:type");
 											if (type == "sfa:calibrated-white-color-type")
 											{
-											//	currStyle.fontColor = AttributeValue("White");
 												QColor c;
 												double w = spg.attribute("sfa:w", "1").toDouble();
 												c.setRgbF(w, w, w);
@@ -1160,7 +741,7 @@ void PagesPlug::parseStyleSheets(QDomEle
 												tmp.fromQColor(c);
 												tmp.setSpotColor(false);
 												tmp.setRegistrationColor(false);
-												QString newColorName = "FromPages"+c.name();
+												QString newColorName = "FromPages" + c.name();
 												QString fNam = m_Doc->PageColors.tryAddColor(newColorName, tmp);
 												if (fNam == newColorName)
 													importedColors.append(newColorName);
@@ -1191,7 +772,7 @@ void PagesPlug::parseStyleSheets(QDomEle
 												tmp.setColorF(c, m, y, k);
 												tmp.setSpotColor(false);
 												tmp.setRegistrationColor(false);
-												QString newColorName = "FromPages"+tmp.name();
+												QString newColorName = "FromPages" + tmp.name();
 												QString fNam = m_Doc->PageColors.tryAddColor(newColorName, tmp);
 												if (fNam == newColorName)
 													importedColors.append(newColorName);
@@ -1261,7 +842,6 @@ void PagesPlug::parseStyleSheets(QDomEle
 											QString type = spg.attribute("xsi:type");
 											if (type == "sfa:calibrated-white-color-type")
 											{
-											//	currStyle.fontColor = AttributeValue("White");
 												QColor c;
 												double w = spg.attribute("sfa:w", "1").toDouble();
 												c.setRgbF(w, w, w);
@@ -1269,7 +849,7 @@ void PagesPlug::parseStyleSheets(QDomEle
 												tmp.fromQColor(c);
 												tmp.setSpotColor(false);
 												tmp.setRegistrationColor(false);
-												QString newColorName = "FromPages"+c.name();
+												QString newColorName = "FromPages" + c.name();
 												QString fNam = m_Doc->PageColors.tryAddColor(newColorName, tmp);
 												if (fNam == newColorName)
 													importedColors.append(newColorName);
@@ -1392,7 +972,6 @@ void PagesPlug::parseStyleSheets(QDomEle
 													currStyle.strokeOpacity  = AttributeValue(QString("%1").arg(1.0 - sph.attribute("sfa:a", "1").toDouble()));
 													if (type == "sfa:calibrated-white-color-type")
 													{
-													//	currStyle.CurrColorStroke = AttributeValue("White");
 														QColor c;
 														double w = sph.attribute("sfa:w", "1").toDouble();
 														c.setRgbF(w, w, w);
@@ -1400,7 +979,7 @@ void PagesPlug::parseStyleSheets(QDomEle
 														tmp.fromQColor(c);
 														tmp.setSpotColor(false);
 														tmp.setRegistrationColor(false);
-														QString newColorName = "FromPages"+c.name();
+														QString newColorName = "FromPages" + c.name();
 														QString fNam = m_Doc->PageColors.tryAddColor(newColorName, tmp);
 														if (fNam == newColorName)
 															importedColors.append(newColorName);
@@ -1431,7 +1010,7 @@ void PagesPlug::parseStyleSheets(QDomEle
 														tmp.setColorF(c, m, y, k);
 														tmp.setSpotColor(false);
 														tmp.setRegistrationColor(false);
-														QString newColorName = "FromPages"+tmp.name();
+														QString newColorName = "FromPages" + tmp.name();
 														QString fNam = m_Doc->PageColors.tryAddColor(newColorName, tmp);
 														if (fNam == newColorName)
 															importedColors.append(newColorName);
@@ -1453,7 +1032,6 @@ void PagesPlug::parseStyleSheets(QDomEle
 											currStyle.fillOpacity = AttributeValue(QString("%1").arg(1.0 - spg.attribute("sfa:a", "1").toDouble()));
 											if (type == "sfa:calibrated-white-color-type")
 											{
-											//	currStyle.CurrColorFill = AttributeValue("White");
 												QColor c;
 												double w = spg.attribute("sfa:w", "1").toDouble();
 												c.setRgbF(w, w, w);
@@ -1461,7 +1039,7 @@ void PagesPlug::parseStyleSheets(QDomEle
 												tmp.fromQColor(c);
 												tmp.setSpotColor(false);
 												tmp.setRegistrationColor(false);
-												QString newColorName = "FromPages"+c.name();
+												QString newColorName = "FromPages" + c.name();
 												QString fNam = m_Doc->PageColors.tryAddColor(newColorName, tmp);
 												if (fNam == newColorName)
 													importedColors.append(newColorName);
@@ -1492,7 +1070,7 @@ void PagesPlug::parseStyleSheets(QDomEle
 												tmp.setColorF(c, m, y, k);
 												tmp.setSpotColor(false);
 												tmp.setRegistrationColor(false);
-												QString newColorName = "FromPages"+tmp.name();
+												QString newColorName = "FromPages" + tmp.name();
 												QString fNam = m_Doc->PageColors.tryAddColor(newColorName, tmp);
 												if (fNam == newColorName)
 													importedColors.append(newColorName);
@@ -2242,4 +1820,3 @@ void PagesPlug::finishItem(PageItem* ite
 		item->setDashes(pattern);
 	}*/
 }
-#endif
diff -Naupr scribus-1.6.2/scribus/plugins/import/pages/importpages.h scribus16x/scribus/plugins/import/pages/importpages.h
--- scribus-1.6.2/scribus/plugins/import/pages/importpages.h	2024-06-15 16:22:26.000000000 +0200
+++ scribus16x/scribus/plugins/import/pages/importpages.h	2025-01-04 10:59:04.557413517 +0100
@@ -13,99 +13,26 @@ for which a new license (GPL+exception)
 #ifndef IMPORTPAGES_H
 #define IMPORTPAGES_H
 
-#if 0
-
+#include <QDomDocument>
+#include <QDomElement>
+#include <QList>
+#include <QMultiMap>
 #include <QObject>
 #include <QString>
-
-#include "pluginapi.h"
-#include "pageitem.h"
-#include "sccolor.h"
-#include "fpointarray.h"
-#include "vgradient.h"
-#include <QList>
+#include <QtGlobal>
 #include <QTransform>
-#include <QMultiMap>
-#include <QVector>
-
-class MultiProgressDialog;
-class ScribusDoc;
-class Selection;
-class TransactionSettings;
-
-//! \brief FH importer plugin
-class PagesPlug : public QObject
-{
-	Q_OBJECT
 
-public:
-	/*!
-	\author Franz Schmid
-	\date
-	\brief Create the Fh importer window.
-	\param fName QString
-	\param flags combination of loadFlags
-	\param showProgress if progress must be displayed
-	\retval EPSPlug plugin
-	*/
-	PagesPlug( ScribusDoc* doc, int flags );
-	~PagesPlug();
-
-	/*!
-	\author Franz Schmid
-	\date
-	\brief Perform import.
-	\param fn QString
-	\param trSettings undo transaction settings
-	\param flags combination of loadFlags
-	\param showProgress if progress must be displayed
-	\retval bool true if import was ok
-	 */
-	bool import(QString fn, const TransactionSettings& trSettings, int flags, bool showProgress = true);
-	QImage readThumbnail(QString fn);
-
-private:
-	bool convert(QString fn);
-
-	QList<PageItem*> Elements;
-	double baseX, baseY;
-	double docWidth;
-	double docHeight;
-
-	QStringList importedColors;
-	QStringList importedPatterns;
-
-	bool interactive;
-	MultiProgressDialog * progressDialog;
-	bool cancel;
-	ScribusDoc* m_Doc;
-	Selection* tmpSel;
-	int importerFlags;
-
-public slots:
-	void cancelRequested() { cancel = true; }
-};
-#else
-
-#include "pluginapi.h"
+#include "fpointarray.h"
 #include "pageitem.h"
+#include "pluginapi.h"
 #include "sccolor.h"
-#include "fpointarray.h"
 #include "scribusstructs.h"
-#include <QList>
-#include <QTransform>
-#include <QMultiMap>
-#include <QtGlobal>
-#include <QObject>
-#include <QString>
-#include <QDomDocument>
-#include <QDomElement>
 
 class MultiProgressDialog;
 class ScribusDoc;
+class ScZipHandler;
 class Selection;
 class TransactionSettings;
-class ScZipHandler;
 
 class PagesPlug : public QObject
 {
@@ -239,40 +166,41 @@ private:
 	void applyParagraphAttrs(ParagraphStyle &newStyle, CharStyle &tmpCStyle, const QString& pAttrs);
 	void applyCharAttrs(CharStyle &tmpCStyle, const QString& pAttrs);
 	void finishItem(PageItem* item, ObjState &obState);
+
+	PageItem* addClip(PageItem* retObj, ObjState& obState);
+
 	QList<PageItem*> Elements;
-	double baseX, baseY;
-	double docWidth;
-	double docHeight;
-	bool interactive;
-	ScribusDoc* m_Doc;
-	Selection* tmpSel;
-	int importerFlags;
-	MultiProgressDialog * progressDialog;
-	bool cancel;
+	double baseX { 0.0 };
+	double baseY { 0.0 };
+	double docWidth { 0.0 };
+	double docHeight { 0.0 };
+	bool interactive { false };
+	ScribusDoc* m_Doc { nullptr };
+	Selection* tmpSel { nullptr };
+	int importerFlags { 0 };
+	MultiProgressDialog * progressDialog { nullptr };
+	bool cancel { false };
 	QStringList importedColors;
 	QStringList importedPatterns;
-	bool firstPage;
-	int pagecount;
-	int mpagecount;
-	double topMargin;
-	double leftMargin;
-	double rightMargin;
-	double bottomMargin;
-	double pgCols;
-	double pgGap;
+	bool firstPage { false };
+	int pagecount { 0 };
+	int mpagecount { 0 };
+	double topMargin { 0.0 };
+	double leftMargin { 0.0 };
+	double rightMargin { 0.0 };
+	double bottomMargin { 0.0 };
+	double pgCols { 0.0 };
+	double pgGap { 0.0 };
 	QString papersize;
 	QHash<int, QString> imageResources;
 	QHash<QString, StyleSheet> m_StyleSheets;
 	QString m_currentStyleSheet;
 
-	PageItem* addClip(PageItem* retObj, ObjState &obState);
-
 	FPointArray Coords;
 	QHash<QString, QPainterPath> pathResources;
-	ScZipHandler *uz;
+	ScZipHandler *uz { nullptr };
 
 public slots:
 	void cancelRequested() { cancel = true; }
 };
 #endif
-#endif
diff -Naupr scribus-1.6.2/scribus/plugins/import/pdf/importpdf.cpp scribus16x/scribus/plugins/import/pdf/importpdf.cpp
--- scribus-1.6.2/scribus/plugins/import/pdf/importpdf.cpp	2024-06-15 16:22:26.000000000 +0200
+++ scribus16x/scribus/plugins/import/pdf/importpdf.cpp	2025-01-04 10:59:04.508414539 +0100
@@ -82,7 +82,7 @@ QImage PdfPlug::readThumbnail(const QStr
 	std::unique_ptr<GlobalParams> globalParamsPtr(new GlobalParams());
 	globalParams = globalParamsPtr.get();
 #endif
-	globalParams->setErrQuiet(gTrue);
+	globalParams->setErrQuiet(true);
 
 	QString pdfFile = QDir::toNativeSeparators(fName);
 	QByteArray encodedFileName = os_is_win() ? pdfFile.toUtf8() : QFile::encodeName(pdfFile);
@@ -105,11 +105,11 @@ QImage PdfPlug::readThumbnail(const QStr
 	bgColor[0] = 255;
 	bgColor[1] = 255;
 	bgColor[2] = 255;
-	SplashOutputDev dev(splashModeXBGR8, 4, gFalse, bgColor, gTrue);
-	dev.setVectorAntialias(gTrue);
-	dev.setFreeTypeHinting(gTrue, gFalse);
+	SplashOutputDev dev(splashModeXBGR8, 4, false, bgColor, true);
+	dev.setVectorAntialias(true);
+	dev.setFreeTypeHinting(true, false);
 	dev.startDoc(&pdfDoc);
-	pdfDoc.displayPage(&dev, 1, hDPI, vDPI, 0, gTrue, gFalse, gFalse);
+	pdfDoc.displayPage(&dev, 1, hDPI, vDPI, 0, true, false, false);
 	SplashBitmap *bitmap = dev.getBitmap();
 	int bw = bitmap->getWidth();
 	int bh = bitmap->getHeight();
@@ -337,7 +337,7 @@ bool PdfPlug::convert(const QString& fn)
 	std::unique_ptr<GlobalParams> globalParamsPtr(new GlobalParams());
 	globalParams = globalParamsPtr.get();
 #endif
-	globalParams->setErrQuiet(gTrue);
+	globalParams->setErrQuiet(true);
 
 	QList<OptionalContentGroup*> ocgGroups;
 	QByteArray encodedFileName = os_is_win() ? fn.toUtf8() : QFile::encodeName(fn);
@@ -393,9 +393,9 @@ bool PdfPlug::convert(const QString& fn)
 			double vDPI = 72.0;
 			int firstPage = 1;
 			int lastPage = pdfDoc->getNumPages();
-			GBool useMediaBox = gTrue;
-			GBool crop = gTrue;
-			GBool printing = gFalse;
+			bool useMediaBox = true;
+			bool crop = true;
+			bool printing = false;
 			const PDFRectangle *mediaBox = pdfDoc->getPage(1)->getMediaBox();
 			QRectF mediaRect = QRectF(QPointF(mediaBox->x1, mediaBox->y1), QPointF(mediaBox->x2, mediaBox->y2)).normalized();
 			bool boxesAreDifferent = false;
@@ -434,9 +434,9 @@ bool PdfPlug::convert(const QString& fn)
 				// When displaying	pages slices, we should always set useMediaBox to true
 				// in order to use MediaBox (x, y) as coordinate system
 				if (contentRect != Media_Box)
-					useMediaBox = gFalse;
+					useMediaBox = false;
 				if (cropped)
-					useMediaBox = gTrue;
+					useMediaBox = true;
 				qApp->changeOverrideCursor(QCursor(Qt::WaitCursor));
 				if (m_progressDialog)
 					m_progressDialog->show();
@@ -474,7 +474,7 @@ bool PdfPlug::convert(const QString& fn)
 							Object orderItem = order->get(i);
 							if (orderItem.isDict())
 							{
-								POPPLER_CONST_075 Object POPPLER_REF ref = order->getNF(i);
+								const Object& ref = order->getNF(i);
 								if (ref.isRef())
 								{
 									OptionalContentGroup *oc = ocg->findOcgByRef(ref.getRef());
@@ -488,7 +488,6 @@ bool PdfPlug::convert(const QString& fn)
 							}
 							else
 							{
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 69, 0)
 								const auto& ocgs = ocg->getOCGs ();
 								for (const auto& ocg : ocgs)
 								{
@@ -500,25 +499,11 @@ bool PdfPlug::convert(const QString& fn)
 										ocgNames.append(ocgName);
 									}
 								}
-#else
-								GooList *ocgs = ocg->getOCGs ();
-								for (int i = 0; i < ocgs->getLength (); ++i)
-								{
-									OptionalContentGroup *oc = (OptionalContentGroup *)ocgs->get(i);
-									QString ocgName = UnicodeParsedString(oc->getName());
-									if (!ocgNames.contains(ocgName))
-									{
-										ocgGroups.prepend(oc);
-										ocgNames.append(ocgName);
-									}
-								}
-#endif
 							}
 						}
 					}
 					else
 					{
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 69, 0)
 						const auto& ocgs = ocg->getOCGs ();
 						for (const auto& ocg : ocgs)
 						{
@@ -530,19 +515,6 @@ bool PdfPlug::convert(const QString& fn)
 								ocgNames.append(ocgName);
 							}
 						}
-#else
-						GooList *ocgs = ocg->getOCGs ();
-						for (int i = 0; i < ocgs->getLength (); ++i)
-						{
-							OptionalContentGroup *oc = (OptionalContentGroup *)ocgs->get(i);
-							QString ocgName = UnicodeParsedString(oc->getName());
-							if (!ocgNames.contains(ocgName))
-							{
-								ocgGroups.prepend(oc);
-								ocgNames.append(ocgName);
-							}
-						}
-#endif
 					}
 				}
 
@@ -891,11 +863,11 @@ QImage PdfPlug::readPreview(int pgNum, i
 	bgColor[0] = 255;
 	bgColor[1] = 255;
 	bgColor[2] = 255;
-	SplashOutputDev *dev = new SplashOutputDev(splashModeXBGR8, 4, gFalse, bgColor, gTrue);
-	dev->setVectorAntialias(gTrue);
-	dev->setFreeTypeHinting(gTrue, gFalse);
+	SplashOutputDev *dev = new SplashOutputDev(splashModeXBGR8, 4, false, bgColor, true);
+	dev->setVectorAntialias(true);
+	dev->setFreeTypeHinting(true, false);
 	dev->startDoc(m_pdfDoc);
-	m_pdfDoc->displayPage(dev, pgNum, hDPI, vDPI, 0, gTrue, gFalse, gFalse);
+	m_pdfDoc->displayPage(dev, pgNum, hDPI, vDPI, 0, true, false, false);
 	SplashBitmap *bitmap = dev->getBitmap();
 	int bw = bitmap->getWidth();
 	int bh = bitmap->getHeight();
@@ -954,23 +926,23 @@ QRectF PdfPlug::getCBox(int box, int pgN
 	return cRect;
 }
 
-QString PdfPlug::UnicodeParsedString(POPPLER_CONST GooString *s1)
+QString PdfPlug::UnicodeParsedString(const GooString *s1)
 {
 	if ( !s1 || s1->getLength() == 0 )
 		return QString();
-	GBool isUnicode;
+	bool isUnicode;
 	int i;
 	Unicode u;
 	QString result;
 	if ((s1->getChar(0) & 0xff) == 0xfe && (s1->getLength() > 1 && (s1->getChar(1) & 0xff) == 0xff))
 	{
-		isUnicode = gTrue;
+		isUnicode = true;
 		i = 2;
 		result.reserve((s1->getLength() - 2) / 2);
 	}
 	else
 	{
-		isUnicode = gFalse;
+		isUnicode = false;
 		i = 0;
 		result.reserve(s1->getLength());
 	}
@@ -998,19 +970,19 @@ QString PdfPlug::UnicodeParsedString(con
 {
 	if (s1.length() == 0)
 		return QString();
-	GBool isUnicode;
+	bool isUnicode;
 	size_t i;
 	Unicode u;
 	QString result;
 	if ((s1.at(0) & 0xff) == 0xfe && (s1.length() > 1 && (s1.at(1) & 0xff) == 0xff))
 	{
-		isUnicode = gTrue;
+		isUnicode = true;
 		i = 2;
 		result.reserve((s1.length() - 2) / 2);
 	}
 	else
 	{
-		isUnicode = gFalse;
+		isUnicode = false;
 		i = 0;
 		result.reserve(s1.length());
 	}
diff -Naupr scribus-1.6.2/scribus/plugins/import/pdf/importpdf.h scribus16x/scribus/plugins/import/pdf/importpdf.h
--- scribus-1.6.2/scribus/plugins/import/pdf/importpdf.h	2024-06-15 16:22:26.000000000 +0200
+++ scribus16x/scribus/plugins/import/pdf/importpdf.h	2025-01-04 10:59:04.508414539 +0100
@@ -24,8 +24,8 @@ for which a new license (GPL+exception)
 
 #include "fpointarray.h"
 #include "importpdfconfig.h"
-#include "pluginapi.h"
 #include "pageitem.h"
+#include "pluginapi.h"
 #include "sccolor.h"
 
 class QColor;
@@ -81,7 +81,7 @@ public:
 private:
 	bool convert(const QString& fn);
 	QRectF getCBox(int box, int pgNum);
-	QString UnicodeParsedString(POPPLER_CONST GooString *s1);
+	QString UnicodeParsedString(const GooString *s1);
 	QString UnicodeParsedString(const std::string& s1);
 	
 	QList<PageItem*> m_elements;
diff -Naupr scribus-1.6.2/scribus/plugins/import/pdf/importpdfconfig.h scribus16x/scribus/plugins/import/pdf/importpdfconfig.h
--- scribus-1.6.2/scribus/plugins/import/pdf/importpdfconfig.h	2024-06-15 16:22:26.000000000 +0200
+++ scribus16x/scribus/plugins/import/pdf/importpdfconfig.h	2025-01-04 10:59:04.508414539 +0100
@@ -15,43 +15,6 @@ for which a new license (GPL+exception)
 	+ ((micro) *     1))
 #define POPPLER_ENCODED_VERSION POPPLER_VERSION_ENCODE(POPPLER_VERSION_MAJOR, POPPLER_VERSION_MINOR, POPPLER_VERSION_MICRO)
 
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 64, 0)
-#define POPPLER_CONST const
-#else
-#define POPPLER_CONST
-#endif
-
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 70, 0)
-#define POPPLER_CONST_070 const
-#else
-#define POPPLER_CONST_070
-#endif
-
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 71, 0)
-#define GBool  bool
-#define gTrue  true
-#define gFalse false
-#endif
-
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 72, 0)
-#define getCString  c_str
-#endif
-
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 73, 0)
-#define Guchar  unsigned char
-#define Gushort unsigned short
-#define Guint   unsigned int
-#define Gulong  unsigned long
-#endif
-
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 75, 0)
-#define POPPLER_CONST_075 const
-#define POPPLER_REF &
-#else
-#define POPPLER_CONST_075
-#define POPPLER_REF
-#endif
-
 #if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 82, 0)
 #define POPPLER_CONST_082 const
 #else
diff -Naupr scribus-1.6.2/scribus/plugins/import/pdf/pdftextrecognition.cpp scribus16x/scribus/plugins/import/pdf/pdftextrecognition.cpp
--- scribus-1.6.2/scribus/plugins/import/pdf/pdftextrecognition.cpp	2024-06-15 16:22:26.000000000 +0200
+++ scribus16x/scribus/plugins/import/pdf/pdftextrecognition.cpp	2025-01-04 10:59:04.508414539 +0100
@@ -41,6 +41,8 @@ void PdfTextRecognition::addPdfTextRegio
 */
 void PdfTextRecognition::addChar(GfxState* state, double x, double y, double dx, double dy, double originX, double originY, CharCode code, int nBytes, POPPLER_CONST_082 Unicode* u, int uLen)
 {
+	if (!u || uLen == 0)
+		return;
 
 	switch (this->m_addCharMode)
 	{
@@ -91,11 +93,18 @@ PdfGlyph PdfTextRecognition::AddCharComm
 	newGlyph.dy = charDelta.y();
 
 	// Convert the character to UTF-16 since that's our SVG document's encoding
-
 	if (uLen > 1)
 		qDebug() << "FIXME: AddBasicChar() '" << u << " : " << uLen;
-	newGlyph.code = static_cast<char16_t>(u[uLen - 1]);
-	newGlyph.rise = state->getRise();
+	if (u && uLen > 0)
+	{
+		newGlyph.code = static_cast<char16_t>(u[uLen - 1]);
+		newGlyph.rise = state->getRise();
+	}
+	else
+	{
+		newGlyph.code = static_cast<char16_t>(0);
+		newGlyph.rise = 0.0;
+	}
 	return newGlyph;
 }
 
@@ -672,10 +681,10 @@ void PdfTextOutputDev::updateFont(GfxSta
 * NOTE: Override these for now and do nothing so they don't get picked up and rendered as vectors by the base class,
 	though in the long run we may actually want that unless they can be implemented in a similar way to the text import getChar in which case overloading the makes perfect sense.
 */
-GBool PdfTextOutputDev::beginType3Char(GfxState* state, double x, double y, double dx, double dy, CharCode code, POPPLER_CONST_082 Unicode* u, int uLen)
+bool PdfTextOutputDev::beginType3Char(GfxState* state, double x, double y, double dx, double dy, CharCode code, POPPLER_CONST_082 Unicode* u, int uLen)
 {
 	//stub
-	return gTrue;
+	return true;
 }
 void  PdfTextOutputDev::endType3Char(GfxState* state)
 {
diff -Naupr scribus-1.6.2/scribus/plugins/import/pdf/pdftextrecognition.h scribus16x/scribus/plugins/import/pdf/pdftextrecognition.h
--- scribus-1.6.2/scribus/plugins/import/pdf/pdftextrecognition.h	2024-06-15 16:22:26.000000000 +0200
+++ scribus16x/scribus/plugins/import/pdf/pdftextrecognition.h	2025-01-04 10:59:04.508414539 +0100
@@ -16,7 +16,6 @@ for which a new license (GPL+exception)
 #include "slaoutput.h"
 
 #include <poppler/GfxState.h>
-#include <poppler/CharCodeToUnicode.h>
 
 /* PDF TextBox Framework */
 /*
@@ -143,7 +142,7 @@ class PdfTextOutputDev : public SlaOutpu
 {
 public:
 	PdfTextOutputDev(ScribusDoc* doc, QList<PageItem*>* Elements, QStringList* importedColors, int flags);
-	virtual ~PdfTextOutputDev();
+	~PdfTextOutputDev() override;
 
 	void updateFont(GfxState* state) override;
 
@@ -151,7 +150,7 @@ public:
 	void  beginTextObject(GfxState* state) override;
 	void  endTextObject(GfxState* state) override;
 	void  drawChar(GfxState* state, double /*x*/, double /*y*/, double /*dx*/, double /*dy*/, double /*originX*/, double /*originY*/, CharCode /*code*/, int /*nBytes*/, POPPLER_CONST_082 Unicode* /*u*/, int /*uLen*/) override;
-	GBool beginType3Char(GfxState* /*state*/, double /*x*/, double /*y*/, double /*dx*/, double /*dy*/, CharCode /*code*/, POPPLER_CONST_082 Unicode* /*u*/, int /*uLen*/) override;
+	bool  beginType3Char(GfxState* /*state*/, double /*x*/, double /*y*/, double /*dx*/, double /*dy*/, CharCode /*code*/, POPPLER_CONST_082 Unicode* /*u*/, int /*uLen*/) override;
 	void  endType3Char(GfxState* /*state*/) override;
 	void  type3D0(GfxState* /*state*/, double /*wx*/, double /*wy*/) override;
 	void  type3D1(GfxState* /*state*/, double /*wx*/, double /*wy*/, double /*llx*/, double /*lly*/, double /*urx*/, double /*ury*/) override;
diff -Naupr scribus-1.6.2/scribus/plugins/import/pdf/slaoutput.cpp scribus16x/scribus/plugins/import/pdf/slaoutput.cpp
--- scribus-1.6.2/scribus/plugins/import/pdf/slaoutput.cpp	2024-06-15 16:22:26.000000000 +0200
+++ scribus16x/scribus/plugins/import/pdf/slaoutput.cpp	2025-01-04 10:59:04.507414560 +0100
@@ -81,6 +81,8 @@ namespace
 	}
 }
 
+#if POPPLER_ENCODED_VERSION < POPPLER_VERSION_ENCODE(24, 10, 0)
+
 LinkSubmitForm::LinkSubmitForm(Object *actionObj)
 {
 	if (!actionObj->isDict())
@@ -92,12 +94,12 @@ LinkSubmitForm::LinkSubmitForm(Object *a
 		Object obj3 = obj1.dictLookup("FS");
 		if (!obj3.isNull() && obj3.isName())
 		{
-			POPPLER_CONST char *name = obj3.getName();
+			const char *name = obj3.getName();
 			if (!strcmp(name, "URL"))
 			{
 				Object obj2 = obj1.dictLookup("F");
 				if (!obj2.isNull())
-					fileName = obj2.getString()->copy();
+					m_url = obj2.getString()->copy();
 			}
 		}
 	}
@@ -108,9 +110,11 @@ LinkSubmitForm::LinkSubmitForm(Object *a
 
 LinkSubmitForm::~LinkSubmitForm()
 {
-	delete fileName;
+	delete m_url;
 }
 
+#endif
+
 LinkImportData::LinkImportData(Object *actionObj)
 {
 	if (!actionObj->isDict())
@@ -120,19 +124,13 @@ LinkImportData::LinkImportData(Object *a
 		return;
 
 	Object obj3 = getFileSpecNameForPlatform(&obj1);
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 01, 0)
 	if (!obj3.isNull())
 		fileName = obj3.getString()->copy();
-}
-
-LinkImportData::~LinkImportData()
-{
-	delete fileName;
-}
-
-AnoOutputDev::~AnoOutputDev()
-{
-	delete fontName;
-	delete itemText;
+#else
+	if (!obj3.isNull())
+		fileName.reset(obj3.getString()->copy());
+#endif
 }
 
 AnoOutputDev::AnoOutputDev(ScribusDoc* doc, QStringList *importedColors)
@@ -162,22 +160,26 @@ void AnoOutputDev::stroke(GfxState *stat
 	currColorStroke = getColor(state->getStrokeColorSpace(), state->getStrokeColor(), &shade);
 }
 
-void AnoOutputDev::drawString(GfxState *state, POPPLER_CONST GooString *s)
+void AnoOutputDev::drawString(GfxState *state, const GooString *s)
 {
 	int shade = 100;
 	currColorText = getColor(state->getFillColorSpace(), state->getFillColor(), &shade);
 	fontSize = state->getFontSize();
 #if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 4, 0)
 	if (state->getFont() && state->getFont()->getName())
-		fontName = new GooString(state->getFont()->getName().value());
+		fontName.reset(new GooString(state->getFont()->getName().value()));
 #else
 	if (state->getFont())
-		fontName = state->getFont()->getName()->copy();
+		fontName.reset(state->getFont()->getName()->copy());
 #endif
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 01, 0)
 	itemText = s->copy();
+#else
+	itemText.reset(s->copy());
+#endif
 }
 
-QString AnoOutputDev::getColor(GfxColorSpace *color_space, POPPLER_CONST_070 GfxColor *color, int *shade)
+QString AnoOutputDev::getColor(GfxColorSpace *color_space, const GfxColor *color, int *shade)
 {
 	QString fNam;
 	QString namPrefix = "FromPDF";
@@ -218,7 +220,7 @@ QString AnoOutputDev::getColor(GfxColorS
 	{
 		auto* sepColorSpace = (GfxSeparationColorSpace*) color_space;
 		GfxColorSpace* altColorSpace = sepColorSpace->getAlt();
-		QString name(sepColorSpace->getName()->getCString());
+		QString name(sepColorSpace->getName()->c_str());
 		bool isRegistrationColor = (name == "All");
 		if (isRegistrationColor)
 		{
@@ -309,7 +311,7 @@ LinkAction* SlaOutputDev::SC_getAction(A
 	if (obj.isDict())
 	{
 		Dict* adic = obj.getDict();
-		POPPLER_CONST_075 Object POPPLER_REF additionalActions = adic->lookupNF("A");
+		const Object& additionalActions = adic->lookupNF("A");
 		Object additionalActionsObject = additionalActions.fetch(m_pdfDoc->getXRef());
 		if (additionalActionsObject.isDict())
 		{
@@ -344,7 +346,7 @@ LinkAction* SlaOutputDev::SC_getAddition
 	if (obj.isDict())
 	{
 		Dict* adic = obj.getDict();
-		POPPLER_CONST_075 Object POPPLER_REF additionalActions = adic->lookupNF("AA");
+		const Object& additionalActions = adic->lookupNF("AA");
 		Object additionalActionsObject = additionalActions.fetch(m_pdfDoc->getXRef());
 		if (additionalActionsObject.isDict())
 		{
@@ -356,7 +358,7 @@ LinkAction* SlaOutputDev::SC_getAddition
 	return linkAction;
 }
 
-GBool SlaOutputDev::annotations_callback(Annot *annota, void *user_data)
+bool SlaOutputDev::annotations_callback(Annot *annota, void *user_data)
 {
 	auto *dev = (SlaOutputDev*) user_data;
 #if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 4, 0)
@@ -460,7 +462,7 @@ bool SlaOutputDev::handleLinkAnnot(Annot
 	if (act->getKind() == actionGoTo)
 	{
 		auto *gto = (LinkGoTo*) act;
-		POPPLER_CONST LinkDest *dst = gto->getDest();
+		const LinkDest *dst = gto->getDest();
 		if (dst)
 		{
 			if (dst->getKind() == destXYZ)
@@ -483,7 +485,7 @@ bool SlaOutputDev::handleLinkAnnot(Annot
 		}
 		else
 		{
-			POPPLER_CONST GooString *ndst = gto->getNamedDest();
+			const GooString *ndst = gto->getNamedDest();
 			if (ndst)
 			{
 #if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
@@ -515,7 +517,7 @@ bool SlaOutputDev::handleLinkAnnot(Annot
 	{
 		auto *gto = (LinkGoToR*) act;
 		fileName = UnicodeParsedString(gto->getFileName());
-		POPPLER_CONST LinkDest *dst = gto->getDest();
+		const LinkDest *dst = gto->getDest();
 		if (dst)
 		{
 			if (dst->getKind() == destXYZ)
@@ -528,7 +530,7 @@ bool SlaOutputDev::handleLinkAnnot(Annot
 		}
 		else
 		{
-			POPPLER_CONST GooString *ndst = gto->getNamedDest();
+			const GooString *ndst = gto->getNamedDest();
 			if (ndst)
 			{
 #if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
@@ -670,7 +672,7 @@ bool SlaOutputDev::handleWidgetAnnot(Ann
 			bool bgFound = false;
 			if (achar)
 			{
-				POPPLER_CONST AnnotColor *bgCol = achar->getBackColor();
+				const AnnotColor *bgCol = achar->getBackColor();
 				if (bgCol)
 				{
 					bgFound = true;
@@ -678,7 +680,7 @@ bool SlaOutputDev::handleWidgetAnnot(Ann
 				}
 				else
 					m_graphicStack.top().fillColor = CommonStrings::None;
-				POPPLER_CONST AnnotColor *fgCol = achar->getBorderColor();
+				const AnnotColor *fgCol = achar->getBorderColor();
 				if (fgCol)
 				{
 					fgFound = true;
@@ -714,8 +716,8 @@ bool SlaOutputDev::handleWidgetAnnot(Ann
 					m_graphicStack.top().strokeColor = annotOutDev->currColorStroke;
 				currTextColor = annotOutDev->currColorText;
 				fontSize = annotOutDev->fontSize;
-				fontName = UnicodeParsedString(annotOutDev->fontName);
-				itemText = UnicodeParsedString(annotOutDev->itemText);
+				fontName = UnicodeParsedString(annotOutDev->fontName.get());
+				itemText = UnicodeParsedString(annotOutDev->itemText.get());
 				delete gfx;
 				delete annotOutDev;
 			}
@@ -907,7 +909,7 @@ bool SlaOutputDev::handleWidgetAnnot(Ann
 				QList<int> radList;
 				for (int i = 0; i < obj2.arrayGetLength(); i++)
 				{
-					POPPLER_CONST_075 Object POPPLER_REF childRef = obj2.arrayGetNF(i);
+					const Object& childRef = obj2.arrayGetNF(i);
 					if (!childRef.isRef())
 						continue;
 					Object childObj = obj2.arrayGet(i);
@@ -979,7 +981,7 @@ void SlaOutputDev::handleActions(PageIte
 			int xco = 0;
 			int yco = 0;
 			auto *gto = (LinkGoTo*) Lact;
-			POPPLER_CONST LinkDest *dst = gto->getDest();
+			const LinkDest *dst = gto->getDest();
 			if (dst)
 			{
 				if (dst->getKind() == destXYZ)
@@ -1004,7 +1006,7 @@ void SlaOutputDev::handleActions(PageIte
 			}
 			else
 			{
-				POPPLER_CONST GooString *ndst = gto->getNamedDest();
+				const GooString *ndst = gto->getNamedDest();
 				if (ndst)
 				{
 #if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
@@ -1041,7 +1043,7 @@ void SlaOutputDev::handleActions(PageIte
 			int yco = 0;
 			auto *gto = (LinkGoToR*) Lact;
 			QString fileName = UnicodeParsedString(gto->getFileName());
-			POPPLER_CONST LinkDest *dst = gto->getDest();
+			const LinkDest *dst = gto->getDest();
 			if (dst)
 			{
 				if (dst->getKind() == destXYZ)
@@ -1057,7 +1059,7 @@ void SlaOutputDev::handleActions(PageIte
 			}
 			else
 			{
-				POPPLER_CONST GooString *ndst = gto->getNamedDest();
+				const GooString *ndst = gto->getNamedDest();
 				if (ndst)
 				{
 #if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
@@ -1078,6 +1080,32 @@ void SlaOutputDev::handleActions(PageIte
 				}
 			}
 		}
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 89, 0)
+		else if (Lact->getKind() == actionResetForm)
+		{
+			ite->annotation().setActionType(4);
+		}
+#endif
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 10, 0)
+		else if (Lact->getKind() == actionSubmitForm)
+		{
+			const auto* impo = (LinkSubmitForm*) Lact;
+			if (impo->isOk())
+			{
+				ite->annotation().setActionType(3);
+				ite->annotation().setAction(UnicodeParsedString(impo->getUrl()));
+				int fl = impo->getFlags();
+				if (fl == 0)
+					ite->annotation().setHTML(0);
+				else if (fl == 4)
+					ite->annotation().setHTML(1);
+				else if (fl == 64)
+					ite->annotation().setHTML(2);
+				else if (fl == 512)
+					ite->annotation().setHTML(3);
+			}
+		}
+#endif
 		else if (Lact->getKind() == actionUnknown)
 		{
 			auto *uno = (LinkUnknown*) Lact;
@@ -1106,7 +1134,7 @@ void SlaOutputDev::handleActions(PageIte
 						if (impo->isOk())
 						{
 							ite->annotation().setActionType(3);
-							ite->annotation().setAction(UnicodeParsedString(impo->getFileName()));
+							ite->annotation().setAction(UnicodeParsedString(impo->getUrl()));
 							int fl = impo->getFlags();
 							if (fl == 0)
 								ite->annotation().setHTML(0);
@@ -1463,14 +1491,14 @@ void SlaOutputDev::restoreState(GfxState
 	m_graphicStack.restore();
 }
 
-void SlaOutputDev::beginTransparencyGroup(GfxState *state, POPPLER_CONST_070 double *bbox, GfxColorSpace * /*blendingColorSpace*/, GBool isolated, GBool knockout, GBool forSoftMask)
+void SlaOutputDev::beginTransparencyGroup(GfxState *state, const double *bbox, GfxColorSpace * /*blendingColorSpace*/, bool isolated, bool knockout, bool forSoftMask)
 {
 // 	qDebug() << "SlaOutputDev::beginTransparencyGroup isolated:" << isolated << "knockout:" << knockout << "forSoftMask:" << forSoftMask;
 	pushGroup("", forSoftMask);
 	m_groupStack.top().isolated = isolated;
 }
 
-void SlaOutputDev::paintTransparencyGroup(GfxState *state, POPPLER_CONST_070 double *bbox)
+void SlaOutputDev::paintTransparencyGroup(GfxState *state, const double *bbox)
 {
 // 	qDebug() << "SlaOutputDev::paintTransparencyGroup";
 	if (m_groupStack.count() != 0)
@@ -1569,7 +1597,7 @@ void SlaOutputDev::endTransparencyGroup(
 	m_tmpSel->clear();
 }
 
-void SlaOutputDev::setSoftMask(GfxState * /*state*/, POPPLER_CONST_070 double * bbox, GBool alpha, Function *transferFunc, GfxColor * /*backdropColor*/)
+void SlaOutputDev::setSoftMask(GfxState * /*state*/, const double * bbox, bool alpha, Function *transferFunc, GfxColor * /*backdropColor*/)
 {
 	if (m_groupStack.count() <= 0)
 		return;
@@ -1814,7 +1842,7 @@ void SlaOutputDev::createFillItem(GfxSta
 	}
 }
 
-GBool SlaOutputDev::axialShadedFill(GfxState *state, GfxAxialShading *shading, double tMin, double tMax)
+bool SlaOutputDev::axialShadedFill(GfxState *state, GfxAxialShading *shading, double tMin, double tMax)
 {
 //	qDebug() << "SlaOutputDev::axialShadedFill";
 	double GrStartX;
@@ -1822,7 +1850,7 @@ GBool SlaOutputDev::axialShadedFill(GfxS
 	double GrEndX;
 	double GrEndY;
 	int shade = 100;
-	POPPLER_CONST_070 Function *func = shading->getFunc(0);
+	const Function *func = shading->getFunc(0);
 	VGradient fillGradient(VGradient::linear);
 	fillGradient.clearStops();
 	GfxColorSpace *color_space = shading->getColorSpace();
@@ -1953,10 +1981,10 @@ GBool SlaOutputDev::axialShadedFill(GfxS
 		m_groupStack.top().Items.append(ite);
 		applyMask(ite);
 	}
-	return gTrue;
+	return true;
 }
 
-GBool SlaOutputDev::radialShadedFill(GfxState *state, GfxRadialShading *shading, double sMin, double sMax)
+bool SlaOutputDev::radialShadedFill(GfxState *state, GfxRadialShading *shading, double sMin, double sMax)
 {
 //	qDebug() << "SlaOutputDev::radialShadedFill";
 	double GrStartX;
@@ -1964,7 +1992,7 @@ GBool SlaOutputDev::radialShadedFill(Gfx
 	double GrEndX;
 	double GrEndY;
 	int shade = 100;
-	POPPLER_CONST_070 Function *func = shading->getFunc(0);
+	const Function *func = shading->getFunc(0);
 	VGradient fillGradient(VGradient::linear);
 	fillGradient.clearStops();
 	GfxColorSpace *color_space = shading->getColorSpace();
@@ -2085,10 +2113,10 @@ GBool SlaOutputDev::radialShadedFill(Gfx
 		m_groupStack.top().Items.append(ite);
 		applyMask(ite);
 	}
-	return gTrue;
+	return true;
 }
 
-GBool SlaOutputDev::gouraudTriangleShadedFill(GfxState *state, GfxGouraudTriangleShading *shading)
+bool SlaOutputDev::gouraudTriangleShadedFill(GfxState *state, GfxGouraudTriangleShading *shading)
 {
 //	qDebug() << "SlaOutputDev::gouraudTriangleShadedFill";
 	double xCoor = m_doc->currentPage()->xOffset();
@@ -2166,10 +2194,10 @@ GBool SlaOutputDev::gouraudTriangleShade
 		ite->meshGradientPatches.append(patchM);
 	}
 	ite->GrType = 12;
-	return gTrue;
+	return true;
 }
 
-GBool SlaOutputDev::patchMeshShadedFill(GfxState *state, GfxPatchMeshShading *shading)
+bool SlaOutputDev::patchMeshShadedFill(GfxState *state, GfxPatchMeshShading *shading)
 {
 //	qDebug() << "SlaOutputDev::patchMeshShadedFill";
 	double xCoor = m_doc->currentPage()->xOffset();
@@ -2316,13 +2344,13 @@ GBool SlaOutputDev::patchMeshShadedFill(
 		ite->meshGradientPatches.append(patchM);
 	}
 	ite->GrType = 12;
-	return gTrue;
+	return true;
 }
 
 #if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(21, 3, 0)
 bool SlaOutputDev::tilingPatternFill(GfxState *state, Gfx * /*gfx*/, Catalog *cat, GfxTilingPattern *tPat, const double *mat, int x0, int y0, int x1, int y1, double xStep, double yStep)
 #else
-GBool SlaOutputDev::tilingPatternFill(GfxState *state, Gfx * /*gfx*/, Catalog *cat, Object *str, POPPLER_CONST_070 double *pmat, int /*paintType*/, int /*tilingType*/, Dict *resDict, POPPLER_CONST_070 double *mat, POPPLER_CONST_070 double *bbox, int x0, int y0, int x1, int y1, double xStep, double yStep)
+bool SlaOutputDev::tilingPatternFill(GfxState *state, Gfx * /*gfx*/, Catalog *cat, Object *str, const double *pmat, int /*paintType*/, int /*tilingType*/, Dict *resDict, const double *mat, const double *bbox, int x0, int y0, int x1, int y1, double xStep, double yStep)
 #endif
 {
 //	qDebug() << "SlaOutputDev::tilingPatternFill";
@@ -2342,7 +2370,7 @@ GBool SlaOutputDev::tilingPatternFill(Gf
 	width = bbox[2] - bbox[0];
 	height = bbox[3] - bbox[1];
 	if (xStep != width || yStep != height)
-		return gFalse;
+		return false;
 	box.x1 = bbox[0];
 	box.y1 = bbox[1];
 	box.x2 = bbox[2];
@@ -2367,8 +2395,6 @@ GBool SlaOutputDev::tilingPatternFill(Gf
 	m_inPattern--;
 	gElements = m_groupStack.pop();
 	m_doc->m_Selection->clear();
-//	double pwidth = 0;
-//	double pheight = 0;
 	if (gElements.Items.count() > 0)
 	{
 		for (int dre = 0; dre < gElements.Items.count(); ++dre)
@@ -2393,8 +2419,6 @@ GBool SlaOutputDev::tilingPatternFill(Gf
 		m_doc->DoDrawing = false;
 		pat.width = ite->width();
 		pat.height = ite->height();
-	//	pwidth = ite->width();
-	//	pheight = ite->height();
 		ite->gXpos = 0;
 		ite->gYpos = 0;
 		ite->setXYPos(ite->gXpos, ite->gYpos, true);
@@ -2457,10 +2481,10 @@ GBool SlaOutputDev::tilingPatternFill(Gf
 		applyMask(ite);
 	}
 	delete gfx;
-	return gTrue;
+	return true;
 }
 
-void SlaOutputDev::drawImageMask(GfxState *state, Object *ref, Stream *str, int width, int height, GBool invert, GBool interpolate, GBool inlineImg)
+void SlaOutputDev::drawImageMask(GfxState *state, Object *ref, Stream *str, int width, int height, bool invert, bool interpolate, bool inlineImg)
 {
 //	qDebug() << "Draw Image Mask";
 	auto imgStr = std::make_shared<ImageStream>(str, width, 1, 1);
@@ -2478,7 +2502,7 @@ void SlaOutputDev::drawImageMask(GfxStat
 	unsigned char* dest = nullptr;
 	int rowStride = image.bytesPerLine();
 	int i, bit;
-	Guchar* pix;
+	unsigned char* pix;
 
 	for (int y = 0; y < height; y++)
 	{
@@ -2533,8 +2557,8 @@ void SlaOutputDev::drawImageMask(GfxStat
 	imgStr->close();
 }
 
-void SlaOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref, Stream *str, int width, int height, GfxImageColorMap *colorMap, GBool interpolate, Stream *maskStr, int maskWidth, int maskHeight,
-				   GfxImageColorMap *maskColorMap, GBool maskInterpolate)
+void SlaOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref, Stream *str, int width, int height, GfxImageColorMap *colorMap, bool interpolate, Stream *maskStr, int maskWidth, int maskHeight,
+				   GfxImageColorMap *maskColorMap, bool maskInterpolate)
 {
 //	qDebug() << "SlaOutputDev::drawSoftMaskedImage Masked Image Components" << colorMap->getNumPixelComps();
 	auto imgStr = std::make_shared<ImageStream>(str, width, colorMap->getNumPixelComps(), colorMap->getBits());
@@ -2544,7 +2568,7 @@ void SlaOutputDev::drawSoftMaskedImage(G
 	for (int y = 0; y < height; y++)
 	{
 		dest = (unsigned int *)(buffer + y * 4 * width);
-		Guchar * pix = imgStr->getLine();
+		unsigned char * pix = imgStr->getLine();
 		colorMap->getRGBLine(pix, dest, width);
 	}
 
@@ -2557,13 +2581,13 @@ void SlaOutputDev::drawSoftMaskedImage(G
 
 	auto mskStr = std::make_shared<ImageStream>(maskStr, maskWidth, maskColorMap->getNumPixelComps(), maskColorMap->getBits());
 	mskStr->reset();
-	Guchar *mdest = nullptr;
+	unsigned char *mdest = nullptr;
 	unsigned char * mbuffer = new unsigned char[maskWidth * maskHeight];
 	memset(mbuffer, 0, maskWidth * maskHeight);
 	for (int y = 0; y < maskHeight; y++)
 	{
-		mdest = (Guchar *)(mbuffer + y * maskWidth);
-		Guchar * pix = mskStr->getLine();
+		mdest = mbuffer + y * maskWidth;
+		unsigned char * pix = mskStr->getLine();
 		maskColorMap->getGrayLine(pix, mdest, maskWidth);
 	}
 	if ((maskWidth != width) || (maskHeight != height))
@@ -2571,7 +2595,7 @@ void SlaOutputDev::drawSoftMaskedImage(G
 	QImage res = image.convertToFormat(QImage::Format_ARGB32);
 
 	int matteRc, matteGc, matteBc;
-	POPPLER_CONST_070 GfxColor *matteColor = maskColorMap->getMatteColor();
+	const GfxColor *matteColor = maskColorMap->getMatteColor();
 	if (matteColor != nullptr)
 	{
 		GfxRGB matteRgb;
@@ -2610,7 +2634,7 @@ void SlaOutputDev::drawSoftMaskedImage(G
 	delete[] mbuffer;
 }
 
-void SlaOutputDev::drawMaskedImage(GfxState *state, Object *ref, Stream *str,  int width, int height, GfxImageColorMap *colorMap, GBool interpolate, Stream *maskStr, int maskWidth, int maskHeight, GBool maskInvert, GBool maskInterpolate)
+void SlaOutputDev::drawMaskedImage(GfxState *state, Object *ref, Stream *str,  int width, int height, GfxImageColorMap *colorMap, bool interpolate, Stream *maskStr, int maskWidth, int maskHeight, bool maskInvert, bool maskInterpolate)
 {
 //	qDebug() << "SlaOutputDev::drawMaskedImage";
 	auto imgStr = std::make_shared<ImageStream>(str, width, colorMap->getNumPixelComps(), colorMap->getBits());
@@ -2620,7 +2644,7 @@ void SlaOutputDev::drawMaskedImage(GfxSt
 	for (int y = 0; y < height; y++)
 	{
 		dest = (unsigned int *)(buffer + y * 4 * width);
-		Guchar * pix = imgStr->getLine();
+		unsigned char * pix = imgStr->getLine();
 		colorMap->getRGBLine(pix, dest, width);
 	}
 
@@ -2633,14 +2657,14 @@ void SlaOutputDev::drawMaskedImage(GfxSt
 
 	auto mskStr = std::make_shared<ImageStream>(maskStr, maskWidth, 1, 1);
 	mskStr->reset();
-	Guchar *mdest = nullptr;
+	unsigned char *mdest = nullptr;
 	int invert_bit = maskInvert ? 1 : 0;
 	unsigned char * mbuffer = new unsigned char[maskWidth * maskHeight];
 	memset(mbuffer, 0, maskWidth * maskHeight);
 	for (int y = 0; y < maskHeight; y++)
 	{
-		mdest = (Guchar *)(mbuffer + y * maskWidth);
-		Guchar * pix = mskStr->getLine();
+		mdest = mbuffer + y * maskWidth;
+		unsigned char * pix = mskStr->getLine();
 		for (int x = 0; x < maskWidth; x++)
 		{
 			if (pix[x] ^ invert_bit)
@@ -2675,7 +2699,7 @@ void SlaOutputDev::drawMaskedImage(GfxSt
 	delete[] mbuffer;
 }
 
-void SlaOutputDev::drawImage(GfxState *state, Object *ref, Stream *str, int width, int height, GfxImageColorMap *colorMap, GBool interpolate, POPPLER_CONST_082 int* maskColors, GBool inlineImg)
+void SlaOutputDev::drawImage(GfxState *state, Object *ref, Stream *str, int width, int height, GfxImageColorMap *colorMap, bool interpolate, POPPLER_CONST_082 int* maskColors, bool inlineImg)
 {
 	auto imgStr = std::make_shared<ImageStream>(str, width, colorMap->getNumPixelComps(), colorMap->getBits());
 	imgStr->reset();
@@ -2689,7 +2713,7 @@ void SlaOutputDev::drawImage(GfxState *s
 		for (int y = 0; y < height; y++)
 		{
 			QRgb *s = (QRgb*)(image.scanLine(y));
-			Guchar *pix = imgStr->getLine();
+			unsigned char *pix = imgStr->getLine();
 			for (int x = 0; x < width; x++)
 			{
 				GfxRGB rgb;
@@ -2716,7 +2740,7 @@ void SlaOutputDev::drawImage(GfxState *s
 		for (int y = 0; y < height; y++)
 		{
 			QRgb *s = (QRgb*)(image.scanLine(y));
-			Guchar *pix = imgStr->getLine();
+			unsigned char *pix = imgStr->getLine();
 			for (int x = 0; x < width; x++)
 			{
 				if (colorMap->getNumPixelComps() == 4)
@@ -2899,7 +2923,7 @@ void SlaOutputDev::createImageFrame(QIma
 	}
 }
 
-void SlaOutputDev::beginMarkedContent(POPPLER_CONST char *name, Object *dictRef)
+void SlaOutputDev::beginMarkedContent(const char *name, Object *dictRef)
 {
 	mContent mSte;
 	mSte.name = QString(name);
@@ -2942,7 +2966,7 @@ void SlaOutputDev::beginMarkedContent(PO
 	m_mcStack.push(mSte);
 }
 
-void SlaOutputDev::beginMarkedContent(POPPLER_CONST char *name, Dict *properties)
+void SlaOutputDev::beginMarkedContent(const char *name, Dict *properties)
 {
 //	qDebug() << "Begin Marked Content with Name " << QString(name);
 	QString nam(name);
@@ -2959,7 +2983,7 @@ void SlaOutputDev::beginMarkedContent(PO
 			QString lName = QString("Layer_%1").arg(m_layerNum + 1);
 			Object obj = properties->lookup("Title");
 			if (obj.isString())
-				lName = QString(obj.getString()->getCString());
+				lName = QString(obj.getString()->c_str());
 			for (const auto& layer : m_doc->Layers)
 			{
 				if (layer.Name == lName)
@@ -3019,12 +3043,12 @@ void SlaOutputDev::endMarkedContent(GfxS
 	}
 }
 
-void SlaOutputDev::markPoint(POPPLER_CONST char *name)
+void SlaOutputDev::markPoint(const char *name)
 {
 //	qDebug() << "Begin Marked Point with Name " << QString(name);
 }
 
-void SlaOutputDev::markPoint(POPPLER_CONST char *name, Dict *properties)
+void SlaOutputDev::markPoint(const char *name, Dict *properties)
 {
 //	qDebug() << "Begin Marked Point with Name " << QString(name) << "and Properties";
 	beginMarkedContent(name, properties);
@@ -3049,7 +3073,11 @@ void SlaOutputDev::updateFont(GfxState *
 	char* tmpBuf = nullptr;
 #endif
 	GfxFontType fontType;
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)
+	std::unique_ptr<SlaOutFontFileID> id;
+#else
 	SlaOutFontFileID *id;
+#endif
 	SplashFontFile *fontFile;
 	SplashFontSrc *fontsrc = nullptr;
 	Object refObj, strObj;
@@ -3079,15 +3107,21 @@ void SlaOutputDev::updateFont(GfxState *
 		goto err1;
 
 	// check the font file cache
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)
+	id.reset(new SlaOutFontFileID(gfxFont->getID()));
+	if ((fontFile = m_fontEngine->getFontFile(*id)))
+		id.reset();
+#else
 	id = new SlaOutFontFileID(gfxFont->getID());
 	if ((fontFile = m_fontEngine->getFontFile(id)))
 		delete id;
+#endif
 	else
 	{
 		fontLoc = gfxFont->locateFont(m_xref ? m_xref : m_pdfDoc->getXRef(), nullptr);
 		if (!fontLoc)
 		{
-			error(errSyntaxError, -1, "Couldn't find a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->getCString() : "(unnamed)");
+			error(errSyntaxError, -1, "Couldn't find a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
 			goto err2;
 		}
 
@@ -3127,44 +3161,73 @@ void SlaOutputDev::updateFont(GfxState *
 			fontsrc->setBuf(std::move(tmpBuf.value()));
 #else
 		if (fileName)
-			fontsrc->setFile(fileName, gFalse);
+			fontsrc->setFile(fileName, false);
 		else
-			fontsrc->setBuf(tmpBuf, tmpBufLen, gTrue);
+			fontsrc->setBuf(tmpBuf, tmpBufLen, true);
 #endif
 
 		// load the font file
 		switch (fontType) {
 		case fontType1:
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)
+			if (!(fontFile = m_fontEngine->loadType1Font(std::move(id), fontsrc, (const char**) ((Gfx8BitFont*) gfxFont)->getEncoding(), fontLoc->fontNum)))
+			{
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
+				goto err2;
+			}
+#else
 			if (!(fontFile = m_fontEngine->loadType1Font(id, fontsrc, (const char **)((Gfx8BitFont *) gfxFont)->getEncoding())))
 			{
-				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->getCString() : "(unnamed)");
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
 				goto err2;
 			}
+#endif
 			break;
 		case fontType1C:
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)
+			if (!(fontFile = m_fontEngine->loadType1CFont(std::move(id), fontsrc, (const char**) ((Gfx8BitFont*) gfxFont)->getEncoding(), fontLoc->fontNum)))
+			{
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
+				goto err2;
+			}
+#else
 			if (!(fontFile = m_fontEngine->loadType1CFont(id, fontsrc, (const char **)((Gfx8BitFont *) gfxFont)->getEncoding())))
 			{
-				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->getCString() : "(unnamed)");
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
 				goto err2;
 			}
+#endif
 			break;
 		case fontType1COT:
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)
+			if (!(fontFile = m_fontEngine->loadOpenTypeT1CFont(std::move(id), fontsrc, (const char **)((Gfx8BitFont *) gfxFont)->getEncoding(), fontLoc->fontNum)))
+			{
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
+				goto err2;
+			}
+#else
 			if (!(fontFile = m_fontEngine->loadOpenTypeT1CFont(id, fontsrc, (const char **)((Gfx8BitFont *) gfxFont)->getEncoding())))
 			{
-				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->getCString() : "(unnamed)");
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
 				goto err2;
 			}
+#endif
 			break;
 		case fontTrueType:
 		case fontTrueTypeOT:
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 4, 0)
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)
+			if (!fileName.empty())
+				ff = FoFiTrueType::load(fileName.c_str(), fontLoc->fontNum);
+			else
+				ff = FoFiTrueType::make(fontsrc->buf.data(), fontsrc->buf.size(), fontLoc->fontNum);
+#elif POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 4, 0)
 			if (!fileName.empty())
 				ff = FoFiTrueType::load(fileName.c_str());
 			else
 				ff = FoFiTrueType::make(fontsrc->buf.data(), fontsrc->buf.size());
 #else
 			if (fileName)
-				ff = FoFiTrueType::load(fileName->getCString());
+				ff = FoFiTrueType::load(fileName->c_str());
 			else
 				ff = FoFiTrueType::make(tmpBuf, tmpBufLen);
 #endif
@@ -3184,19 +3247,35 @@ void SlaOutputDev::updateFont(GfxState *
 				codeToGID = nullptr;
 				n = 0;
 			}
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)
+			if (!(fontFile = m_fontEngine->loadTrueTypeFont(std::move(id), fontsrc, codeToGID, n, fontLoc->fontNum)))
+			{
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
+				goto err2;
+			}
+#else
 			if (!(fontFile = m_fontEngine->loadTrueTypeFont(id, fontsrc, codeToGID, n)))
 			{
-				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->getCString() : "(unnamed)");
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
 				goto err2;
 			}
+#endif
 			break;
 		case fontCIDType0:
 		case fontCIDType0C:
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)
+			if (!(fontFile = m_fontEngine->loadCIDFont(std::move(id), fontsrc, fontLoc->fontNum)))
+			{
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
+				goto err2;
+			}
+#else
 			if (!(fontFile = m_fontEngine->loadCIDFont(id, fontsrc)))
 			{
-				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->getCString() : "(unnamed)");
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
 				goto err2;
 			}
+#endif
 			break;
 		case fontCIDType0COT:
 			if (((GfxCIDFont *) gfxFont)->getCIDToGID())
@@ -3210,12 +3289,21 @@ void SlaOutputDev::updateFont(GfxState *
 				codeToGID = nullptr;
 				n = 0;
 			}
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)
+			if (!(fontFile = m_fontEngine->loadOpenTypeCFFFont(std::move(id), fontsrc, codeToGID, n, fontLoc->fontNum)))
+			{
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'",
+					gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
+				goto err2;
+			}
+#else
 			if (!(fontFile = m_fontEngine->loadOpenTypeCFFFont(id, fontsrc, codeToGID, n)))
 			{
 				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'",
-				gfxFont->getName() ? gfxFont->getName()->getCString() : "(unnamed)");
+				gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
 				goto err2;
 			}
+#endif
 			break;
 		case fontCIDType2:
 		case fontCIDType2OT:
@@ -3232,14 +3320,19 @@ void SlaOutputDev::updateFont(GfxState *
 			}
 			else
 			{
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 4, 0)
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)
+				if (!fileName.empty())
+					ff = FoFiTrueType::load(fileName.c_str(), fontLoc->fontNum);
+				else
+					ff = FoFiTrueType::make(fontsrc->buf.data(), fontsrc->buf.size(), fontLoc->fontNum);
+#elif POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 4, 0)
 				if (!fileName.empty())
 					ff = FoFiTrueType::load(fileName.c_str());
 				else
 					ff = FoFiTrueType::make(fontsrc->buf.data(), fontsrc->buf.size());
 #else
 				if (fileName)
-					ff = FoFiTrueType::load(fileName->getCString());
+					ff = FoFiTrueType::load(fileName->c_str());
 				else
 					ff = FoFiTrueType::make(tmpBuf, tmpBufLen);
 #endif
@@ -3253,11 +3346,19 @@ void SlaOutputDev::updateFont(GfxState *
 				delete ff;
 #endif
 			}
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)
+			if (!(fontFile = m_fontEngine->loadTrueTypeFont(std::move(id), fontsrc, codeToGID, n, fontLoc->fontNum)))
+			{
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
+				goto err2;
+			}
+#else
 			if (!(fontFile = m_fontEngine->loadTrueTypeFont(id, fontsrc, codeToGID, n, faceIndex)))
 			{
-				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->getCString() : "(unnamed)");
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
 				goto err2;
 			}
+#endif
 			break;
 		default:
 			// this shouldn't happen
@@ -3292,7 +3393,11 @@ void SlaOutputDev::updateFont(GfxState *
 	return;
 
 err2:
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)
+	id.reset();
+#else
 	delete id;
+#endif
 #if POPPLER_ENCODED_VERSION < POPPLER_VERSION_ENCODE(22, 2, 0)
 	delete fontLoc;
 #endif
@@ -3334,7 +3439,7 @@ void SlaOutputDev::drawChar(GfxState* st
 			qPath.setFillRule(Qt::WindingFill);
 			for (int i = 0; i < fontPath->getLength(); ++i)
 			{
-				Guchar f;
+				unsigned char f;
 				fontPath->getPoint(i, &x1, &y1, &f);
 				if (f & splashPathFirst)
 					qPath.moveTo(x1,y1);
@@ -3396,25 +3501,25 @@ void SlaOutputDev::drawChar(GfxState* st
 }
 
 
-GBool SlaOutputDev::beginType3Char(GfxState *state, double x, double y, double dx, double dy, CharCode code, POPPLER_CONST_082 Unicode *u, int uLen)
+bool SlaOutputDev::beginType3Char(GfxState *state, double x, double y, double dx, double dy, CharCode code, POPPLER_CONST_082 Unicode *u, int uLen)
 {
 //	qDebug() << "beginType3Char";
 #if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 4, 0)
 	GfxFont *gfxFont;
 	if (!(gfxFont = state->getFont().get()))
-		return gTrue;
+		return true;
 #else
 	GfxFont* gfxFont;
 	if (!(gfxFont = state->getFont()))
-		return gTrue;
+		return true;
 #endif
 	if (gfxFont->getType() != fontType3)
-		return gTrue;
+		return true;
 	F3Entry f3e;
 	f3e.colored = false;
 	m_F3Stack.push(f3e);
 	pushGroup();
-	return gFalse;
+	return false;
 }
 
 void SlaOutputDev::endType3Char(GfxState *state)
@@ -3514,7 +3619,7 @@ void SlaOutputDev::endTextObject(GfxStat
 	}
 }
 
-QString SlaOutputDev::getColor(GfxColorSpace *color_space, POPPLER_CONST_070 GfxColor *color, int *shade)
+QString SlaOutputDev::getColor(GfxColorSpace *color_space, const GfxColor *color, int *shade)
 {
 	QString fNam;
 	QString namPrefix = "FromPDF";
@@ -3561,7 +3666,7 @@ QString SlaOutputDev::getColor(GfxColorS
 	{
 		auto* sepColorSpace = (GfxSeparationColorSpace*) color_space;
 		GfxColorSpace* altColorSpace = sepColorSpace->getAlt();
-		QString name(sepColorSpace->getName()->getCString());
+		QString name(sepColorSpace->getName()->c_str());
 		bool isRegistrationColor = (name == "All");
 		if (isRegistrationColor)
 		{
@@ -3842,7 +3947,7 @@ void SlaOutputDev::applyMask(PageItem *i
 	}
 }
 
-void SlaOutputDev::pushGroup(const QString& maskName, GBool forSoftMask, GBool alpha, bool inverted)
+void SlaOutputDev::pushGroup(const QString& maskName, bool forSoftMask, bool alpha, bool inverted)
 {
 	groupEntry gElements;
 	gElements.forSoftMask = forSoftMask;
@@ -3852,23 +3957,23 @@ void SlaOutputDev::pushGroup(const QStri
 	m_groupStack.push(gElements);
 }
 
-QString SlaOutputDev::UnicodeParsedString(POPPLER_CONST GooString *s1) const
+QString SlaOutputDev::UnicodeParsedString(const GooString *s1) const
 {
 	if ( !s1 || s1->getLength() == 0 )
 		return QString();
-	GBool isUnicode;
+	bool isUnicode;
 	int i;
 	Unicode u;
 	QString result;
 	if ((s1->getChar(0) & 0xff) == 0xfe && (s1->getLength() > 1 && (s1->getChar(1) & 0xff) == 0xff))
 	{
-		isUnicode = gTrue;
+		isUnicode = true;
 		i = 2;
 		result.reserve((s1->getLength() - 2) / 2);
 	}
 	else
 	{
-		isUnicode = gFalse;
+		isUnicode = false;
 		i = 0;
 		result.reserve(s1->getLength());
 	}
@@ -3893,19 +3998,19 @@ QString SlaOutputDev::UnicodeParsedStrin
 {
 	if (s1.length() == 0)
 		return QString();
-	GBool isUnicode;
+	bool isUnicode;
 	size_t i;
 	Unicode u;
 	QString result;
 	if ((s1.at(0) & 0xff) == 0xfe && (s1.length() > 1 && (s1.at(1) & 0xff) == 0xff))
 	{
-		isUnicode = gTrue;
+		isUnicode = true;
 		i = 2;
 		result.reserve((s1.length() - 2) / 2);
 	}
 	else
 	{
-		isUnicode = gFalse;
+		isUnicode = false;
 		i = 0;
 		result.reserve(s1.length());
 	}
diff -Naupr scribus-1.6.2/scribus/plugins/import/pdf/slaoutput.h scribus16x/scribus/plugins/import/pdf/slaoutput.h
--- scribus-1.6.2/scribus/plugins/import/pdf/slaoutput.h	2024-06-15 16:22:26.000000000 +0200
+++ scribus16x/scribus/plugins/import/pdf/slaoutput.h	2025-01-04 10:59:04.508414539 +0100
@@ -30,55 +30,54 @@ for which a new license (GPL+exception)
 #include "selection.h"
 #include "vgradient.h"
 
-#if POPPLER_ENCODED_VERSION < POPPLER_VERSION_ENCODE(0, 73, 0)
-#include <poppler/goo/gtypes.h>
-#endif
-#include <poppler/Object.h>
-#include <poppler/OutputDev.h>
+#include <poppler/Catalog.h>
+#include <poppler/Error.h>
+#include <poppler/Form.h>
 #include <poppler/Gfx.h>
-#include <poppler/GfxState.h>
-#include <poppler/Stream.h>
 #include <poppler/GfxFont.h>
+#include <poppler/GfxState.h>
 #include <poppler/Link.h>
-#include <poppler/PDFDoc.h>
-#include <poppler/Error.h>
-#include <poppler/Form.h>
+#include <poppler/Object.h>
+#include <poppler/OutputDev.h>
 #include <poppler/Page.h>
-#include <poppler/Catalog.h>
-#include <poppler/CharCodeToUnicode.h>
-#include <poppler/FontEncodingTables.h>
-#include <poppler/splash/SplashFontFileID.h>
-#include <poppler/splash/SplashFontFile.h>
-#include <poppler/splash/SplashFontEngine.h>
+#include <poppler/PDFDoc.h>
+#include <poppler/Stream.h>
 #include <poppler/splash/SplashFont.h>
+#include <poppler/splash/SplashFontEngine.h>
+#include <poppler/splash/SplashFontFile.h>
+#include <poppler/splash/SplashFontFileID.h>
+#include <poppler/splash/SplashGlyphBitmap.h>
 #include <poppler/splash/SplashMath.h>
 #include <poppler/splash/SplashPath.h>
-#include <poppler/splash/SplashGlyphBitmap.h>
 
 //------------------------------------------------------------------------
-// LinkSubmitData
+// LinkSubmitForm
 //------------------------------------------------------------------------
 
+#if POPPLER_ENCODED_VERSION < POPPLER_VERSION_ENCODE(24, 10, 0)
+
 class LinkSubmitForm: public LinkAction
 {
 public:
 	// Build a LinkImportData from an action dictionary.
-	LinkSubmitForm(Object *actionObj);
+	explicit LinkSubmitForm(Object *actionObj);
 	// Destructor.
-	virtual ~LinkSubmitForm();
+	~LinkSubmitForm() override;
 
 	// Was the LinkImportData created successfully?
-	GBool isOk() POPPLER_CONST override { return fileName != nullptr; }
+	bool isOk() const override { return m_url != nullptr; }
 	// Accessors.
-	LinkActionKind getKind() POPPLER_CONST override { return actionUnknown; }
-	GooString *getFileName() { return fileName; }
-	int getFlags() { return m_flags; }
+	LinkActionKind getKind() const override { return actionUnknown; }
+	GooString *getUrl() { return m_url; }
+	int getFlags() const { return m_flags; }
 
 private:
-	GooString *fileName {nullptr};		// file name
+	GooString *m_url {nullptr};		// URL
 	int m_flags {0};
 };
 
+#endif
+
 //------------------------------------------------------------------------
 // LinkImportData
 //------------------------------------------------------------------------
@@ -87,18 +86,16 @@ class LinkImportData: public LinkAction
 {
 public:
 	// Build a LinkImportData from an action dictionary.
-	LinkImportData(Object *actionObj);
-	// Destructor.
-	virtual ~LinkImportData();
+	explicit LinkImportData(Object *actionObj);
 
 	// Was the LinkImportData created successfully?
-	GBool isOk() POPPLER_CONST override { return fileName != nullptr; }
+	bool isOk() const override { return fileName != nullptr; }
 	// Accessors.
-	LinkActionKind getKind() POPPLER_CONST override { return actionUnknown; }
-	GooString *getFileName() { return fileName; }
+	LinkActionKind getKind() const override { return actionUnknown; }
+	GooString* getFileName() { return fileName.get(); }
 
 private:
-	GooString *fileName {nullptr};		// file name
+	std::unique_ptr<GooString> fileName;		// file name
 };
 
 //------------------------------------------------------------------------
@@ -108,13 +105,19 @@ private:
 class SlaOutFontFileID: public SplashFontFileID
 {
 public:
-	SlaOutFontFileID(const Ref *rA) { r = *rA; }
-	~SlaOutFontFileID() {}
+	explicit SlaOutFontFileID(const Ref *rA) { r = *rA; }
 
-	GBool matches(SplashFontFileID *id) override
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)
+	bool matches(const SplashFontFileID& id) const override
+	{
+		return ((const SlaOutFontFileID&) id).r.num == r.num && ((const SlaOutFontFileID&) id).r.gen == r.gen;
+	}
+#else
+	bool matches(SplashFontFileID *id) override
 	{
 		return ((SlaOutFontFileID*) id)->r.num == r.num && ((SlaOutFontFileID *) id)->r.gen == r.gen;
 	}
+#endif
 
 private:
 	Ref r;
@@ -125,33 +128,32 @@ class AnoOutputDev : public OutputDev
 {
 public:
 	AnoOutputDev(ScribusDoc* doc, QStringList *importedColors);
-	virtual ~AnoOutputDev();
 
-	GBool isOk() { return gTrue; }
-	GBool upsideDown() override { return gTrue; }
-	GBool useDrawChar() override { return gFalse; }
-	GBool interpretType3Chars() override { return gFalse; }
-	GBool useTilingPatternFill() override  { return gFalse; }
-	GBool useShadedFills(int type) override { return gFalse; }
-	GBool useFillColorStop() override { return gFalse; }
-	GBool useDrawForm() override { return gFalse; }
+	bool isOk() const { return true; }
+	bool upsideDown() override { return true; }
+	bool useDrawChar() override { return false; }
+	bool interpretType3Chars() override { return false; }
+	bool useTilingPatternFill() override  { return false; }
+	bool useShadedFills(int type) override { return false; }
+	bool useFillColorStop() override { return false; }
+	bool useDrawForm() override { return false; }
 
 	void stroke(GfxState *state) override;
 	void eoFill(GfxState *state) override;
 	void fill(GfxState *state) override;
-	void drawString(GfxState *state, POPPLER_CONST GooString *s) override;
+	void drawString(GfxState *state, const GooString *s) override;
 
 	QString currColorText;
 	QString currColorFill;
 	QString currColorStroke;
 	double  fontSize {12};
-	GooString *fontName {nullptr};
-	GooString *itemText {nullptr};
+	std::unique_ptr<GooString> fontName;
+	std::unique_ptr<GooString> itemText;
 
 private:
-	QString getColor(GfxColorSpace *color_space, POPPLER_CONST_070 GfxColor *color, int *shade);
-	ScribusDoc* m_doc;
-	QStringList *m_importedColors;
+	QString getColor(GfxColorSpace *color_space, const GfxColor *color, int *shade);
+	ScribusDoc* m_doc { nullptr };
+	QStringList *m_importedColors { nullptr };
 };
 
 
@@ -160,7 +162,7 @@ class SlaOutputDev : public OutputDev
 {
 public:
 	SlaOutputDev(ScribusDoc* doc, QList<PageItem*> *Elements, QStringList *importedColors, int flags);
-	virtual ~SlaOutputDev();
+	~SlaOutputDev() override;
 
 	LinkAction* SC_getAction(AnnotWidget *ano);
 #if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
@@ -168,7 +170,7 @@ public:
 #else
 	LinkAction* SC_getAdditionalAction(const char *key, AnnotWidget *ano);
 #endif
-	static GBool annotations_callback(Annot *annota, void *user_data);
+	static bool annotations_callback(Annot *annota, void *user_data);
 	bool handleTextAnnot(Annot* annota, double xCoor, double yCoor, double width, double height);
 	bool handleLinkAnnot(Annot* annota, double xCoor, double yCoor, double width, double height);
 	bool handleWidgetAnnot(Annot* annota, double xCoor, double yCoor, double width, double height);
@@ -176,16 +178,16 @@ public:
 	void handleActions(PageItem* ite, AnnotWidget *ano);
 	void startDoc(PDFDoc *doc, XRef *xrefA, Catalog *catA);
 
-	GBool isOk() { return gTrue; }
-	GBool upsideDown() override { return gTrue; }
-	GBool useDrawChar() override { return gTrue; }
-	GBool interpretType3Chars() override { return gTrue; }
-	GBool useTilingPatternFill() override { return gTrue; }
-	GBool useShadedFills(int type) override { return type <= 7; }
-	GBool useFillColorStop() override { return gTrue; }
-	GBool useDrawForm() override { return gFalse; }
+	bool isOk() const { return true; }
+	bool upsideDown() override { return true; }
+	bool useDrawChar() override { return true; }
+	bool interpretType3Chars() override { return true; }
+	bool useTilingPatternFill() override { return true; }
+	bool useShadedFills(int type) override { return type <= 7; }
+	bool useFillColorStop() override { return true; }
+	bool useDrawForm() override { return false; }
 
-//	virtual GBool needClipToCropBox() { return gTrue; }
+//	virtual bool needClipToCropBox() { return true; }
 	void startPage(int pageNum, GfxState *, XRef *) override;
 	void endPage() override;
 
@@ -200,32 +202,32 @@ public:
 #if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(21, 3, 0)
 	bool tilingPatternFill(GfxState *state, Gfx *gfx, Catalog *cat, GfxTilingPattern *tPat, const double *mat, int x0, int y0, int x1, int y1, double xStep, double yStep) override;
 #else
-	GBool tilingPatternFill(GfxState *state, Gfx *gfx, Catalog *cat, Object *str, POPPLER_CONST_070 double *pmat, int paintType, int tilingType, Dict *resDict, POPPLER_CONST_070 double *mat, POPPLER_CONST_070 double *bbox, int x0, int y0, int x1, int y1, double xStep, double yStep) override;
+	bool tilingPatternFill(GfxState *state, Gfx *gfx, Catalog *cat, Object *str, const double *pmat, int paintType, int tilingType, Dict *resDict, const double *mat, const double *bbox, int x0, int y0, int x1, int y1, double xStep, double yStep) override;
 #endif
-	GBool functionShadedFill(GfxState * /*state*/, GfxFunctionShading * /*shading*/) override { qDebug() << "Function Shaded Fill";  return gFalse; }
-	GBool axialShadedFill(GfxState *state, GfxAxialShading *shading, double tMin, double tMax) override;
-	GBool axialShadedSupportExtend(GfxState *state, GfxAxialShading *shading)  override { return (shading->getExtend0() == shading->getExtend1()); }
-	GBool radialShadedFill(GfxState *state, GfxRadialShading *shading, double sMin, double sMax) override;
-	GBool radialShadedSupportExtend(GfxState *state, GfxRadialShading *shading) override { return (shading->getExtend0() == shading->getExtend1()); }
-	GBool gouraudTriangleShadedFill(GfxState *state, GfxGouraudTriangleShading *shading) override;
-	GBool patchMeshShadedFill(GfxState *state, GfxPatchMeshShading *shading) override;
+	bool functionShadedFill(GfxState * /*state*/, GfxFunctionShading * /*shading*/) override { qDebug() << "Function Shaded Fill";  return false; }
+	bool axialShadedFill(GfxState *state, GfxAxialShading *shading, double tMin, double tMax) override;
+	bool axialShadedSupportExtend(GfxState *state, GfxAxialShading *shading)  override { return (shading->getExtend0() == shading->getExtend1()); }
+	bool radialShadedFill(GfxState *state, GfxRadialShading *shading, double sMin, double sMax) override;
+	bool radialShadedSupportExtend(GfxState *state, GfxRadialShading *shading) override { return (shading->getExtend0() == shading->getExtend1()); }
+	bool gouraudTriangleShadedFill(GfxState *state, GfxGouraudTriangleShading *shading) override;
+	bool patchMeshShadedFill(GfxState *state, GfxPatchMeshShading *shading) override;
 
 	//----- path clipping
 	void clip(GfxState *state) override;
 	void eoClip(GfxState *state) override;
 	void clipToStrokePath(GfxState * /*state*/) override { qDebug() << "Clip to StrokePath"; }
-	virtual GBool deviceHasTextClip(GfxState *state) { return gFalse; }
+	virtual bool deviceHasTextClip(GfxState *state) { return false; }
 
   // If current colorspace is pattern,
   // does this device support text in pattern colorspace?
-	virtual GBool supportTextCSPattern(GfxState *state)
+	virtual bool supportTextCSPattern(GfxState *state)
 	{
 		return state->getFillColorSpace()->getMode() == csPattern;
 	}
 
   // If current colorspace is pattern,
   // need this device special handling for masks in pattern colorspace?
-	virtual GBool fillMaskCSPattern(GfxState * state)
+	virtual bool fillMaskCSPattern(GfxState * state)
 	{
 		return state->getFillColorSpace()->getMode() == csPattern;
 	}
@@ -233,37 +235,37 @@ public:
 	virtual void endMaskClip(GfxState *state) { qDebug() << "End Mask Clip"; }
 
   //----- grouping operators
-	void beginMarkedContent(POPPLER_CONST char *name, Dict *properties) override;
-	virtual void beginMarkedContent(POPPLER_CONST char *name, Object *dictRef);
+	void beginMarkedContent(const char *name, Dict *properties) override;
+	virtual void beginMarkedContent(const char *name, Object *dictRef);
 	void endMarkedContent(GfxState *state) override;
-	void markPoint(POPPLER_CONST char *name) override;
-	void markPoint(POPPLER_CONST char *name, Dict *properties) override;
+	void markPoint(const char *name) override;
+	void markPoint(const char *name, Dict *properties) override;
 
 	//----- image drawing
-	void drawImageMask(GfxState *state, Object *ref, Stream *str, int width, int height, GBool invert, GBool interpolate, GBool inlineImg) override;
-	void drawImage(GfxState *state, Object *ref, Stream *str, int width, int height, GfxImageColorMap *colorMap, GBool interpolate, POPPLER_CONST_082 int *maskColors, GBool inlineImg) override;
+	void drawImageMask(GfxState *state, Object *ref, Stream *str, int width, int height, bool invert, bool interpolate, bool inlineImg) override;
+	void drawImage(GfxState *state, Object *ref, Stream *str, int width, int height, GfxImageColorMap *colorMap, bool interpolate, POPPLER_CONST_082 int *maskColors, bool inlineImg) override;
 	void drawSoftMaskedImage(GfxState *state, Object *ref, Stream *str,
 				   int width, int height,
 				   GfxImageColorMap *colorMap,
-				   GBool interpolate,
+				   bool interpolate,
 				   Stream *maskStr,
 				   int maskWidth, int maskHeight,
 				   GfxImageColorMap *maskColorMap,
-				   GBool maskInterpolate) override;
+				   bool maskInterpolate) override;
 
 	void drawMaskedImage(GfxState *state, Object *ref, Stream *str,
 				   int width, int height,
 				   GfxImageColorMap *colorMap,
-				   GBool interpolate,
+				   bool interpolate,
 				   Stream *maskStr,
 				   int maskWidth, int maskHeight,
-				   GBool maskInvert, GBool maskInterpolate) override; // { qDebug() << "Draw Masked Image"; }
+				   bool maskInvert, bool maskInterpolate) override;
 
 	//----- transparency groups and soft masks
-	void beginTransparencyGroup(GfxState *state, POPPLER_CONST_070 double *bbox, GfxColorSpace * /*blendingColorSpace*/, GBool /*isolated*/, GBool /*knockout*/, GBool /*forSoftMask*/) override;
-	void paintTransparencyGroup(GfxState *state, POPPLER_CONST_070 double *bbox) override;
+	void beginTransparencyGroup(GfxState *state, const double *bbox, GfxColorSpace * /*blendingColorSpace*/, bool /*isolated*/, bool /*knockout*/, bool /*forSoftMask*/) override;
+	void paintTransparencyGroup(GfxState *state, const double *bbox) override;
 	void endTransparencyGroup(GfxState *state) override;
-	void setSoftMask(GfxState * /*state*/, POPPLER_CONST_070 double * /*bbox*/, GBool /*alpha*/, Function * /*transferFunc*/, GfxColor * /*backdropColor*/) override;
+	void setSoftMask(GfxState * /*state*/, const double * /*bbox*/, bool /*alpha*/, Function * /*transferFunc*/, GfxColor * /*backdropColor*/) override;
 	void clearSoftMask(GfxState * /*state*/) override;
 
 	void updateFillColor(GfxState *state) override;
@@ -274,7 +276,7 @@ public:
 	void  beginTextObject(GfxState *state) override;
 	void  endTextObject(GfxState *state) override;
 	void  drawChar(GfxState *state, double /*x*/, double /*y*/, double /*dx*/, double /*dy*/, double /*originX*/, double /*originY*/, CharCode /*code*/, int /*nBytes*/, POPPLER_CONST_082 Unicode * /*u*/, int /*uLen*/) override;
-	GBool beginType3Char(GfxState * /*state*/, double /*x*/, double /*y*/, double /*dx*/, double /*dy*/, CharCode /*code*/, POPPLER_CONST_082 Unicode * /*u*/, int /*uLen*/) override;
+	bool  beginType3Char(GfxState * /*state*/, double /*x*/, double /*y*/, double /*dx*/, double /*dy*/, CharCode /*code*/, POPPLER_CONST_082 Unicode * /*u*/, int /*uLen*/) override;
 	void  endType3Char(GfxState * /*state*/) override;
 	void  type3D0(GfxState * /*state*/, double /*wx*/, double /*wy*/) override;
 	void  type3D1(GfxState * /*state*/, double /*wx*/, double /*wy*/, double /*llx*/, double /*lly*/, double /*urx*/, double /*ury*/) override;
@@ -293,7 +295,7 @@ public:
 protected:
 	void setItemFillAndStroke(GfxState* state, PageItem* textNode);
 	void applyMask(PageItem* ite);
-	void pushGroup(const QString& maskName = "", GBool forSoftMask = gFalse, GBool alpha = gFalse, bool inverted = false);
+	void pushGroup(const QString& maskName = "", bool forSoftMask = false, bool alpha = false, bool inverted = false);
 
 	ScribusDoc* m_doc;
 	Qt::PenCapStyle m_lineEnd { Qt::FlatCap };
@@ -354,9 +356,9 @@ protected:
 	struct groupEntry
 	{
 		QList<PageItem*> Items;
-		GBool forSoftMask { gFalse };
-		GBool isolated { gFalse };
-		GBool alpha { gFalse };
+		bool forSoftMask { false };
+		bool isolated { false };
+		bool alpha { false };
 		QString maskName;
 		QPointF maskPos;
 		bool inverted { false };
@@ -367,11 +369,11 @@ protected:
 
 private:
 	void getPenState(GfxState *state);
-	QString getColor(GfxColorSpace *color_space, POPPLER_CONST_070 GfxColor *color, int *shade);
+	QString getColor(GfxColorSpace *color_space, const GfxColor *color, int *shade);
 	QString getAnnotationColor(const AnnotColor *color);
 	QString convertPath(POPPLER_CONST_083 GfxPath *path);
 	int getBlendMode(GfxState *state) const;
-	QString UnicodeParsedString(POPPLER_CONST GooString *s1) const;
+	QString UnicodeParsedString(const GooString *s1) const;
 	QString UnicodeParsedString(const std::string& s1) const;
 	bool checkClip();
 
diff -Naupr scribus-1.6.2/scribus/plugins/import/pm/importpm.cpp scribus16x/scribus/plugins/import/pm/importpm.cpp
--- scribus-1.6.2/scribus/plugins/import/pm/importpm.cpp	2024-06-15 16:22:26.000000000 +0200
+++ scribus16x/scribus/plugins/import/pm/importpm.cpp	2025-01-04 10:59:04.868407025 +0100
@@ -343,7 +343,7 @@ bool PmPlug::convert(const QString& fn)
 		{
 			ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 			qApp->changeOverrideCursor(QCursor(Qt::ArrowCursor));
-			ScMessageBox::warning(mw, CommonStrings::trWarning, tr("Parsing failed!\n\nPlease submit your file (if possible) to the\nDocument Liberation Project http://www.documentliberation.org"));
+			ScMessageBox::warning(mw, CommonStrings::trWarning, tr("Parsing failed!\n\nPlease submit your file (if possible) to the\nDocument Liberation Project https://www.documentliberation.org"));
 			qApp->changeOverrideCursor(QCursor(Qt::WaitCursor));
 		}
 		return false;
diff -Naupr scribus-1.6.2/scribus/plugins/import/pub/importpub.cpp scribus16x/scribus/plugins/import/pub/importpub.cpp
--- scribus-1.6.2/scribus/plugins/import/pub/importpub.cpp	2024-06-15 16:22:26.000000000 +0200
+++ scribus16x/scribus/plugins/import/pub/importpub.cpp	2025-01-04 10:59:04.871406963 +0100
@@ -350,7 +350,7 @@ bool PubPlug::convert(const QString& fn)
 		{
 			ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 			qApp->changeOverrideCursor(QCursor(Qt::ArrowCursor));
-			ScMessageBox::warning(mw, CommonStrings::trWarning, tr("Parsing failed!\n\nPlease submit your file (if possible) to the\nDocument Liberation Project http://www.documentliberation.org"));
+			ScMessageBox::warning(mw, CommonStrings::trWarning, tr("Parsing failed!\n\nPlease submit your file (if possible) to the\nDocument Liberation Project https://www.documentliberation.org"));
 			qApp->changeOverrideCursor(QCursor(Qt::WaitCursor));
 		}
 		return false;
diff -Naupr scribus-1.6.2/scribus/plugins/import/qxp/importqxp.cpp scribus16x/scribus/plugins/import/qxp/importqxp.cpp
--- scribus-1.6.2/scribus/plugins/import/qxp/importqxp.cpp	2024-06-15 16:22:26.000000000 +0200
+++ scribus16x/scribus/plugins/import/qxp/importqxp.cpp	2025-01-04 10:59:04.874406900 +0100
@@ -360,7 +360,7 @@ bool QxpPlug::convert(QString fn)
 		{
 			ScribusMainWindow* mw=(m_Doc==0) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 			qApp->changeOverrideCursor(QCursor(Qt::ArrowCursor));
-			ScMessageBox::warning(mw, CommonStrings::trWarning, tr("Parsing failed!\n\nPlease submit your file (if possible) to the\nDocument Liberation Project http://www.documentliberation.org"));
+			ScMessageBox::warning(mw, CommonStrings::trWarning, tr("Parsing failed!\n\nPlease submit your file (if possible) to the\nDocument Liberation Project https://www.documentliberation.org"));
 			qApp->changeOverrideCursor(QCursor(Qt::WaitCursor));
 		}
 		return false;
diff -Naupr scribus-1.6.2/scribus/plugins/import/svm/importsvm.cpp scribus16x/scribus/plugins/import/svm/importsvm.cpp
--- scribus-1.6.2/scribus/plugins/import/svm/importsvm.cpp	2024-06-15 16:22:27.000000000 +0200
+++ scribus16x/scribus/plugins/import/svm/importsvm.cpp	2025-01-04 10:59:04.764409196 +0100
@@ -1878,6 +1878,15 @@ void SvmPlug::handleSmallText(QDataStrea
 			aTxt += char(ch);
 		}
 	}
+	else if (currentDC.fontEnc == 0x4C) // UTF-8
+	{
+		quint16 numChar;
+		ds >> numChar;
+		QByteArray utf8Data(numChar, 0);
+		qint64 numCharRead = ds.readRawData(utf8Data.data(), numChar);
+		if (numChar == numCharRead)
+			aTxt = QString::fromUtf8(utf8Data);
+	}
 	else
 	{
 		quint16 length;
@@ -1949,6 +1958,15 @@ void SvmPlug::handleText(QDataStream &ds
 			aTxt += char(ch);
 		}
 	}
+	else if (currentDC.fontEnc == 0x4C) // UTF-8
+	{
+		quint16 numChar;
+		ds >> numChar;
+		QByteArray utf8Data(numChar, 0);
+		qint64 numCharRead = ds.readRawData(utf8Data.data(), numChar);
+		if (numChar == numCharRead)
+			aTxt = QString::fromUtf8(utf8Data);
+	}
 	else
 	{
 		quint16 numChar;
diff -Naupr scribus-1.6.2/scribus/plugins/import/vsd/importvsd.cpp scribus16x/scribus/plugins/import/vsd/importvsd.cpp
--- scribus-1.6.2/scribus/plugins/import/vsd/importvsd.cpp	2024-06-15 16:22:27.000000000 +0200
+++ scribus16x/scribus/plugins/import/vsd/importvsd.cpp	2025-01-04 10:59:04.918405981 +0100
@@ -356,7 +356,7 @@ bool VsdPlug::convert(const QString& fn)
 			{
 				ScribusMainWindow* mw = (m_Doc == nullptr) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 				qApp->changeOverrideCursor(QCursor(Qt::ArrowCursor));
-				ScMessageBox::warning(mw, CommonStrings::trWarning, tr("Parsing failed!\n\nPlease submit your file (if possible) to the\nDocument Liberation Project http://www.documentliberation.org"));
+				ScMessageBox::warning(mw, CommonStrings::trWarning, tr("Parsing failed!\n\nPlease submit your file (if possible) to the\nDocument Liberation Project https://www.documentliberation.org"));
 				qApp->changeOverrideCursor(QCursor(Qt::WaitCursor));
 			}
 		}
diff -Naupr scribus-1.6.2/scribus/plugins/import/wmf/wmfstruct.h scribus16x/scribus/plugins/import/wmf/wmfstruct.h
--- scribus-1.6.2/scribus/plugins/import/wmf/wmfstruct.h	2024-06-15 16:22:27.000000000 +0200
+++ scribus16x/scribus/plugins/import/wmf/wmfstruct.h	2025-01-04 10:59:04.816408110 +0100
@@ -11,38 +11,38 @@ for which a new license (GPL+exception)
 #ifndef wmfstruct_h
 #define wmfstruct_h
 
-typedef qint16 WORD16;
-typedef qint32 WORD32;
-typedef qint32 LONG32;
-typedef void* _HANDLE;
+using WORD16 = qint16;
+using WORD32 = qint32;
+using LONG32 = qint32;
+using _HANDLE = void*;
 
-typedef struct _RECT16
+struct RECT16
 {
     WORD16 left;
     WORD16 top;
     WORD16 right;
     WORD16 bottom;
-} RECT16;
+};
 
-typedef struct _RECT32
+struct RECT32
 {
     LONG32 left;
     LONG32 top;
     LONG32 right;
     LONG32 bottom;
-} RECT32;
+};
 
-typedef struct _SIZE16
+struct SIZE16
 {
     WORD16 width;
     WORD16 height;
-} SIZE16;
+};
 
-typedef struct _SIZE32
+struct SIZE32
 {
     LONG32 width;
     LONG32 height;
-} SIZE32;
+};
 
 
 struct WmfEnhMetaHeader
diff -Naupr scribus-1.6.2/scribus/plugins/import/zmf/importzmf.cpp scribus16x/scribus/plugins/import/zmf/importzmf.cpp
--- scribus-1.6.2/scribus/plugins/import/zmf/importzmf.cpp	2024-06-15 16:22:27.000000000 +0200
+++ scribus16x/scribus/plugins/import/zmf/importzmf.cpp	2025-01-04 10:59:04.923405877 +0100
@@ -348,7 +348,7 @@ bool ZmfPlug::convert(QString fn)
 		{
 			ScribusMainWindow* mw=(m_Doc==0) ? ScCore->primaryMainWindow() : m_Doc->scMW();
 			qApp->changeOverrideCursor(QCursor(Qt::ArrowCursor));
-			ScMessageBox::warning(mw, CommonStrings::trWarning, tr("Parsing failed!\n\nPlease submit your file (if possible) to the\nDocument Liberation Project http://www.documentliberation.org"));
+			ScMessageBox::warning(mw, CommonStrings::trWarning, tr("Parsing failed!\n\nPlease submit your file (if possible) to the\nDocument Liberation Project https://www.documentliberation.org"));
 			qApp->changeOverrideCursor(QCursor(Qt::WaitCursor));
 		}
 		return false;
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/cmdcell.cpp scribus16x/scribus/plugins/scriptplugin/cmdcell.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/cmdcell.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/cmdcell.cpp	2025-01-04 10:59:06.316376803 +0100
@@ -25,7 +25,7 @@ PyObject *scribus_getcelltext(PyObject*
 	PageItem *i = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (i == nullptr)
 		return nullptr;
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot get cell text on a non-table item.","python error").toLocal8Bit().constData());
@@ -37,7 +37,7 @@ PyObject *scribus_getcelltext(PyObject*
 		return nullptr;
 	}
 
-	PageItem* textFrame = table->cellAt(row, column).textFrame();
+	const PageItem* textFrame = table->cellAt(row, column).textFrame();
 	const StoryText& story = textFrame->itemText;
 	QString text;
 	text.reserve(story.hasSelection() ? story.selectionLength() : story.length());
@@ -68,7 +68,7 @@ PyObject *scribus_setcelltext(PyObject*
 	PageItem *i = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (i == nullptr)
 		return nullptr;
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot set cell text on a non-table item.","python error").toLocal8Bit().constData());
@@ -94,7 +94,7 @@ PyObject *scribus_getcellstyle(PyObject*
 	PageItem *i = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (i == nullptr)
 		return nullptr;
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot get cell style on a non-table item.","python error").toLocal8Bit().constData());
@@ -120,7 +120,7 @@ PyObject *scribus_setcellstyle(PyObject*
 	PageItem *i = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (i == nullptr)
 		return nullptr;
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot set cell style on a non-table item.","python error").toLocal8Bit().constData());
@@ -146,7 +146,7 @@ PyObject *scribus_getcellrowspan(PyObjec
 	PageItem *i = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (i == nullptr)
 		return nullptr;
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot get cell row span from non-table item.","python error").toLocal8Bit().constData());
@@ -166,7 +166,7 @@ PyObject *scribus_getcellcolumnspan(PyOb
 	PageItem *i = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (i == nullptr)
 		return nullptr;
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot get cell column span from non-table item.","python error").toLocal8Bit().constData());
@@ -186,7 +186,7 @@ PyObject *scribus_getcellfillcolor(PyObj
 	PageItem *i = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (i == nullptr)
 		return nullptr;
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot get cell fill color on a non-table item.","python error").toLocal8Bit().constData());
@@ -212,7 +212,7 @@ PyObject *scribus_setcellfillcolor(PyObj
 	PageItem *i = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (i == nullptr)
 		return nullptr;
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot set cell fill color on a non-table item.","python error").toLocal8Bit().constData());
@@ -239,7 +239,7 @@ PyObject *scribus_setcellleftborder(PyOb
 	PageItem *i = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (i == nullptr)
 		return nullptr;
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot set cell left border on a non-table item.","python error").toLocal8Bit().constData());
@@ -273,7 +273,7 @@ PyObject *scribus_setcellrightborder(PyO
 	PageItem *i = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (i == nullptr)
 		return nullptr;
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot set cell right border on a non-table item.","python error").toLocal8Bit().constData());
@@ -307,7 +307,7 @@ PyObject *scribus_setcelltopborder(PyObj
 	PageItem *i = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (i == nullptr)
 		return nullptr;
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot set cell top border on a non-table item.","python error").toLocal8Bit().constData());
@@ -341,7 +341,7 @@ PyObject *scribus_setcellbottomborder(Py
 	PageItem *i = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (i == nullptr)
 		return nullptr;
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot set cell bottom border on a non-table item.","python error").toLocal8Bit().constData());
@@ -375,7 +375,7 @@ PyObject *scribus_setcellleftpadding(PyO
 	PageItem *i = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (i == nullptr)
 		return nullptr;
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot set cell left padding on a non-table item.","python error").toLocal8Bit().constData());
@@ -408,7 +408,7 @@ PyObject *scribus_setcellrightpadding(Py
 	PageItem *i = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (i == nullptr)
 		return nullptr;
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot set cell right padding on a non-table item.","python error").toLocal8Bit().constData());
@@ -441,7 +441,7 @@ PyObject *scribus_setcelltoppadding(PyOb
 	PageItem *i = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (i == nullptr)
 		return nullptr;
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot set cell top padding on a non-table item.","python error").toLocal8Bit().constData());
@@ -474,7 +474,7 @@ PyObject *scribus_setcellbottompadding(P
 	PageItem *i = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (i == nullptr)
 		return nullptr;
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot set cell bottom padding on a non-table item.","python error").toLocal8Bit().constData());
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/cmdcolor.cpp scribus16x/scribus/plugins/scriptplugin/cmdcolor.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/cmdcolor.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/cmdcolor.cpp	2025-01-04 10:59:06.316376803 +0100
@@ -15,13 +15,10 @@ for which a new license (GPL+exception)
 
 PyObject *scribus_getcolornames(PyObject* /* self */)
 {
-	ColorList edc;
-	PyObject *l;
 	int cc = 0;
-	edc = ScCore->primaryMainWindow()->HaveDoc ? ScCore->primaryMainWindow()->doc->PageColors : PrefsManager::instance().colorSet();
-	ColorList::Iterator it;
-	l = PyList_New(edc.count());
-	for (it = edc.begin(); it != edc.end(); ++it)
+	ColorList edc = ScCore->primaryMainWindow()->HaveDoc ? ScCore->primaryMainWindow()->doc->PageColors : PrefsManager::instance().colorSet();
+	PyObject* l = PyList_New(edc.count());
+	for (auto it = edc.begin(); it != edc.end(); ++it)
 	{
 		PyList_SetItem(l, cc, PyUnicode_FromString(it.key().toUtf8()));
 		cc++;
@@ -42,7 +39,7 @@ PyObject *scribus_getcolor(PyObject* /*
 		return nullptr;
 	}
 	edc = ScCore->primaryMainWindow()->HaveDoc ? ScCore->primaryMainWindow()->doc->PageColors : PrefsManager::instance().colorSet();
-	ScribusDoc* currentDoc = ScCore->primaryMainWindow()->HaveDoc ? ScCore->primaryMainWindow()->doc : nullptr;
+	const ScribusDoc* currentDoc = ScCore->primaryMainWindow()->HaveDoc ? ScCore->primaryMainWindow()->doc : nullptr;
 	QString col = QString::fromUtf8(name.c_str());
 	if (!edc.contains(col))
 	{
@@ -68,7 +65,7 @@ PyObject *scribus_getcolorfloat(PyObject
 		return nullptr;
 	}
 	edc = ScCore->primaryMainWindow()->HaveDoc ? ScCore->primaryMainWindow()->doc->PageColors : PrefsManager::instance().colorSet();
-	ScribusDoc* currentDoc = ScCore->primaryMainWindow()->HaveDoc ? ScCore->primaryMainWindow()->doc : nullptr;
+	const ScribusDoc* currentDoc = ScCore->primaryMainWindow()->HaveDoc ? ScCore->primaryMainWindow()->doc : nullptr;
 	QString col = QString::fromUtf8(name.c_str());
 	if (!edc.contains(col))
 	{
@@ -93,7 +90,7 @@ PyObject *scribus_getcolorasrgb(PyObject
 		return nullptr;
 	}
 	edc = ScCore->primaryMainWindow()->HaveDoc ? ScCore->primaryMainWindow()->doc->PageColors : PrefsManager::instance().colorSet();
-	ScribusDoc* currentDoc = ScCore->primaryMainWindow()->HaveDoc ? ScCore->primaryMainWindow()->doc : nullptr;
+	const ScribusDoc* currentDoc = ScCore->primaryMainWindow()->HaveDoc ? ScCore->primaryMainWindow()->doc : nullptr;
 	QString col = QString::fromUtf8(name.c_str());
 	if (!edc.contains(col))
 	{
@@ -117,7 +114,7 @@ PyObject *scribus_getcolorasrgbfloat(PyO
 		return nullptr;
 	}
 	edc = ScCore->primaryMainWindow()->HaveDoc ? ScCore->primaryMainWindow()->doc->PageColors : PrefsManager::instance().colorSet();
-	ScribusDoc* currentDoc = ScCore->primaryMainWindow()->HaveDoc ? ScCore->primaryMainWindow()->doc : nullptr;
+	const ScribusDoc* currentDoc = ScCore->primaryMainWindow()->HaveDoc ? ScCore->primaryMainWindow()->doc : nullptr;
 	QString col = QString::fromUtf8(name.c_str());
 	if (!edc.contains(col))
 	{
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/cmddoc.cpp scribus16x/scribus/plugins/scriptplugin/cmddoc.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/cmddoc.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/cmddoc.cpp	2025-01-04 10:59:06.316376803 +0100
@@ -22,7 +22,6 @@ PyObject *scribus_newdocument(PyObject*
 {
 	double topMargin, bottomMargin, leftMargin, rightMargin;
 	double pageWidth, pageHeight;
-//	int orientation, firstPageNr, unit, pagesType, facingPages, firstPageOrder, numPages;
 	int orientation, firstPageNr, unit, pagesType, firstPageOrder, numPages;
 
 	PyObject *p, *m;
@@ -113,6 +112,20 @@ PyObject *scribus_newdoc(PyObject* /* se
 	return PyLong_FromLong(static_cast<long>(ret));
 }
 
+PyObject *scribus_getbleeds(PyObject */* self */, PyObject* /*args*/)
+{
+	if (!checkHaveDocument())
+		return nullptr;
+
+	const MarginStruct& bleeds = ScCore->primaryMainWindow()->doc->bleedsVal();
+
+	return Py_BuildValue("(dddd)",
+		PointToValue(bleeds.left()),
+		PointToValue(bleeds.right()),
+		PointToValue(bleeds.top()),
+		PointToValue(bleeds.bottom()));
+}
+
 PyObject *scribus_setbleeds(PyObject */* self */, PyObject *args)
 {
 	double lr, tpr, btr, rr;
@@ -131,6 +144,20 @@ PyObject *scribus_setbleeds(PyObject */*
 	Py_RETURN_NONE;
 }
 
+PyObject* scribus_getmargins(PyObject*/* self */, PyObject* /*args*/)
+{
+	if (!checkHaveDocument())
+		return nullptr;
+
+	const MarginStruct& margins = ScCore->primaryMainWindow()->doc->marginsVal();
+
+	return Py_BuildValue("(dddd)",
+		PointToValue(margins.left()),
+		PointToValue(margins.right()),
+		PointToValue(margins.top()),
+		PointToValue(margins.bottom()));
+}
+
 PyObject *scribus_setmargins(PyObject* /* self */, PyObject* args)
 {
 	double lr, tpr, btr, rr;
@@ -151,6 +178,18 @@ PyObject *scribus_setmargins(PyObject* /
 	Py_RETURN_NONE;
 }
 
+PyObject* scribus_getbaseline(PyObject* /* self */)
+{
+	if (!checkHaveDocument())
+		return nullptr;
+
+	const GuidesPrefs& guides = ScCore->primaryMainWindow()->doc->guidesPrefs();
+
+	return Py_BuildValue("(dd)",
+		PointToValue(guides.valueBaselineGrid),
+		PointToValue(guides.offsetBaselineGrid));
+}
+
 PyObject *scribus_setbaseline(PyObject* /* self */, PyObject* args)
 {
 	double grid, offset;
@@ -171,14 +210,13 @@ PyObject *scribus_setbaseline(PyObject*
 	Py_RETURN_NONE;
 }
 
-
 PyObject *scribus_closedoc(PyObject* /* self */)
 {
 	if (!checkHaveDocument())
 		return nullptr;
 	ScCore->primaryMainWindow()->doc->setModified(false);
 	bool ret = ScCore->primaryMainWindow()->slotFileClose();
-	qApp->processEvents();
+	QApplication::processEvents();
 	return PyLong_FromLong(static_cast<long>(ret));
 }
 
@@ -280,7 +318,7 @@ PyObject *scribus_getinfo(PyObject* /* s
 		return PyUnicode_FromString("");
 	}
 
-	DocumentInformation& docInfo = ScCore->primaryMainWindow()->doc->documentInfo();
+	const DocumentInformation& docInfo = ScCore->primaryMainWindow()->doc->documentInfo();
 	return Py_BuildValue("(sss)",
 				docInfo.author().toUtf8().data(),
 				docInfo.title().toUtf8().data(),
@@ -311,6 +349,43 @@ PyObject *scribus_getunit(PyObject* /* s
 	return PyLong_FromLong(static_cast<long>(ScCore->primaryMainWindow()->doc->unitIndex()));
 }
 
+PyObject *scribus_pointstodocunit(PyObject* /* self */, PyObject *args)
+{
+    double points;
+    if (!PyArg_ParseTuple(args, "d", &points))
+        return nullptr;
+    if (!checkHaveDocument())
+        return nullptr;
+
+    return Py_BuildValue("d", PointToValue(points));
+}
+
+PyObject *scribus_docunittopoints(PyObject* /* self */, PyObject *args)
+{
+    double value;
+    if (!PyArg_ParseTuple(args, "d", &value))
+        return nullptr;
+    if (!checkHaveDocument())
+        return nullptr;
+
+    return Py_BuildValue("d", ValueToPoint(value));
+}
+
+PyObject *scribus_stringvaluetopoints(PyObject* /* self */, PyObject *args)
+{
+    PyESString strValue;
+    if (!PyArg_ParseTuple(args, "es", "utf-8", strValue.ptr()))
+        return nullptr;
+
+    QString qv = QString::fromUtf8(strValue.c_str());
+
+    int uIdx = unitIndexFromString(qv);
+    double value = unitValueFromString(qv);
+    double points = value / unitGetRatioFromIndex(uIdx);
+
+    return Py_BuildValue("d", points);
+}
+
 PyObject *scribus_loadstylesfromfile(PyObject* /* self */, PyObject *args)
 {
 	PyESString fileName;
@@ -358,7 +433,7 @@ PyObject *scribus_masterpagenames(PyObje
 {
 	if (!checkHaveDocument())
 		return nullptr;
-	ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
+	const ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
 
 	PyObject* names = PyList_New(currentDoc->MasterPages.count());
 	QMap<QString,int>::const_iterator it(currentDoc->MasterNames.constBegin());
@@ -448,8 +523,8 @@ PyObject *scribus_getmasterpage(PyObject
 		return nullptr;
 	e--;
 
-	ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
-	if ((e < 0) || (e > static_cast<int>(currentDoc->Pages->count())-1))
+	const ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
+	if ((e < 0) || (e > currentDoc->Pages->count() - 1))
 	{
 		PyErr_SetString(PyExc_IndexError, QObject::tr("Page number out of range: '%1'.","python error").arg(e+1).toLocal8Bit().constData());
 		return nullptr;
@@ -473,7 +548,7 @@ PyObject* scribus_applymasterpage(PyObje
 		PyErr_SetString(PyExc_ValueError, QObject::tr("Master page does not exist: '%1'","python error").arg(masterPageName).toLocal8Bit().constData());
 		return nullptr;
 	}
-	if ((page < 1) || (page > static_cast<int>(currentDoc->Pages->count())))
+	if ((page < 1) || (page > currentDoc->Pages->count()))
 	{
 		PyErr_SetString(PyExc_IndexError, QObject::tr("Page number out of range: %1.","python error").arg(page).toLocal8Bit().constData());
 		return nullptr;
@@ -498,9 +573,12 @@ void cmddocdocwarnings()
 	  << scribus_closemasterpage__doc__
 	  << scribus_createmasterpage__doc__
 	  << scribus_deletemasterpage__doc__
-	  << scribus_editmasterpage__doc__ 
+	  << scribus_editmasterpage__doc__
+	  << scribus_getbaseline__doc__ 
+	  << scribus_getbleeds__doc__ 
 	  << scribus_getdocname__doc__
 	  << scribus_getinfo__doc__
+	  << scribus_getmargins__doc__
 	  << scribus_getmasterpage__doc__
 	  << scribus_getunit__doc__ 
 	  << scribus_havedoc__doc__
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/cmddoc.h scribus16x/scribus/plugins/scriptplugin/cmddoc.h
--- scribus-1.6.2/scribus/plugins/scriptplugin/cmddoc.h	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/cmddoc.h	2025-01-04 10:59:06.320376720 +0100
@@ -194,6 +194,17 @@ strings.\n\
 PyObject *scribus_getinfo(PyObject * /*self*/);
 
 /*! docstring */
+PyDoc_STRVAR(scribus_getbleeds__doc__,
+QT_TR_NOOP("getBleeds() -> (lr, rr, tr, br)\n\
+\n\
+Gets the bleeds of the document. Left(lr), Right(rr), Top(tr) and Bottom(br)\n\
+bleeds are given in the measurement units of the document - see UNIT_<type>\n\
+constants.\n\
+"));
+/** Sets document bleeds - left, right, top and bottom. */
+PyObject *scribus_getbleeds(PyObject * /*self*/, PyObject* args);
+
+/*! docstring */
 PyDoc_STRVAR(scribus_setbleeds__doc__,
 QT_TR_NOOP("setBleeds(lr, rr, tr, br)\n\
 \n\
@@ -205,6 +216,17 @@ constants.\n\
 PyObject *scribus_setbleeds(PyObject * /*self*/, PyObject* args);
 
 /*! docstring */
+PyDoc_STRVAR(scribus_getmargins__doc__,
+QT_TR_NOOP("getMargins() -> (lr, rr, tr, br)\n\
+\n\
+Gets the margins of the document, Left(lr), Right(rr), Top(tr) and Bottom(br)\n\
+margins are given in the measurement units of the document - see UNIT_<type>\n\
+constants.\n\
+"));
+/** Sets document margins - left, right, top and bottom. */
+PyObject *scribus_getmargins(PyObject * /*self*/, PyObject* args);
+
+/*! docstring */
 PyDoc_STRVAR(scribus_setmargins__doc__,
 QT_TR_NOOP("setMargins(lr, rr, tr, br)\n\
 \n\
@@ -216,6 +238,17 @@ constants.\n\
 PyObject *scribus_setmargins(PyObject * /*self*/, PyObject* args);
 
 /*! docstring */
+PyDoc_STRVAR(scribus_getbaseline__doc__,
+    QT_TR_NOOP("getBaseLine() -> (grid, offset)\n\
+\n\
+Gets the base line settings of the document, grid spacing(grid), grid offset(offset).\n\
+Values are given in the measurement units of the document - see UNIT_<type>\n\
+constants.\n\
+"));
+/** Sets document baseline settings - grid and offset. */
+PyObject* scribus_getbaseline(PyObject* /*self*/);
+
+/*! docstring */
 PyDoc_STRVAR(scribus_setbaseline__doc__,
 QT_TR_NOOP("setBaseLine(grid, offset)\n\
 \n\
@@ -235,7 +268,7 @@ defined as constants UNIT_<type>.\n\
 \n\
 May raise ValueError if an invalid unit is passed.\n\
 "));
-/** Changes unit scale. */
+/** Changes the document unit. */
 PyObject *scribus_setunit(PyObject * /*self*/, PyObject* args);
 
 /*! docstring */
@@ -246,10 +279,37 @@ Returns the measurement units of the doc
 of the UNIT_* constants:\n\
 UNIT_INCHES, UNIT_MILLIMETERS, UNIT_PICAS, UNIT_POINTS.\n\
 "));
-/** Returns actual unit scale. */
+/** Returns actual document unit. */
 PyObject *scribus_getunit(PyObject * /*self*/);
 
 /*! docstring */
+PyDoc_STRVAR(scribus_pointstodocunit__doc__,
+QT_TR_NOOP("pointsToDocUnit(points) -> value\n\
+\n\
+Returns a value in the measurement units of the document converted from points.\n\
+"));
+/** Converts from points to the document unit. */
+PyObject *scribus_pointstodocunit(PyObject * /*self*/, PyObject* args);
+
+/*! docstring */
+PyDoc_STRVAR(scribus_docunittopoints__doc__,
+QT_TR_NOOP("docUnitToPoints(value) -> points\n\
+\n\
+Returns a value in points converted from the measurement units of the document.\n\
+"));
+/** Converts from the document unit to points. */
+PyObject *scribus_docunittopoints(PyObject * /*self*/, PyObject* args);
+
+/*! docstring */
+PyDoc_STRVAR(scribus_stringvaluetopoints__doc__,
+QT_TR_NOOP("stringValueToPoints(\"10mm\") -> points\n\
+\n\
+Returns a value in points converted from a string value (\"5mm\", \"2in\" et.c.).\n\
+"));
+/** Converts a string value ("5mm", "2in" et.c.) to points. */
+PyObject *scribus_stringvaluetopoints(PyObject * /*self*/, PyObject *args);
+
+/*! docstring */
 PyDoc_STRVAR(scribus_loadstylesfromfile__doc__,
 QT_TR_NOOP("loadStylesFromFile(\"filename\")\n\
 \n\
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/cmdgetprop.cpp scribus16x/scribus/plugins/scriptplugin/cmdgetprop.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/cmdgetprop.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/cmdgetprop.cpp	2025-01-04 10:59:06.317376783 +0100
@@ -17,7 +17,6 @@ for which a new license (GPL+exception)
 PyObject *scribus_getobjecttype(PyObject* /* self */, PyObject* args)
 {
 	PyESString name;
-	PageItem *item = nullptr;
 	QString result = "";
 
 	if (!PyArg_ParseTuple(args, "|es", "utf-8", name.ptr()))
@@ -26,7 +25,7 @@ PyObject *scribus_getobjecttype(PyObject
 	if (!checkHaveDocument())
 		return nullptr;
 
-	item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem* item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 
@@ -74,7 +73,7 @@ PyObject *scribus_getfillcolor(PyObject*
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	return PyUnicode_FromString(item->fillColor().toUtf8());
@@ -87,7 +86,7 @@ PyObject *scribus_getfilltransparency(Py
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	return PyFloat_FromDouble(1.0 - item->fillTransparency());
@@ -100,7 +99,7 @@ PyObject *scribus_getfillblendmode(PyObj
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	return PyLong_FromLong(static_cast<long>(item->fillBlendmode()));
@@ -113,7 +112,7 @@ PyObject *scribus_getcustomlinestyle(PyO
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	return PyUnicode_FromString(item->customLineStyle().toUtf8());
@@ -126,7 +125,7 @@ PyObject *scribus_getlinecolor(PyObject*
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	return PyUnicode_FromString(item->lineColor().toUtf8());
@@ -139,7 +138,7 @@ PyObject *scribus_getlinetransparency(Py
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	return PyFloat_FromDouble(1.0 - item->lineTransparency());
@@ -152,7 +151,7 @@ PyObject *scribus_getlineblendmode(PyObj
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	return PyLong_FromLong(static_cast<long>(item->lineBlendmode()));
@@ -165,7 +164,7 @@ PyObject *scribus_getlinewidth(PyObject*
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	return PyFloat_FromDouble(item->lineWidth());
@@ -178,7 +177,7 @@ PyObject *scribus_getlineshade(PyObject*
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	return PyLong_FromLong(static_cast<long>(item->lineShade()));
@@ -191,7 +190,7 @@ PyObject *scribus_getlinejoin(PyObject*
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	return PyLong_FromLong(static_cast<long>(item->PLineJoin));
@@ -204,7 +203,7 @@ PyObject *scribus_getlinecap(PyObject* /
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	return PyLong_FromLong(static_cast<long>(item->PLineEnd));
@@ -217,7 +216,7 @@ PyObject *scribus_getlinestyle(PyObject*
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	return PyLong_FromLong(static_cast<long>(item->PLineArt));
@@ -230,7 +229,7 @@ PyObject *scribus_getfillshade(PyObject*
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	return PyLong_FromLong(static_cast<long>(item->fillShade()));
@@ -243,7 +242,7 @@ PyObject *scribus_getcornerradius(PyObje
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	return PyLong_FromLong(static_cast<long>(item->cornerRadius()));
@@ -256,7 +255,7 @@ PyObject *scribus_getimageoffset(PyObjec
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	return Py_BuildValue("(ff)", item->imageXOffset() * item->imageXScale(), item->imageYOffset() * item->imageYScale());
@@ -269,7 +268,7 @@ PyObject *scribus_getimagescale(PyObject
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	return Py_BuildValue("(ff)", item->imageXScale() / 72.0 * item->pixm.imgInfo.xres, item->imageYScale() / 72.0 * item->pixm.imgInfo.yres);
@@ -282,7 +281,7 @@ PyObject *scribus_getimagefile(PyObject*
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	return PyUnicode_FromString(item->Pfile.toUtf8());
@@ -295,7 +294,7 @@ PyObject *scribus_getposition(PyObject*
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	return Py_BuildValue("(ff)", docUnitXToPageX(item->xPos()),
@@ -309,7 +308,7 @@ PyObject *scribus_getsize(PyObject* /* s
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	return Py_BuildValue("(ff)", PointToValue(item->width()), PointToValue(item->height()));
@@ -322,7 +321,7 @@ PyObject *scribus_getrotation(PyObject*
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	return PyFloat_FromDouble(item->rotation() * -1.0);
@@ -406,7 +405,7 @@ PyObject *scribus_getobjectattributes(Py
 	if (!lst)
 		return nullptr;
 	int n = 0;
-	for (ObjAttrVector::Iterator objAttrIt = attributes->begin() ; objAttrIt != attributes->end(); ++objAttrIt)
+	for (auto objAttrIt = attributes->begin() ; objAttrIt != attributes->end(); ++objAttrIt)
 	{
 		PyObject *tmp;
 		tmp = Py_BuildValue("{ssssssssssssss}",
@@ -436,7 +435,7 @@ PyObject *scribus_getimagecolorspace(PyO
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	if (item->itemType() != PageItem::ImageFrame)
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/cmdgetsetprop.cpp scribus16x/scribus/plugins/scriptplugin/cmdgetsetprop.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/cmdgetsetprop.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/cmdgetsetprop.cpp	2025-01-04 10:59:06.317376783 +0100
@@ -79,7 +79,7 @@ PyObject* scribus_propertyctype(PyObject
 	objArg = nullptr; // no need to decref, it's borrowed
 
 	// Look up the property and retrieve its type information
-	const char* type = getpropertytype( (QObject*) obj, propertyname.c_str(), includesuper);
+	const char* type = getpropertytype(obj, propertyname.c_str(), includesuper);
 	if (type == nullptr)
 	{
 		PyErr_SetString(PyExc_KeyError, QObject::tr("Property not found").toLocal8Bit().constData());
@@ -94,7 +94,7 @@ PyObject* convert_QStringList_to_PyListO
 	if (!resultList)
 		return nullptr;
 
-	for ( QStringList::Iterator it = origlist.begin(); it != origlist.end(); ++it )
+	for (auto it = origlist.begin(); it != origlist.end(); ++it)
 		if (PyList_Append(resultList, PyUnicode_FromString((*it).toUtf8().data())) == -1)
 			return nullptr;
 
@@ -122,7 +122,7 @@ PyObject* convert_QObjectList_to_PyListO
 			return nullptr;
 		}
 		// and add it to the list
-		if (PyList_Append(resultList, (PyObject*)objPtr) == -1)
+		if (PyList_Append(resultList, objPtr) == -1)
 			return nullptr;
 	}
 	return resultList;
@@ -213,7 +213,7 @@ PyObject* scribus_getpropertynames(PyObj
 		return nullptr;
 
 	// Get the QObject* the object argument refers to
-	QObject* obj = getQObjectFromPyArg(objArg);
+	const QObject* obj = getQObjectFromPyArg(objArg);
 	if (!obj)
 		return nullptr;
 	objArg = nullptr; // no need to decref, it's borrowed
@@ -245,7 +245,7 @@ PyObject* scribus_getproperty(PyObject*
 		return nullptr;
 
 	// Get the QObject* the object argument refers to
-	QObject* obj = getQObjectFromPyArg(objArg);
+	const QObject* obj = getQObjectFromPyArg(objArg);
 	if (!obj)
 		return nullptr;
 	objArg = nullptr; // no need to decref, it's borrowed
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/cmdmani.cpp scribus16x/scribus/plugins/scriptplugin/cmdmani.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/cmdmani.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/cmdmani.cpp	2025-01-04 10:59:06.317376783 +0100
@@ -389,9 +389,9 @@ PyObject *scribus_groupobjects(PyObject*
 	// If we were passed a list of items to group...
 	if (il != nullptr)
 	{
-		int len = PyList_Size(il);
+		Py_ssize_t len = PyList_Size(il);
 		tempSelection = new Selection(ScCore->primaryMainWindow(), false);
-		for (int i = 0; i < len; i++)
+		for (Py_ssize_t i = 0; i < len; i++)
 		{
 			// FIXME: We might need to explicitly get this string as utf8
 			// but as sysdefaultencoding is utf8 it should be a no-op to do
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/cmdobj.cpp scribus16x/scribus/plugins/scriptplugin/cmdobj.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/cmdobj.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/cmdobj.cpp	2025-01-04 10:59:06.317376783 +0100
@@ -230,7 +230,7 @@ PyObject *scribus_createpolyline(PyObjec
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	int len = PyList_Size(il);
+	Py_ssize_t len = PyList_Size(il);
 	if (len < 4)
 	{
 		PyErr_SetString(PyExc_ValueError, QObject::tr("Point list must contain at least two points (four values).","python error").toLocal8Bit().constData());
@@ -247,10 +247,10 @@ PyObject *scribus_createpolyline(PyObjec
 //		return nullptr;
 //	}
 	double x, y, w, h;
-	int i = 0;
-	x = pageUnitXToDocX(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, i))));
+	Py_ssize_t i = 0;
+	x = pageUnitXToDocX(PyFloat_AsDouble(PyList_GetItem(il, i)));
 	i++;
-	y = pageUnitYToDocY(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, i))));
+	y = pageUnitYToDocY(PyFloat_AsDouble(PyList_GetItem(il, i)));
 	i++;
 	int ic = ScCore->primaryMainWindow()->doc->itemAdd(PageItem::PolyLine, PageItem::Unspecified, x, y, 1, 1,	ScCore->primaryMainWindow()->doc->itemToolPrefs().shapeLineWidth, ScCore->primaryMainWindow()->doc->itemToolPrefs().shapeFillColor, ScCore->primaryMainWindow()->doc->itemToolPrefs().shapeLineColor);
 	PageItem *it = ScCore->primaryMainWindow()->doc->Items->at(ic);
@@ -260,21 +260,21 @@ PyObject *scribus_createpolyline(PyObjec
 	int pp = 6;
 	for (i = 2; i < len - 2; i += 2)
 	{
-		w = pageUnitXToDocX(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, i))));
-		h = pageUnitYToDocY(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, i+1))));
+		w = pageUnitXToDocX(PyFloat_AsDouble(PyList_GetItem(il, i)));
+		h = pageUnitYToDocY(PyFloat_AsDouble(PyList_GetItem(il, i + 1)));
 		it->PoLine.resize(pp);
-		it->PoLine.setPoint(pp-4, w-x, h-y);
-		it->PoLine.setPoint(pp-3, w-x, h-y);
-		it->PoLine.setPoint(pp-2, w-x, h-y);
-		it->PoLine.setPoint(pp-1, w-x, h-y);
+		it->PoLine.setPoint(pp - 4, w - x, h - y);
+		it->PoLine.setPoint(pp - 3, w - x, h - y);
+		it->PoLine.setPoint(pp - 2, w - x, h - y);
+		it->PoLine.setPoint(pp - 1, w - x, h - y);
 		pp += 4;
 	}
 	pp -= 2;
-	w = pageUnitXToDocX(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, len-2))));
-	h = pageUnitYToDocY(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, len-1))));
+	w = pageUnitXToDocX(PyFloat_AsDouble(PyList_GetItem(il, len - 2)));
+	h = pageUnitYToDocY(PyFloat_AsDouble(PyList_GetItem(il, len - 1)));
 	it->PoLine.resize(pp);
-	it->PoLine.setPoint(pp-2, w-x, h-y);
-	it->PoLine.setPoint(pp-1, w-x, h-y);
+	it->PoLine.setPoint(pp - 2, w - x, h - y);
+	it->PoLine.setPoint(pp - 1, w - x, h - y);
 	FPoint np2 = getMinClipF(&it->PoLine);
 	if (np2.x() < 0)
 	{
@@ -307,7 +307,7 @@ PyObject *scribus_createpolygon(PyObject
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	int len = PyList_Size(il);
+	Py_ssize_t len = PyList_Size(il);
 	if (len < 6)
 	{
 		PyErr_SetString(PyExc_ValueError, QObject::tr("Point list must contain at least three points (six values).","python error").toLocal8Bit().constData());
@@ -324,10 +324,10 @@ PyObject *scribus_createpolygon(PyObject
 //		return nullptr;
 //	}
 	double x, y, w, h;
-	int i = 0;
-	x = pageUnitXToDocX(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, i))));
+	Py_ssize_t i = 0;
+	x = pageUnitXToDocX(PyFloat_AsDouble(PyList_GetItem(il, i)));
 	i++;
-	y = pageUnitYToDocY(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, i))));
+	y = pageUnitYToDocY(PyFloat_AsDouble(PyList_GetItem(il, i)));
 	i++;
 	int ic = ScCore->primaryMainWindow()->doc->itemAdd(PageItem::Polygon, PageItem::Unspecified, x, y, 1, 1,	ScCore->primaryMainWindow()->doc->itemToolPrefs().shapeLineWidth, ScCore->primaryMainWindow()->doc->itemToolPrefs().shapeFillColor, ScCore->primaryMainWindow()->doc->itemToolPrefs().shapeLineColor);
 	PageItem *it = ScCore->primaryMainWindow()->doc->Items->at(ic);
@@ -337,26 +337,26 @@ PyObject *scribus_createpolygon(PyObject
 	int pp = 6;
 	for (i = 2; i < len - 2; i += 2)
 	{
-		w = pageUnitXToDocX(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, i))));
-		h = pageUnitYToDocY(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, i+1))));
+		w = pageUnitXToDocX(PyFloat_AsDouble(PyList_GetItem(il, i)));
+		h = pageUnitYToDocY(PyFloat_AsDouble(PyList_GetItem(il, i + 1)));
 		it->PoLine.resize(pp);
-		it->PoLine.setPoint(pp-4, w-x, h-y);
-		it->PoLine.setPoint(pp-3, w-x, h-y);
-		it->PoLine.setPoint(pp-2, w-x, h-y);
-		it->PoLine.setPoint(pp-1, w-x, h-y);
+		it->PoLine.setPoint(pp - 4, w - x, h - y);
+		it->PoLine.setPoint(pp - 3, w - x, h - y);
+		it->PoLine.setPoint(pp - 2, w - x, h - y);
+		it->PoLine.setPoint(pp - 1, w - x, h - y);
 		pp += 4;
 	}
-	w = pageUnitXToDocX(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, len-2))));
-	h = pageUnitYToDocY(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, len-1))));
+	w = pageUnitXToDocX(PyFloat_AsDouble(PyList_GetItem(il, len - 2)));
+	h = pageUnitYToDocY(PyFloat_AsDouble(PyList_GetItem(il, len - 1)));
 	it->PoLine.resize(pp);
-	it->PoLine.setPoint(pp-4, w-x, h-y);
-	it->PoLine.setPoint(pp-3, w-x, h-y);
-	it->PoLine.setPoint(pp-2, w-x, h-y);
-	it->PoLine.setPoint(pp-1, w-x, h-y);
+	it->PoLine.setPoint(pp - 4, w - x, h - y);
+	it->PoLine.setPoint(pp - 3, w - x, h - y);
+	it->PoLine.setPoint(pp - 2, w - x, h - y);
+	it->PoLine.setPoint(pp - 1, w - x, h - y);
 	pp += 2;
 	it->PoLine.resize(pp);
-	it->PoLine.setPoint(pp-2, 0, 0);
-	it->PoLine.setPoint(pp-1, 0, 0);
+	it->PoLine.setPoint(pp - 2, 0, 0);
+	it->PoLine.setPoint(pp - 1, 0, 0);
 	FPoint np2 = getMinClipF(&it->PoLine);
 	if (np2.x() < 0)
 	{
@@ -388,7 +388,7 @@ PyObject *scribus_createbezierline(PyObj
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	int len = PyList_Size(il);
+	Py_ssize_t len = PyList_Size(il);
 	if (len < 8)
 	{
 		PyErr_SetString(PyExc_ValueError, QObject::tr("Point list must contain at least four points (eight values).","python error").toLocal8Bit().constData());
@@ -405,49 +405,49 @@ PyObject *scribus_createbezierline(PyObj
 //		return nullptr;
 //	}
 	double x, y, w, h, kx, ky, kx2, ky2;
-	int i = 0;
-	x = pageUnitXToDocX(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, i))));
+	Py_ssize_t i = 0;
+	x = pageUnitXToDocX(PyFloat_AsDouble(PyList_GetItem(il, i)));
 	i++;
-	y = pageUnitYToDocY(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, i))));
+	y = pageUnitYToDocY(PyFloat_AsDouble(PyList_GetItem(il, i)));
 	i++;
-	kx = pageUnitXToDocX(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, i))));
+	kx = pageUnitXToDocX(PyFloat_AsDouble(PyList_GetItem(il, i)));
 	i++;
-	ky = pageUnitYToDocY(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, i))));
+	ky = pageUnitYToDocY(PyFloat_AsDouble(PyList_GetItem(il, i)));
 	i++;
-	kx2 = pageUnitXToDocX(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, i))));
+	kx2 = pageUnitXToDocX(PyFloat_AsDouble(PyList_GetItem(il, i)));
 	i++;
-	ky2 = pageUnitYToDocY(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, i))));
+	ky2 = pageUnitYToDocY(PyFloat_AsDouble(PyList_GetItem(il, i)));
 	i++;
 	//int ic = ScCore->primaryMainWindow()->view->PaintPolyLine(x, y, 1, 1,	ScCore->primaryMainWindow()->doc->toolSettings.dWidth, ScCore->primaryMainWindow()->doc->toolSettings.dBrush, ScCore->primaryMainWindow()->doc->toolSettings.dPen);
 	int ic = ScCore->primaryMainWindow()->doc->itemAdd(PageItem::PolyLine, PageItem::Unspecified, x, y, 1, 1,	ScCore->primaryMainWindow()->doc->itemToolPrefs().shapeLineWidth, ScCore->primaryMainWindow()->doc->itemToolPrefs().shapeFillColor, ScCore->primaryMainWindow()->doc->itemToolPrefs().shapeLineColor);
 	PageItem *it = ScCore->primaryMainWindow()->doc->Items->at(ic);
 	it->PoLine.resize(2);
 	it->PoLine.setPoint(0, 0, 0);
-	it->PoLine.setPoint(1, kx-x, ky-y);
+	it->PoLine.setPoint(1, kx - x, ky - y);
 	int pp = 6;
 	for (i = 6; i < len - 6; i += 6)
 	{
-		w = pageUnitXToDocX(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, i))));
-		h = pageUnitYToDocY(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, i+1))));
-		kx = pageUnitXToDocX(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, i+2))));
-		ky = pageUnitYToDocY(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, i+3))));
-		kx2 = pageUnitXToDocX(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, i+4))));
-		ky2 = pageUnitYToDocY(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, i+5))));
+		w = pageUnitXToDocX(PyFloat_AsDouble(PyList_GetItem(il, i)));
+		h = pageUnitYToDocY(PyFloat_AsDouble(PyList_GetItem(il, i + 1)));
+		kx = pageUnitXToDocX(PyFloat_AsDouble(PyList_GetItem(il, i + 2)));
+		ky = pageUnitYToDocY(PyFloat_AsDouble(PyList_GetItem(il, i + 3)));
+		kx2 = pageUnitXToDocX(PyFloat_AsDouble(PyList_GetItem(il, i + 4)));
+		ky2 = pageUnitYToDocY(PyFloat_AsDouble(PyList_GetItem(il, i + 5)));
 		it->PoLine.resize(pp);
-		it->PoLine.setPoint(pp-4, w-x, h-y);
-		it->PoLine.setPoint(pp-3, kx-x, ky-y);
-		it->PoLine.setPoint(pp-2, it->PoLine.point(pp-4));
-		it->PoLine.setPoint(pp-1, kx2-x, ky2-y);
+		it->PoLine.setPoint(pp - 4, w - x, h - y);
+		it->PoLine.setPoint(pp - 3, kx - x, ky - y);
+		it->PoLine.setPoint(pp - 2, it->PoLine.point(pp - 4));
+		it->PoLine.setPoint(pp - 1, kx2 - x, ky2 - y);
 		pp += 4;
 	}
 	pp -= 2;
-	w = pageUnitXToDocX(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, len-6))));
-	h = pageUnitYToDocY(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, len-5))));
-	kx = pageUnitXToDocX(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, len-4))));
-	ky = pageUnitYToDocY(static_cast<double>(PyFloat_AsDouble(PyList_GetItem(il, len-3))));
+	w = pageUnitXToDocX(PyFloat_AsDouble(PyList_GetItem(il, len - 6)));
+	h = pageUnitYToDocY(PyFloat_AsDouble(PyList_GetItem(il, len - 5)));
+	kx = pageUnitXToDocX(PyFloat_AsDouble(PyList_GetItem(il, len - 4)));
+	ky = pageUnitYToDocY(PyFloat_AsDouble(PyList_GetItem(il, len - 3)));
 	it->PoLine.resize(pp);
-	it->PoLine.setPoint(pp-2, w-x, h-y);
-	it->PoLine.setPoint(pp-1, kx-x, ky-y);
+	it->PoLine.setPoint(pp - 2, w - x, h - y);
+	it->PoLine.setPoint(pp - 1, kx - x, ky - y);
 	FPoint np2 = getMinClipF(&it->PoLine);
 	if (np2.x() < 0)
 	{
@@ -538,7 +538,7 @@ PyObject *scribus_gettextflowmode(PyObje
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 
@@ -600,7 +600,7 @@ PyObject *scribus_getcharacterstyle(PyOb
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	if ((item->itemType() != PageItem::TextFrame) && (item->itemType() != PageItem::PathText))
@@ -609,8 +609,8 @@ PyObject *scribus_getcharacterstyle(PyOb
 		return nullptr;
 	}
 
-	ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
-	StoryText&  itemText = item->itemText;
+	const ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
+	const StoryText&  itemText = item->itemText;
 
 	int selectionLength = itemText.selectionLength();	
 	if ((selectionLength > 0) || (currentDoc->appMode == modeEdit))
@@ -640,7 +640,7 @@ PyObject *scribus_getparagraphstyle(PyOb
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	if ((item->itemType() != PageItem::TextFrame) && (item->itemType() != PageItem::PathText))
@@ -649,8 +649,8 @@ PyObject *scribus_getparagraphstyle(PyOb
 		return nullptr;
 	}
 
-	ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
-	StoryText&  itemText = item->itemText;
+	const ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
+	const StoryText&  itemText = item->itemText;
 
 	int selectionLength = itemText.selectionLength();	
 	if ((selectionLength > 0) || (currentDoc->appMode == modeEdit))
@@ -878,8 +878,8 @@ PyObject *scribus_duplicateobjects(PyObj
 	}
 	else if ((pyObject != nullptr) && PyList_Check(pyObject))
 	{
-		int len = PyList_Size(pyObject);
-		for (int i = 0; i < len; ++i)
+		Py_ssize_t len = PyList_Size(pyObject);
+		for (Py_ssize_t i = 0; i < len; ++i)
 		{
 			PyObject* pyItem = PyList_GetItem(pyObject, i);
 			if (!PyUnicode_Check(pyItem))
@@ -926,7 +926,7 @@ PyObject *scribus_duplicateobjects(PyObj
 	PyObject* pyList = PyList_New(currentDoc->m_Selection->count());
 	for (int i = 0; i < currentDoc->m_Selection->count(); ++i)
 	{
-		PageItem* item = currentDoc->m_Selection->itemAt(i);
+		const PageItem* item = currentDoc->m_Selection->itemAt(i);
 		PyList_SetItem(pyList, i, PyUnicode_FromString(item->itemName().toUtf8()));
 	}
 	return pyList;
@@ -986,8 +986,8 @@ PyObject *scribus_copyobjects(PyObject *
 	}
 	else if ((pyObject != nullptr) && PyList_Check(pyObject))
 	{
-		int len = PyList_Size(pyObject);
-		for (int i = 0; i < len; i++)
+		Py_ssize_t len = PyList_Size(pyObject);
+		for (Py_ssize_t i = 0; i < len; i++)
 		{
 			PyObject* pyItem = PyList_GetItem(pyObject, i);
 			if (!PyUnicode_Check(pyItem))
@@ -1064,7 +1064,7 @@ PyObject *scribus_pasteobjects(PyObject
 	PyObject* pyList = PyList_New(currentDoc->m_Selection->count());
 	for (int i = 0; i < currentDoc->m_Selection->count(); ++i)
 	{
-		PageItem* item = currentDoc->m_Selection->itemAt(i);
+		const PageItem* item = currentDoc->m_Selection->itemAt(i);
 		PyList_SetItem(pyList, i, PyUnicode_FromString(item->itemName().toUtf8()));
 	}
 	return pyList;
@@ -1079,10 +1079,10 @@ PyObject *scribus_getitempagenumber(PyOb
 	if (!checkHaveDocument())
 		return nullptr;
 
-	PageItem *i = GetUniqueItem(QString::fromUtf8(name.c_str()));
-	if (i == nullptr)
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	if (item == nullptr)
 		return nullptr;
-	return PyLong_FromLong(i->OwnPage);
+	return PyLong_FromLong(item->OwnPage);
 }
 
 /*! HACK: this removes "warning: 'blah' defined but not used" compiler warnings
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/cmdpage.cpp scribus16x/scribus/plugins/scriptplugin/cmdpage.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/cmdpage.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/cmdpage.cpp	2025-01-04 10:59:06.317376783 +0100
@@ -37,7 +37,7 @@ PyObject *scribus_redraw(PyObject* /* se
 	if (!checkHaveDocument())
 		return nullptr;
 	ScCore->primaryMainWindow()->view->DrawNew();
-	qApp->processEvents();
+	QApplication::processEvents();
 
 	Py_RETURN_NONE;
 }
@@ -50,7 +50,7 @@ PyObject *scribus_getpagetype(PyObject*
 	if (!checkHaveDocument())
 		return nullptr;
 	e--;
-	if ((e < 0) || (e > static_cast<int>(ScCore->primaryMainWindow()->doc->Pages->count())-1))
+	if ((e < 0) || (e > ScCore->primaryMainWindow()->doc->Pages->count() - 1))
 	{
 		PyErr_SetString(PyExc_IndexError, QObject::tr("Page number out of range.","python error").toLocal8Bit().constData());
 		return nullptr;
@@ -75,9 +75,7 @@ PyObject *scribus_savepageeps(PyObject*
 		PyErr_SetString(ScribusException, message.toLocal8Bit().constData());
 		return nullptr;
 	}
-// 	Py_INCREF(Py_True); // return True not None for backward compat
-// 	return Py_True;
-//	Py_RETURN_TRUE;
+
 	return PyBool_FromLong(static_cast<long>(true));
 }
 
@@ -89,14 +87,13 @@ PyObject *scribus_deletepage(PyObject* /
 	if (!checkHaveDocument())
 		return nullptr;
 	e--;
-	if ((e < 0) || (e > static_cast<int>(ScCore->primaryMainWindow()->doc->Pages->count())-1))
+	if ((e < 0) || (e > ScCore->primaryMainWindow()->doc->Pages->count() - 1))
 	{
 		PyErr_SetString(PyExc_IndexError, QObject::tr("Page number out of range.","python error").toLocal8Bit().constData());
 		return nullptr;
 	}
 	ScCore->primaryMainWindow()->deletePage2(e);
-// 	Py_INCREF(Py_None);
-// 	return Py_None;
+
 	Py_RETURN_NONE;
 }
 
@@ -108,14 +105,13 @@ PyObject *scribus_gotopage(PyObject* /*
 	if (!checkHaveDocument())
 		return nullptr;
 	e--;
-	if ((e < 0) || (e > static_cast<int>(ScCore->primaryMainWindow()->doc->Pages->count())-1))
+	if ((e < 0) || (e > ScCore->primaryMainWindow()->doc->Pages->count() - 1))
 	{
 		PyErr_SetString(PyExc_IndexError, QObject::tr("Page number out of range.","python error").toLocal8Bit().constData());
 		return nullptr;
 	}
 	ScCore->primaryMainWindow()->view->GotoPage(e);
-// 	Py_INCREF(Py_None);
-// 	return Py_None;
+
 	Py_RETURN_NONE;
 }
 
@@ -130,7 +126,7 @@ PyObject *scribus_newpage(PyObject* /* s
 		return nullptr;
 
 	ScribusMainWindow* mainWin = ScCore->primaryMainWindow();
-	ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
+	const ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
 
 	int loc = (e > -1) ? e : currentDoc->Pages->count();
 	if (currentDoc->pageSets()[currentDoc->pagePositioning()].Columns != 1)
@@ -161,15 +157,14 @@ PyObject *scribus_newpage(PyObject* /* s
 	else
 	{
 		e--;
-		if ((e < 0) || (e > static_cast<int>(loc - 1)))
+		if ((e < 0) || (e > loc - 1))
 		{
 			PyErr_SetString(PyExc_IndexError, QObject::tr("Page number out of range.","python error").toLocal8Bit().constData());
 			return nullptr;
 		}
 		mainWin->slotNewPageP(e, qName);
 	}
-// 	Py_INCREF(Py_None);
- //	return Py_None;
+
 	Py_RETURN_NONE;
 }
 
@@ -184,7 +179,7 @@ PyObject *scribus_getpagesize(PyObject*
 {
 	if (!checkHaveDocument())
 		return nullptr;
-	ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
+	const ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
 
 	PyObject *t;
 	t = Py_BuildValue(
@@ -202,10 +197,10 @@ PyObject *scribus_getpagensize(PyObject*
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
+	const ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
 
 	e--;
-	if ((e < 0) || (e > static_cast<int>(currentDoc->Pages->count())-1))
+	if ((e < 0) || (e > currentDoc->Pages->count() - 1))
 	{
 		PyErr_SetString(PyExc_IndexError, QObject::tr("Page number out of range.","python error").toLocal8Bit().constData());
 		return nullptr;
@@ -226,10 +221,10 @@ PyObject *scribus_getpagenmargins(PyObje
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
+	const ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
 
 	e--;
-	if ((e < 0) || (e > static_cast<int>(currentDoc->Pages->count())-1))
+	if ((e < 0) || (e > currentDoc->Pages->count() - 1))
 	{
 		PyErr_SetString(PyExc_IndexError, QObject::tr("Page number out of range.","python error").toLocal8Bit().constData());
 		return nullptr;
@@ -246,7 +241,7 @@ PyObject *scribus_getpageitems(PyObject*
 {
 	if (!checkHaveDocument())
 		return nullptr;
-	ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
+	const ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
 
 	if (currentDoc->Items->count() == 0)
 		return Py_BuildValue("[]");
@@ -284,11 +279,10 @@ PyObject *scribus_getHguides(PyObject* /
 	int n = g.count();//ScCore->primaryMainWindow()->doc->currentPage->YGuides.count();
 	if (n == 0)
 		return Py_BuildValue("[]");
-	int i;
 	double tmp;
 	PyObject *l, *guide;
 	l = PyList_New(0);
-	for (i=0; i<n; i++)
+	for (int i = 0; i < n; i++)
 	{
 		tmp = g[i];
 		guide = Py_BuildValue("d", PointToValue(tmp));
@@ -311,11 +305,10 @@ PyObject *scribus_setHguides(PyObject* /
 		PyErr_SetString(PyExc_TypeError, QObject::tr("argument is not list: must be list of float values.","python error").toLocal8Bit().constData());
 		return nullptr;
 	}
-	int i, n;
-	n = PyList_Size(l);
+	Py_ssize_t n = PyList_Size(l);
 	double guide;
 	currentDoc->currentPage()->guides.clearHorizontals(GuideManagerCore::Standard);
-	for (i=0; i<n; i++)
+	for (Py_ssize_t i = 0; i < n; i++)
 	{
 		if (!PyArg_Parse(PyList_GetItem(l, i), "d", &guide))
 		{
@@ -336,11 +329,10 @@ PyObject *scribus_getVguides(PyObject* /
 	int n = g.count();//ScCore->primaryMainWindow()->doc->currentPage->XGuides.count();
 	if (n == 0)
 		return Py_BuildValue("[]");
-	int i;
 	double tmp;
 	PyObject *l, *guide;
 	l = PyList_New(0);
-	for (i=0; i<n; i++)
+	for (int i = 0; i < n; i++)
 	{
 		tmp = g[i];
 		guide = Py_BuildValue("d", PointToValue(tmp));
@@ -363,11 +355,10 @@ PyObject *scribus_setVguides(PyObject* /
 		PyErr_SetString(PyExc_TypeError, QObject::tr("argument is not list: must be list of float values.","python error").toLocal8Bit().constData());
 		return nullptr;
 	}
-	int i, n;
-	n = PyList_Size(l);
+	Py_ssize_t n = PyList_Size(l);
 	double guide;
 	currentDoc->currentPage()->guides.clearVerticals(GuideManagerCore::Standard);
-	for (i=0; i<n; i++)
+	for (Py_ssize_t i = 0; i < n; i++)
 	{
 		if (!PyArg_Parse(PyList_GetItem(l, i), "d", &guide))
 		{
@@ -575,9 +566,9 @@ PyObject *scribus_getpagemargins(PyObjec
 // This function is used by scribus_importpage() to add new pages
 void import_addpages(int total, int pos)
 {
-	ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
+	const ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
 
-	for (int i=0; i<total; i++)
+	for (int i = 0; i < total; i++)
 	{
 		int locreal = pos + i;
 		int loc = pos + i + 1;
@@ -632,12 +623,12 @@ PyObject *scribus_importpage(PyObject* /
 		PyErr_SetString(PyExc_TypeError, QObject::tr("second argument is not tuple: must be tuple of integer values.","python error").toLocal8Bit().constData());
 		return nullptr;
 	}
-
 	Py_INCREF(pages);
+
 	std::vector<int> pageNs;
-	int i, n, p;
-	n = PyTuple_Size(pages);
-	for (i=0; i<n; i++)
+	int p;
+	Py_ssize_t n = PyTuple_Size(pages);
+	for (Py_ssize_t i = 0; i < n; i++)
 	{
 		if (!PyArg_Parse(PyTuple_GetItem(pages, i), "i", &p))
 		{
@@ -649,7 +640,7 @@ PyObject *scribus_importpage(PyObject* /
 	}
 	Py_DECREF(pages);
  
-	QString fromDoc = QString(doc);
+	QString fromDoc(doc);
 	bool createPage = (createPageI != 0);
 
 	int startPage = 0;
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/cmdsetprop.cpp scribus16x/scribus/plugins/scriptplugin/cmdsetprop.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/cmdsetprop.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/cmdsetprop.cpp	2025-01-04 10:59:06.318376762 +0100
@@ -442,8 +442,8 @@ PyObject *scribus_setobjectattributes(Py
 	}
 
 	ObjAttrVector attributes;
-	int n = PyList_Size(attr);
-	for (int i = 0; i < n; ++i)
+	Py_ssize_t n = PyList_Size(attr);
+	for (Py_ssize_t i = 0; i < n; ++i)
 	{
 		PyObject *tmp = PyList_GetItem(attr, i);
 		if (!PyDict_Check(tmp))
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/cmdstyle.cpp scribus16x/scribus/plugins/scriptplugin/cmdstyle.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/cmdstyle.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/cmdstyle.cpp	2025-01-04 10:59:06.318376762 +0100
@@ -115,11 +115,11 @@ PyObject *scribus_createparagraphstyle(P
 
 	if (tabDefinitions != nullptr)
 	{
-		int n = PyList_Size(tabDefinitions);
-		for (int i = 0; i < n; i++)
+		Py_ssize_t n = PyList_Size(tabDefinitions);
+		for (Py_ssize_t i = 0; i < n; i++)
 		{
 			PyObject* tabDefinition = PyList_GetItem(tabDefinitions, i);
-			int size = PyTuple_Check(tabDefinition) ? PyTuple_Size(tabDefinition) : 1;
+			Py_ssize_t size = PyTuple_Check(tabDefinition) ? PyTuple_Size(tabDefinition) : 1;
 			PyObject* tabPositionDefinition = PyTuple_Check(tabDefinition) ? PyTuple_GetItem(tabDefinition, 0) : tabDefinition;
 
 			float tabPosition = 0.0;
@@ -192,7 +192,7 @@ PyObject *scribus_createcharstyle(PyObje
 	if (!checkHaveDocument())
 		return nullptr;
 
-	const double dbl_min = -std::numeric_limits<double>::max();
+	constexpr double dbl_min = -std::numeric_limits<double>::max();
 
 	ScribusDoc* currentDoc = ScCore->primaryMainWindow()->doc;
 	const StyleSet<CharStyle>& charStyles = ScCore->primaryMainWindow()->doc->charStyles();
@@ -227,7 +227,7 @@ PyObject *scribus_createcharstyle(PyObje
 		return nullptr;
 	}
 
-	QString realFont = QString(font.c_str());
+	QString realFont(font.c_str());
 	if (!realFont.isEmpty())
 	{
 		if (!currentDoc->AllFonts->contains(realFont))
@@ -238,8 +238,8 @@ PyObject *scribus_createcharstyle(PyObje
 	}
 
 	const ColorList& docColors = currentDoc->PageColors;
-	QString qFillColor = QString(fillColor.c_str());
-	QString qStrokeColor = QString(strokeColor.defaulted("Black"));
+	QString qFillColor(fillColor.c_str());
+	QString qStrokeColor(strokeColor.defaulted("Black"));
 	if (!qFillColor.isEmpty())
 	{
 		if ((qFillColor != CommonStrings::None) && (!docColors.contains(qFillColor)))
@@ -263,7 +263,7 @@ PyObject *scribus_createcharstyle(PyObje
 		strokeShade = qMax(0.0, qMin(strokeShade, 1.0));
 	QStringList featuresList = QString(features.defaulted("inherit")).split(',', Qt::SkipEmptyParts);
 	QString qFontFeatures = QString::fromUtf8(fontFeatures.c_str());
-	QString qLanguage = QString(language.c_str());
+	QString qLanguage(language.c_str());
 
 	CharStyle tmpCharStyle;
 	tmpCharStyle.setName(name.c_str());
@@ -340,7 +340,7 @@ PyObject *scribus_createcustomlinestyle(
 	MultiLine ml;
 	const ColorList& docColors = currentDoc->PageColors;
 
-	for (int i = 0; i < PyList_Size(obj); i++)
+	for (Py_ssize_t i = 0; i < PyList_Size(obj); i++)
 	{
 		PyObject *line = PyList_GetItem(obj, i);
 		if (!PyDict_Check(line))
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/cmdtable.cpp scribus16x/scribus/plugins/scriptplugin/cmdtable.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/cmdtable.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/cmdtable.cpp	2025-01-04 10:59:06.318376762 +0100
@@ -23,7 +23,7 @@ PyObject *scribus_gettablerows(PyObject*
 	if (i == nullptr)
 		return nullptr;
 
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot get table row count of non-table item.","python error").toLocal8Bit().constData());
@@ -43,7 +43,7 @@ PyObject *scribus_gettablecolumns(PyObje
 	if (i == nullptr)
 		return nullptr;
 
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot get table column count of non-table item.","python error").toLocal8Bit().constData());
@@ -130,13 +130,13 @@ PyObject *scribus_gettablerowheight(PyOb
 	PageItem *i = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (i == nullptr)
 		return nullptr;
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot get row height from non-table item.","python error").toLocal8Bit().constData());
 		return nullptr;
 	}
-	return PyFloat_FromDouble(static_cast<double>(table->rowHeight(row)));
+	return PyFloat_FromDouble(table->rowHeight(row));
 }
 
 PyObject *scribus_resizetablerow(PyObject* /* self */, PyObject* args)
@@ -249,13 +249,13 @@ PyObject *scribus_gettablecolumnwidth(Py
 	PageItem *i = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (i == nullptr)
 		return nullptr;
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot get column width from non-table item.","python error").toLocal8Bit().constData());
 		return nullptr;
 	}
-	return PyFloat_FromDouble(static_cast<double>(table->columnWidth(column)));
+	return PyFloat_FromDouble(table->columnWidth(column));
 }
 
 PyObject *scribus_resizetablecolumn(PyObject* /* self */, PyObject* args)
@@ -333,7 +333,7 @@ PyObject *scribus_gettablestyle(PyObject
 	PageItem *i = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (i == nullptr)
 		return nullptr;
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot get table style on a non-table item.","python error").toLocal8Bit().constData());
@@ -373,7 +373,7 @@ PyObject *scribus_gettablefillcolor(PyOb
 	PageItem *i = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (i == nullptr)
 		return nullptr;
-	PageItem_Table *table = i->asTable();
+	const PageItem_Table *table = i->asTable();
 	if (!table)
 	{
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot get table fill color on a non-table item.","python error").toLocal8Bit().constData());
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/cmdtext.cpp scribus16x/scribus/plugins/scriptplugin/cmdtext.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/cmdtext.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/cmdtext.cpp	2025-01-04 10:59:06.318376762 +0100
@@ -56,7 +56,7 @@ PyObject *scribus_getfontsize(PyObject*
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	if (!(item->isTextFrame()) && !(item->isPathText()))
@@ -68,10 +68,10 @@ PyObject *scribus_getfontsize(PyObject*
 	{
 		for (int i = 0; i < item->itemText.length(); i++)
 			if (item->itemText.selected(i))
-				return PyFloat_FromDouble(static_cast<double>(item->itemText.charStyle(i).fontSize() / 10.0));
+				return PyFloat_FromDouble(item->itemText.charStyle(i).fontSize() / 10.0);
 		return nullptr;
 	}
-	return PyFloat_FromDouble(static_cast<double>(item->currentCharStyle().fontSize() / 10.0));
+	return PyFloat_FromDouble(item->currentCharStyle().fontSize() / 10.0);
 }
 
 PyObject *scribus_getfont(PyObject* /* self */, PyObject* args)
@@ -81,7 +81,7 @@ PyObject *scribus_getfont(PyObject* /* s
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	if (!(item->isTextFrame()) && !(item->isPathText()))
@@ -106,7 +106,7 @@ PyObject *scribus_gettextcolor(PyObject*
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
     if (!(item->isTextFrame()) && !(item->isPathText()))
@@ -133,7 +133,7 @@ PyObject *scribus_gettextshade(PyObject*
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	if (!(item->isTextFrame()) && !(item->isPathText()))
@@ -160,7 +160,7 @@ PyObject *scribus_gettextlength(PyObject
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	if (!(item->isTextFrame()) && !(item->isPathText()))
@@ -178,7 +178,7 @@ PyObject *scribus_gettextlines(PyObject*
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	if (!(item->isTextFrame()) && !(item->isPathText()))
@@ -196,7 +196,7 @@ PyObject *scribus_gettextverticalalignme
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	if (!item->isTextFrame())
@@ -214,7 +214,7 @@ PyObject *scribus_getcolumns(PyObject* /
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	if (!item->isTextFrame())
@@ -232,7 +232,7 @@ PyObject *scribus_getcolumngap(PyObject*
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	if (!item->isTextFrame())
@@ -240,7 +240,7 @@ PyObject *scribus_getcolumngap(PyObject*
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot get column gap of non-text frame.", "python error").toLocal8Bit().constData());
 		return nullptr;
 	}
-	return PyFloat_FromDouble(PointToValue(static_cast<double>(item->m_columnGap)));
+	return PyFloat_FromDouble(PointToValue(item->m_columnGap));
 }
 
 PyObject *scribus_getfontfeatures(PyObject* /* self */, PyObject* args)
@@ -250,7 +250,7 @@ PyObject *scribus_getfontfeatures(PyObje
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	if (!(item->isTextFrame()) && !(item->isPathText()))
@@ -357,7 +357,7 @@ PyObject *scribus_getfirstlineoffset(PyO
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	if (!item->isTextFrame())
@@ -375,7 +375,7 @@ PyObject *scribus_getlinespacing(PyObjec
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	if (!item->isTextFrame())
@@ -383,7 +383,7 @@ PyObject *scribus_getlinespacing(PyObjec
 		PyErr_SetString(WrongFrameTypeError, QObject::tr("Cannot get line space of non-text frame.","python error").toLocal8Bit().constData());
 		return nullptr;
 	}
-	return PyFloat_FromDouble(static_cast<double>(item->currentStyle().lineSpacing()));
+	return PyFloat_FromDouble(item->currentStyle().lineSpacing());
 }
 
 PyObject *scribus_getlinespacingmode(PyObject* /* self */, PyObject* args)
@@ -393,7 +393,7 @@ PyObject *scribus_getlinespacingmode(PyO
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	if (!item->isTextFrame())
@@ -411,7 +411,7 @@ PyObject *scribus_gettextdistances(PyObj
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	if (!item->isTextFrame())
@@ -433,7 +433,7 @@ PyObject *scribus_getframetext(PyObject*
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	if (!(item->isTextFrame()) && !(item->isPathText()))
@@ -467,7 +467,7 @@ PyObject *scribus_getalltext(PyObject* /
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	if (!(item->isTextFrame()) && !(item->isPathText()))
@@ -543,7 +543,7 @@ PyObject *scribus_inserttext(PyObject* /
 	textData.replace("\r\n", SpecialChars::PARSEP);
 	textData.replace(QChar('\n') , SpecialChars::PARSEP);
 	text.free();
-	if ((pos < -1) || (pos > static_cast<int>(item->itemText.length())))
+	if ((pos < -1) || (pos > item->itemText.length()))
 	{
 		PyErr_SetString(PyExc_IndexError, QObject::tr("Insert index out of bounds.","python error").toLocal8Bit().constData());
 		return nullptr;
@@ -1081,7 +1081,7 @@ PyObject *scribus_selecttext(PyObject* /
 			selcount = 0;
 	}
 	// cr 2005-01-18 fixed off-by-one with end bound that made selecting the last char impossible
-	if ((start < 0) || ((start + selcount) > static_cast<int>(item->itemText.length())))
+	if ((start < 0) || ((start + selcount) > item->itemText.length()))
 	{
 		PyErr_SetString(PyExc_IndexError, QObject::tr("Selection index out of bounds", "python error").toLocal8Bit().constData());
 		return nullptr;
@@ -1117,7 +1117,7 @@ PyObject *scribus_getselectedtextrange(P
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	if (!item->isTextFrame())
@@ -1135,7 +1135,7 @@ PyObject *scribus_getframeselectedtextra
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	if (!item->isTextFrame())
@@ -1567,7 +1567,7 @@ PyObject *scribus_ispdfbookmark(PyObject
 		return nullptr;
 	if (!checkHaveDocument())
 		return nullptr;
-	PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
+	const PageItem *item = GetUniqueItem(QString::fromUtf8(name.c_str()));
 	if (item == nullptr)
 		return nullptr;
 	if (!item->isTextFrame())
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/guiapp.cpp scribus16x/scribus/plugins/scriptplugin/guiapp.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/guiapp.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/guiapp.cpp	2025-01-04 10:59:06.318376762 +0100
@@ -27,7 +27,7 @@ PyObject *scribus_statusmessage(PyObject
 PyObject *scribus_progressreset(PyObject* /* self */)
 {
 	ScCore->primaryMainWindow()->mainWindowProgressBar->reset();
-	qApp->processEvents();
+	QApplication::processEvents();
 	Py_RETURN_NONE;
 }
 
@@ -38,7 +38,7 @@ PyObject *scribus_progresssettotalsteps(
 		return nullptr;
 	ScCore->primaryMainWindow()->mainWindowProgressBar->setMaximum(steps);
 	ScCore->primaryMainWindow()->mainWindowProgressBar->setValue(0);
-	qApp->processEvents();
+	QApplication::processEvents();
 	Py_RETURN_NONE;
 }
 
@@ -53,7 +53,7 @@ PyObject *scribus_progresssetprogress(Py
 		return nullptr;
 	}
 	ScCore->primaryMainWindow()->mainWindowProgressBar->setValue(position);
-	qApp->processEvents();
+	QApplication::processEvents();
 	Py_RETURN_NONE;
 }
 
@@ -65,9 +65,9 @@ PyObject *scribus_setcursor(PyObject* /*
 	if (!PyArg_ParseTuple(args, "es", "ascii", aCursor.ptr()))
 		return nullptr;
 	if (strcmp(aCursor.c_str(), "wait") == 0)
-		qApp->changeOverrideCursor(Qt::WaitCursor);
+		QApplication::changeOverrideCursor(Qt::WaitCursor);
 //	else
-//		qApp->restoreOverrideCursor();
+//		QApplication::restoreOverrideCursor();
 	Py_RETURN_NONE;
 }
 
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/objimageexport.cpp scribus16x/scribus/plugins/scriptplugin/objimageexport.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/objimageexport.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/objimageexport.cpp	2025-01-04 10:59:06.320376720 +0100
@@ -18,7 +18,7 @@ for which a new license (GPL+exception)
 #include "scribusdoc.h"
 #include "scribusview.h"
 
-typedef struct
+struct ImageExport
 {
 	PyObject_HEAD
 	PyObject *name; // string - filename
@@ -28,7 +28,7 @@ typedef struct
 	int scale; // how is bitmap scaled 100 = 100%
 	int quality; // quality/compression <1; 100>
 	int transparentBkgnd; // background transparency
-} ImageExport;
+};
 
 static void ImageExport_dealloc(ImageExport* self)
 {
@@ -63,11 +63,11 @@ static int ImageExport_init(ImageExport
 }
 
 static PyMemberDef ImageExport_members[] = {
-	{const_cast<char*>("dpi"), T_INT, offsetof(ImageExport, dpi), 0, imgexp_dpi__doc__},
-	{const_cast<char*>("scale"), T_INT, offsetof(ImageExport, scale), 0, imgexp_scale__doc__},
-	{const_cast<char*>("quality"), T_INT, offsetof(ImageExport, quality), 0, imgexp_quality__doc__},
-	{const_cast<char*>("transparentBkgnd"), T_INT, offsetof(ImageExport, transparentBkgnd), 0, imgexp_transparentBkgnd__doc__},
-	{nullptr, 0, 0, 0, nullptr} // sentinel
+	{ "dpi", T_INT, offsetof(ImageExport, dpi), 0, imgexp_dpi__doc__ },
+	{ "scale", T_INT, offsetof(ImageExport, scale), 0, imgexp_scale__doc__ },
+	{ "quality", T_INT, offsetof(ImageExport, quality), 0, imgexp_quality__doc__ },
+	{ "transparentBkgnd", T_INT, offsetof(ImageExport, transparentBkgnd), 0, imgexp_transparentBkgnd__doc__ },
+	{ nullptr, 0, 0, 0, nullptr } // sentinel
 };
 
 static PyObject *ImageExport_getName(ImageExport *self, void * /*closure*/)
@@ -136,41 +136,40 @@ static int ImageExport_setAllTypes(Image
 }
 
 static PyGetSetDef ImageExport_getseters [] = {
-	{const_cast<char*>("name"), (getter)ImageExport_getName, (setter)ImageExport_setName, imgexp_filename__doc__, nullptr},
-	{const_cast<char*>("type"), (getter)ImageExport_getType, (setter)ImageExport_setType, imgexp_type__doc__, nullptr},
-	{const_cast<char*>("allTypes"), (getter)ImageExport_getAllTypes, (setter)ImageExport_setAllTypes, imgexp_alltypes__doc__, nullptr},
-	{nullptr, nullptr, nullptr, nullptr, nullptr}  // sentinel
+	{ "name", (getter) ImageExport_getName, (setter) ImageExport_setName, imgexp_filename__doc__, nullptr },
+	{ "type", (getter) ImageExport_getType, (setter) ImageExport_setType, imgexp_type__doc__, nullptr },
+	{ "allTypes", (getter) ImageExport_getAllTypes, (setter) ImageExport_setAllTypes, imgexp_alltypes__doc__, nullptr },
+	{ nullptr, nullptr, nullptr, nullptr, nullptr }  // sentinel
 };
 
 static PyObject *ImageExport_save(ImageExport *self)
 {
 	if (!checkHaveDocument())
 		return nullptr;
+
 	ScribusDoc*  doc = ScCore->primaryMainWindow()->doc;
 	ScribusView*view = ScCore->primaryMainWindow()->view;
+	ScPage* page = doc->currentPage();
 
 	/* a little magic here - I need to compute the "maxGr" value...
 	* We need to know the right size of the page for landscape,
 	* portrait and user defined sizes.
 	*/
-	double pixmapSize = (doc->pageHeight() > doc->pageWidth()) ? doc->pageHeight() : doc->pageWidth();
+	double pixmapSize = (page->height() > page->width()) ? page->height() : page->width();
 	PageToPixmapFlags flags = Pixmap_DrawBackground;
 	if (self->transparentBkgnd)
 		flags &= ~Pixmap_DrawBackground;
-	QImage im = view->PageToPixmap(doc->currentPage()->pageNr(), qRound(pixmapSize * self->scale * (self->dpi / 72.0) / 100.0), flags);
+	QImage im = view->PageToPixmap(page->pageNr(), qRound(pixmapSize * self->scale * (self->dpi / 72.0) / 100.0), flags);
 	int dpi = qRound(100.0 / 2.54 * self->dpi);
 	im.setDotsPerMeterY(dpi);
 	im.setDotsPerMeterX(dpi);
 
 	QString imgFileName = PyUnicode_asQString(self->name);
-	if (!im.save(imgFileName, PyUnicode_AsUTF8(self->type)))
+	if (!im.save(imgFileName, PyUnicode_AsUTF8(self->type), self->quality))
 	{
 		PyErr_SetString(ScribusException, QObject::tr("Failed to export image", "python error").toLocal8Bit().constData());
 		return nullptr;
 	}
-// 	Py_INCREF(Py_True); // return True not None for backward compat
- //	return Py_True;
-//	Py_RETURN_TRUE;
 	return PyBool_FromLong(static_cast<long>(true));
 }
 
@@ -179,46 +178,44 @@ static PyObject *ImageExport_saveAs(Imag
 	PyESString value;
 	if (!checkHaveDocument())
 		return nullptr;
-	if (!PyArg_ParseTuple(args, const_cast<char*>("es"), "utf-8", value.ptr()))
+	if (!PyArg_ParseTuple(args, "es", "utf-8", value.ptr()))
 		return nullptr;
 
 	ScribusDoc*  doc = ScCore->primaryMainWindow()->doc;
 	ScribusView*view = ScCore->primaryMainWindow()->view;
+	ScPage* page = doc->currentPage();
 
 	/* a little magic here - I need to compute the "maxGr" value...
 	* We need to know the right size of the page for landscape,
 	* portrait and user defined sizes.
 	*/
-	double pixmapSize = (doc->pageHeight() > doc->pageWidth()) ? doc->pageHeight() : doc->pageWidth();
+	double pixmapSize = (page->height() > page->width()) ? page->height() : page->width();
 	PageToPixmapFlags flags = Pixmap_DrawBackground;
 	if (self->transparentBkgnd)
 		flags &= ~Pixmap_DrawBackground;
-	QImage im = view->PageToPixmap(doc->currentPage()->pageNr(), qRound(pixmapSize * self->scale * (self->dpi / 72.0) / 100.0), flags);
+	QImage im = view->PageToPixmap(page->pageNr(), qRound(pixmapSize * self->scale * (self->dpi / 72.0) / 100.0), flags);
 	int dpi = qRound(100.0 / 2.54 * self->dpi);
 	im.setDotsPerMeterY(dpi);
 	im.setDotsPerMeterX(dpi);
 
 	QString outputFileName = QString::fromUtf8(value.c_str());
-	if (!im.save(outputFileName, PyUnicode_AsUTF8(self->type)))
+	if (!im.save(outputFileName, PyUnicode_AsUTF8(self->type), self->quality))
 	{
 		PyErr_SetString(ScribusException, QObject::tr("Failed to export image", "python error").toLocal8Bit().constData());
 		return nullptr;
 	}
-// 	Py_INCREF(Py_True); // return True not None for backward compat
- //	return Py_True;
-//	Py_RETURN_TRUE;
 	return PyBool_FromLong(static_cast<long>(true));
 }
 
 static PyMethodDef ImageExport_methods[] = {
-	{const_cast<char*>("save"), (PyCFunction)ImageExport_save, METH_NOARGS, imgexp_save__doc__},
-	{const_cast<char*>("saveAs"), (PyCFunction)ImageExport_saveAs, METH_VARARGS, imgexp_saveas__doc__},
-	{nullptr, (PyCFunction)(nullptr), 0, nullptr} // sentinel
+	{ "save", (PyCFunction) ImageExport_save, METH_NOARGS, imgexp_save__doc__ },
+	{ "saveAs", (PyCFunction) ImageExport_saveAs, METH_VARARGS, imgexp_saveas__doc__ },
+	{ nullptr, (PyCFunction)(nullptr), 0, nullptr } // sentinel
 };
 
 PyTypeObject ImageExport_Type = {
 	PyVarObject_HEAD_INIT(nullptr, 0)   // PyObject_VAR_HEAD
-	const_cast<char*>("scribus.ImageExport"), // char *tp_name; /* For printing, in format "<module>.<name>" */
+	"scribus.ImageExport", // const char *tp_name; /* For printing, in format "<module>.<name>" */
 	sizeof(ImageExport),   // int tp_basicsize, /* For allocation */
 	0,  // int tp_itemsize; /* For allocation */
 
@@ -285,7 +282,7 @@ PyTypeObject ImageExport_Type = {
 	nullptr, //	 descrgetfunc tp_descr_get;
 	nullptr, //	 descrsetfunc tp_descr_set;
 	0, //	 long tp_dictoffset;
-	(initproc)ImageExport_init, //	 initproc tp_init;
+	(initproc) ImageExport_init, //	 initproc tp_init;
 	nullptr, //	 allocfunc tp_alloc;
 	ImageExport_new, //	 newfunc tp_new;
 	nullptr, //	 freefunc tp_free; /* Low-level free-memory routine */
@@ -304,8 +301,11 @@ PyTypeObject ImageExport_Type = {
 #if PY_VERSION_HEX >= 0x03080000 && PY_VERSION_HEX < 0x03090000
 	nullptr, // deprecated tp_print
 #endif
-#if PY_VERSION_HEX >= 0x03120000
-	0, // char tp_watched
+#if PY_VERSION_HEX >= 0x030C0000 // Python 3.12
+	0, // unsigned char tp_watched
+#endif
+#if PY_VERSION_HEX >= 0x030D0000 // Python 3.13
+	0, // uint16_t tp_versions_used
 #endif
 
 #if defined(COUNT_ALLOCS) && PY_VERSION_HEX < 0x03090000
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/objpdffile.cpp scribus16x/scribus/plugins/scriptplugin/objpdffile.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/objpdffile.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/objpdffile.cpp	2025-01-04 10:59:06.318376762 +0100
@@ -43,7 +43,7 @@ static double minmaxd(double val, double
 	return val;
 }
 
-typedef struct
+struct PDFfile
 {
 	PyObject_HEAD
 	PyObject *file; // string - file to save into
@@ -113,8 +113,7 @@ typedef struct
 	int hideMenuBar;
 	int fitWindow;
 	PyObject *openAction;
-
-} PDFfile;
+};
 
 static void PDFfile_dealloc(PDFfile *self)
 {
@@ -340,7 +339,6 @@ static PyObject * PDFfile_new(PyTypeObje
 
 static int PDFfile_init(PDFfile *self, PyObject * /*args*/, PyObject * /*kwds*/)
 {
-	int i;
 	if (!checkHaveDocument())
 		return -1;
 
@@ -453,7 +451,7 @@ static int PDFfile_init(PDFfile *self, P
 		PyErr_SetString(PyExc_SystemError, "Can not initialize 'pages' attribute");
 		return -1;
 	}
-	for (i = 0; i < num; ++i)
+	for (int i = 0; i < num; ++i)
 	{
 		PyObject *tmp = PyLong_FromLong((long) i + 1L);
 		if (tmp)
@@ -529,7 +527,7 @@ static int PDFfile_init(PDFfile *self, P
 		PyErr_SetString(PyExc_SystemError, "Can not initialize 'effval' attribute");
 		return -1;
 	}
-	for (i = 0; i < num; ++i)
+	for (int i = 0; i < num; ++i)
 	{
 		PyObject *tmp;
 		PDFPresentationData t = currentDoc->Pages->at(i)->PresentVals;
@@ -731,66 +729,66 @@ static int PDFfile_init(PDFfile *self, P
 }
 
 static PyMemberDef PDFfile_members[] = {
-	{const_cast<char*>("thumbnails"), T_INT, offsetof(PDFfile, thumbnails), 0, const_cast<char*>("Generate thumbnails. Bool value.")},
-	{const_cast<char*>("cropMarks"), T_INT, offsetof(PDFfile, cropMarks), 0, const_cast<char*>("Create crop marks in the PDF indicating where the paper should be cut or trimmed after printing.")},
-	{const_cast<char*>("bleedMarks"), T_INT, offsetof(PDFfile, bleedMarks), 0, const_cast<char*>("Create marks delimiting the bleed area.")},
-	{const_cast<char*>("registrationMarks"), T_INT, offsetof(PDFfile, registrationMarks), 0, const_cast<char*>("Add registration marks to each separation.")},
-	{const_cast<char*>("colorMarks"), T_INT, offsetof(PDFfile, colorMarks), 0, const_cast<char*>("Add color calibration bars.")},
-	{const_cast<char*>("docInfoMarks"), T_INT, offsetof(PDFfile, docInfoMarks), 0, const_cast<char*>("Add document information which includes the document title and page numbers.")},
-	{const_cast<char*>("markOffset"), T_DOUBLE, offsetof(PDFfile, markOffset), 0, const_cast<char*>("Indicate the distance offset between mark and page area.")},
-	{const_cast<char*>("markLength"), T_DOUBLE, offsetof(PDFfile, markLength), 0, const_cast<char*>("Indicate the length of crop and bleed marks.")},
-	{const_cast<char*>("compress"), T_INT, offsetof(PDFfile, compress), 0, const_cast<char*>("Compression switch. Bool value.")},
-	{const_cast<char*>("compressmtd"), T_INT, offsetof(PDFfile, compressmtd), 0, const_cast<char*>("Compression method.\n\t0 - Automatic\n\t1 - JPEG\n\t2 - zip\n\t3 - None.")},
-	{const_cast<char*>("quality"), T_INT, offsetof(PDFfile, quality), 0, const_cast<char*>("Image quality\n\t0 - Maximum\n\t1 - High\n\t2 - Medium\n\t3 - Low\n\t4 - Minimum")},
-	{const_cast<char*>("bookmarks"), T_INT, offsetof(PDFfile, bookmarks), 0, const_cast<char*>("Embed the bookmarks you created in your document.\nThese are useful for navigating long PDF documents.\nBool value")},
-	{const_cast<char*>("binding"), T_INT, offsetof(PDFfile, binding), 0, const_cast<char*>("Choose binding.\n\t0 - Left binding\n\t1 - Right binding")},
-	{const_cast<char*>("presentation"), T_INT, offsetof(PDFfile, presentation), 0, const_cast<char*>("Enable Presentation Effects.Bool value")},
-	{const_cast<char*>("article"), T_INT, offsetof(PDFfile, article), 0, const_cast<char*>("Save Linked Text Frames as PDF Articles\n\tBool value")},
-	{const_cast<char*>("encrypt"), T_INT, offsetof(PDFfile, encrypt), 0, const_cast<char*>("Use Encription. Bool value")},
-	{const_cast<char*>("uselpi"), T_INT, offsetof(PDFfile, uselpi), 0, const_cast<char*>("Use Custom Rendering Settings. Bool value")},
-	{const_cast<char*>("usespot"), T_INT, offsetof(PDFfile, usespot), 0, const_cast<char*>("Use Spot Colors. Bool value")},
-	{const_cast<char*>("domulti"), T_INT, offsetof(PDFfile, domulti), 0, const_cast<char*>("Produce a PDF File for every Page. Bool value")},
-	{const_cast<char*>("allowPrinting"), T_INT, offsetof(PDFfile, allowPrinting), 0, const_cast<char*>("Allow Printing the Document. Bool value")},
-	{const_cast<char*>("allowChange"), T_INT, offsetof(PDFfile, allowChange), 0, const_cast<char*>("Allow Changing the Document. Bool value")},
-	{const_cast<char*>("allowCopy"), T_INT, offsetof(PDFfile, allowCopy), 0, const_cast<char*>("Allow Copying Text and Graphics. Bool value")},
-	{const_cast<char*>("allowAnnots"), T_INT, offsetof(PDFfile, allowAnnots), 0, const_cast<char*>("Allow Adding Annotations and Fields. Bool value")},
-	{const_cast<char*>("version"), T_INT, offsetof(PDFfile, version), 0, const_cast<char*>("Choose PDF version to use:\n\t10 = PDF/X4\n\t11 = PDF/X1a\n\t12 = PDF/X-3\n\t13 = PDF 1.3 (Acrobat 4)\n\t14 = PDF 1.4 (Acrobat 5)\n\t15 = PDF 1.5 (Acrobat 6)")},
-	{const_cast<char*>("outdst"), T_INT, offsetof(PDFfile, outdst), 0, const_cast<char*>("Output destination.\n\t0 - screen\n\t1 - printer")},
-	{const_cast<char*>("profiles"), T_INT, offsetof(PDFfile, profiles), 0, const_cast<char*>("Embed a color profile for solid colors. Bool value.")},
-	{const_cast<char*>("profilei"), T_INT, offsetof(PDFfile, profilei), 0, const_cast<char*>("Embed a color profile for images. Bool value.")},
-	{const_cast<char*>("intents"), T_INT, offsetof(PDFfile, intents), 0, const_cast<char*>("Rendering intent for solid colors\n\t0 - Perceptual\n\t1 - Relative Colorimetric\n\t2 - Saturation\n\t3 - Absolute Colorimetric")},
-	{const_cast<char*>("intenti"), T_INT, offsetof(PDFfile, intenti), 0, const_cast<char*>("Rendering intent for images\n\t0 - Perceptual\n\t1 - Relative Colorimetric\n\t2 - Saturation\n\t3 - Absolute Colorimetric")},
-	{const_cast<char*>("noembicc"), T_INT, offsetof(PDFfile, noembicc), 0, const_cast<char*>("Don't use embedded ICC profiles. Bool value")},
-	{const_cast<char*>("bleedt"), T_DOUBLE, offsetof(PDFfile, bleedt), 0, const_cast<char*>("Bleed Top\n""Distance for bleed from the top of the physical page")},
-	{const_cast<char*>("bleedl"), T_DOUBLE, offsetof(PDFfile, bleedl), 0, const_cast<char*>("Bleed Left\n""Distance for bleed from the left of the physical page")},
-	{const_cast<char*>("bleedr"), T_DOUBLE, offsetof(PDFfile, bleedr), 0, const_cast<char*>("Bleed Right\n""Distance for bleed from the right of the physical page")},
-	{const_cast<char*>("bleedb"), T_DOUBLE, offsetof(PDFfile, bleedb), 0, const_cast<char*>("Bleed Bottom\n""Distance for bleed from the bottom of the physical page")},
-	{const_cast<char*>("useDocBleeds"), T_INT, offsetof(PDFfile, useDocBleeds), 0, const_cast<char*>("Use the existing bleed settings from the document preferences. Bool value")},
-	{const_cast<char*>("useLayers"), T_INT, offsetof(PDFfile, useLayers), 0, const_cast<char*>("Layers in your document are exported to the PDF. Only available if PDF 1.5 is chosen.")},
-	{const_cast<char*>("embedPDF"), T_INT, offsetof(PDFfile, embedPDF), 0, const_cast<char*>("Export EPS and PDFs in image frames as embedded PDFs. This does *not* yet take care of colorspaces, so you should know what you are doing before setting this to 'true'.")},
-	{const_cast<char*>("mirrorH"), T_INT, offsetof(PDFfile, mirrorH), 0, const_cast<char*>("Mirror Page(s) horizontally")},
-	{const_cast<char*>("mirrorV"), T_INT, offsetof(PDFfile, mirrorV), 0, const_cast<char*>("Mirror Page(s) vertically")},
-	{const_cast<char*>("doClip"), T_INT, offsetof(PDFfile, doClip), 0, const_cast<char*>("Do not show objects outside the margins in the exported file")},
-	{const_cast<char*>("isGrayscale"), T_INT, offsetof(PDFfile, isGrayscale), 0, const_cast<char*>("Export PDF in grayscale")},
-	{const_cast<char*>("pageLayout"), T_INT, offsetof(PDFfile, pageLayout), 0, const_cast<char*>("Document layout in PDF viewer:\n"
+	{ "thumbnails", T_INT, offsetof(PDFfile, thumbnails), 0, "Generate thumbnails. Bool value." },
+	{ "cropMarks", T_INT, offsetof(PDFfile, cropMarks), 0, "Create crop marks in the PDF indicating where the paper should be cut or trimmed after printing." },
+	{ "bleedMarks", T_INT, offsetof(PDFfile, bleedMarks), 0, "Create marks delimiting the bleed area." },
+	{ "registrationMarks", T_INT, offsetof(PDFfile, registrationMarks), 0, "Add registration marks to each separation." },
+	{ "colorMarks", T_INT, offsetof(PDFfile, colorMarks), 0, "Add color calibration bars." },
+	{ "docInfoMarks", T_INT, offsetof(PDFfile, docInfoMarks), 0, "Add document information which includes the document title and page numbers." },
+	{ "markOffset", T_DOUBLE, offsetof(PDFfile, markOffset), 0, "Indicate the distance offset between mark and page area." },
+	{ "markLength", T_DOUBLE, offsetof(PDFfile, markLength), 0, "Indicate the length of crop and bleed marks." },
+	{ "compress", T_INT, offsetof(PDFfile, compress), 0, "Compression switch. Bool value." },
+	{ "compressmtd", T_INT, offsetof(PDFfile, compressmtd), 0, "Compression method.\n\t0 - Automatic\n\t1 - JPEG\n\t2 - zip\n\t3 - None." },
+	{ "quality", T_INT, offsetof(PDFfile, quality), 0, "Image quality\n\t0 - Maximum\n\t1 - High\n\t2 - Medium\n\t3 - Low\n\t4 - Minimum" },
+	{ "bookmarks", T_INT, offsetof(PDFfile, bookmarks), 0, "Embed the bookmarks you created in your document.\nThese are useful for navigating long PDF documents.\nBool value" },
+	{ "binding", T_INT, offsetof(PDFfile, binding), 0, "Choose binding.\n\t0 - Left binding\n\t1 - Right binding" },
+	{ "presentation", T_INT, offsetof(PDFfile, presentation), 0, "Enable Presentation Effects.Bool value" },
+	{ "article", T_INT, offsetof(PDFfile, article), 0, "Save Linked Text Frames as PDF Articles\n\tBool value" },
+	{ "encrypt", T_INT, offsetof(PDFfile, encrypt), 0, "Use Encription. Bool value" },
+	{ "uselpi", T_INT, offsetof(PDFfile, uselpi), 0, "Use Custom Rendering Settings. Bool value" },
+	{ "usespot", T_INT, offsetof(PDFfile, usespot), 0, "Use Spot Colors. Bool value" },
+	{ "domulti", T_INT, offsetof(PDFfile, domulti), 0, "Produce a PDF File for every Page. Bool value" },
+	{ "allowPrinting", T_INT, offsetof(PDFfile, allowPrinting), 0, "Allow Printing the Document. Bool value" },
+	{ "allowChange", T_INT, offsetof(PDFfile, allowChange), 0, "Allow Changing the Document. Bool value" },
+	{ "allowCopy", T_INT, offsetof(PDFfile, allowCopy), 0, "Allow Copying Text and Graphics. Bool value" },
+	{ "allowAnnots", T_INT, offsetof(PDFfile, allowAnnots), 0, "Allow Adding Annotations and Fields. Bool value" },
+	{ "version", T_INT, offsetof(PDFfile, version), 0, "Choose PDF version to use:\n\t10 = PDF/X4\n\t11 = PDF/X1a\n\t12 = PDF/X-3\n\t13 = PDF 1.3 (Acrobat 4)\n\t14 = PDF 1.4 (Acrobat 5)\n\t15 = PDF 1.5 (Acrobat 6)" },
+	{ "outdst", T_INT, offsetof(PDFfile, outdst), 0, "Output destination.\n\t0 - screen\n\t1 - printer" },
+	{ "profiles", T_INT, offsetof(PDFfile, profiles), 0, "Embed a color profile for solid colors. Bool value." },
+	{ "profilei", T_INT, offsetof(PDFfile, profilei), 0, "Embed a color profile for images. Bool value." },
+	{ "intents", T_INT, offsetof(PDFfile, intents), 0, "Rendering intent for solid colors\n\t0 - Perceptual\n\t1 - Relative Colorimetric\n\t2 - Saturation\n\t3 - Absolute Colorimetric" },
+	{ "intenti", T_INT, offsetof(PDFfile, intenti), 0, "Rendering intent for images\n\t0 - Perceptual\n\t1 - Relative Colorimetric\n\t2 - Saturation\n\t3 - Absolute Colorimetric" },
+	{ "noembicc", T_INT, offsetof(PDFfile, noembicc), 0, "Don't use embedded ICC profiles. Bool value" },
+	{ "bleedt", T_DOUBLE, offsetof(PDFfile, bleedt), 0, "Bleed Top\n""Distance for bleed from the top of the physical page" },
+	{ "bleedl", T_DOUBLE, offsetof(PDFfile, bleedl), 0, "Bleed Left\n""Distance for bleed from the left of the physical page" },
+	{ "bleedr", T_DOUBLE, offsetof(PDFfile, bleedr), 0, "Bleed Right\n""Distance for bleed from the right of the physical page" },
+	{ "bleedb", T_DOUBLE, offsetof(PDFfile, bleedb), 0, "Bleed Bottom\n""Distance for bleed from the bottom of the physical page" },
+	{ "useDocBleeds", T_INT, offsetof(PDFfile, useDocBleeds), 0, "Use the existing bleed settings from the document preferences. Bool value" },
+	{ "useLayers", T_INT, offsetof(PDFfile, useLayers), 0, "Layers in your document are exported to the PDF. Only available if PDF 1.5 is chosen." },
+	{ "embedPDF", T_INT, offsetof(PDFfile, embedPDF), 0, "Export EPS and PDFs in image frames as embedded PDFs. This does *not* yet take care of colorspaces, so you should know what you are doing before setting this to 'true'." },
+	{ "mirrorH", T_INT, offsetof(PDFfile, mirrorH), 0, "Mirror Page(s) horizontally" },
+	{ "mirrorV", T_INT, offsetof(PDFfile, mirrorV), 0, "Mirror Page(s) vertically" },
+	{ "doClip", T_INT, offsetof(PDFfile, doClip), 0, "Do not show objects outside the margins in the exported file" },
+	{ "isGrayscale", T_INT, offsetof(PDFfile, isGrayscale), 0, "Export PDF in grayscale" },
+	{ "pageLayout", T_INT, offsetof(PDFfile, pageLayout), 0, "Document layout in PDF viewer:\n"
 												     "\t0 - Show the document in single page mode\n"
 												     "\t1 - Show the document in single page mode with the pages displayed continuously end to end like a scroll\n"
 												     "\t2 - Show the document with facing pages, starting with the first page displayed on the left\n"
 												     "\t3 - Show the document with facing pages, starting with the first page displayed on the right"
-												     )},
-	{const_cast<char*>("displayBookmarks"), T_INT, offsetof(PDFfile, displayBookmarks), 0, const_cast<char*>("Display the bookmarks upon opening")},
-	{const_cast<char*>("displayThumbs"), T_INT, offsetof(PDFfile, displayThumbs), 0, const_cast<char*>("Display the page thumbnails upon opening")},
-	{const_cast<char*>("displayLayers"), T_INT, offsetof(PDFfile, displayLayers), 0, const_cast<char*>("Display the layer list upon opening. Useful only for PDF 1.5+.")},
-	{const_cast<char*>("displayFullscreen"), T_INT, offsetof(PDFfile, displayFullscreen), 0, const_cast<char*>("Display the document in full screen mode upon opening.")},
-	{const_cast<char*>("hideToolBar"), T_INT, offsetof(PDFfile, hideToolBar), 0, const_cast<char*>("Hide the viewer toolbar. The toolbar has usually selection and other editing capabilities.")},
-	{const_cast<char*>("hideMenuBar"), T_INT, offsetof(PDFfile, hideMenuBar), 0, const_cast<char*>("Hide the viewer menu bar, the PDF will display in a plain window.")},
-	{const_cast<char*>("fitWindow"), T_INT, offsetof(PDFfile, fitWindow), 0, const_cast<char*>("Fit the document page or pages to the available space in the viewer window.")},
+												     },
+	{ "displayBookmarks", T_INT, offsetof(PDFfile, displayBookmarks), 0, "Display the bookmarks upon opening" },
+	{ "displayThumbs", T_INT, offsetof(PDFfile, displayThumbs), 0, "Display the page thumbnails upon opening" },
+	{ "displayLayers", T_INT, offsetof(PDFfile, displayLayers), 0, "Display the layer list upon opening. Useful only for PDF 1.5+." },
+	{ "displayFullscreen", T_INT, offsetof(PDFfile, displayFullscreen), 0, "Display the document in full screen mode upon opening." },
+	{ "hideToolBar", T_INT, offsetof(PDFfile, hideToolBar), 0, "Hide the viewer toolbar. The toolbar has usually selection and other editing capabilities." },
+	{ "hideMenuBar", T_INT, offsetof(PDFfile, hideMenuBar), 0, "Hide the viewer menu bar, the PDF will display in a plain window." },
+	{ "fitWindow", T_INT, offsetof(PDFfile, fitWindow), 0, "Fit the document page or pages to the available space in the viewer window." },
 	/** Deprecated members */
-	{const_cast<char*>("aprint"), T_INT, offsetof(PDFfile, allowPrinting), 0, const_cast<char*>("Deprecated. Use 'allowPrinting' instead.")},
-	{const_cast<char*>("achange"), T_INT, offsetof(PDFfile, allowChange), 0, const_cast<char*>("Deprecated. Use 'allowChange' instead.")},
-	{const_cast<char*>("acopy"), T_INT, offsetof(PDFfile, allowCopy), 0, const_cast<char*>("Deprecated. Use 'allowCopy' instead.")},
-	{const_cast<char*>("aanot"), T_INT, offsetof(PDFfile, allowAnnots), 0, const_cast<char*>("Deprecated. Use 'allowAnnots' instead.")},
-	{nullptr, 0, 0, 0, nullptr} // sentinel
+	{ "aprint", T_INT, offsetof(PDFfile, allowPrinting), 0, "Deprecated. Use 'allowPrinting' instead." },
+	{ "achange", T_INT, offsetof(PDFfile, allowChange), 0, "Deprecated. Use 'allowChange' instead." },
+	{ "acopy", T_INT, offsetof(PDFfile, allowCopy), 0, "Deprecated. Use 'allowCopy' instead." },
+	{ "aanot", T_INT, offsetof(PDFfile, allowAnnots), 0, "Deprecated. Use 'allowAnnots' instead." },
+	{ nullptr, 0, 0, 0, nullptr } // sentinel
 };
 
 
@@ -868,8 +866,8 @@ static int PDFfile_setfonts(PDFfile *sel
 		PyErr_SetString(PyExc_TypeError, "The 'fonts' attribute value must be list of strings.");
 		return -1;
 	}
-	int n = PyList_Size(value);
-	for (int i = 0; i < n; ++i)
+	Py_ssize_t n = PyList_Size(value);
+	for (Py_ssize_t i = 0; i < n; ++i)
 	{
 		if (!PyUnicode_Check(PyList_GetItem(value, i)))
 		{
@@ -905,8 +903,8 @@ static int PDFfile_setSubsetList(PDFfile
 		PyErr_SetString(PyExc_TypeError, "The 'subsetList' attribute value must be list of strings.");
 		return -1;
 	}
-	int n = PyList_Size(value);
-	for (int i = 0; i < n; ++i)
+	Py_ssize_t n = PyList_Size(value);
+	for (Py_ssize_t i = 0; i < n; ++i)
 	{
 		if (!PyUnicode_Check(PyList_GetItem(value, i)))
 		{
@@ -939,8 +937,8 @@ static int PDFfile_setpages(PDFfile *sel
 		PyErr_SetString(PyExc_TypeError, "'pages' attribute value must be list of integers.");
 		return -1;
 	}
-	int len = PyList_Size(value);
-	for (int i = 0; i < len; i++)
+	Py_ssize_t len = PyList_Size(value);
+	for (Py_ssize_t i = 0; i < len; i++)
 	{
 		PyObject *tmp = PyList_GetItem(value, i);
 		// I did not check if tmp is nullptr
@@ -1042,8 +1040,8 @@ static int PDFfile_seteffval(PDFfile *se
 		PyErr_SetString(PyExc_TypeError, "'effval' must be list.");
 		return -1;
 	}
-	int n = PyList_Size(value);
-	for (int i = 0; i < n; ++i)
+	Py_ssize_t n = PyList_Size(value);
+	for (Py_ssize_t i = 0; i < n; ++i)
 	{
 		PyObject *tmp = PyList_GetItem(value, i);
 		if (!PyList_Check(tmp))
@@ -1051,7 +1049,7 @@ static int PDFfile_seteffval(PDFfile *se
 			PyErr_SetString(PyExc_TypeError, "elements of 'effval' must be list of five integers.");
 			return -1;
 		}
-		int j = PyList_Size(tmp);
+		Py_ssize_t j = PyList_Size(tmp);
 		if (j != 6)
 		{
 			PyErr_SetString(PyExc_TypeError, "elements of 'effval' must have exactly six integers.");
@@ -1091,8 +1089,8 @@ static int PDFfile_setlpival(PDFfile *se
 		return -1;
 	}
 	// Do I need Py_INCREF or Py_DECREF here?
-	int n = PyList_Size(value);
-	for (int i = 0; i < n; ++i)
+	Py_ssize_t n = PyList_Size(value);
+	for (Py_ssize_t i = 0; i < n; ++i)
 	{
 		PyObject *tmp = PyList_GetItem(value, i);
 		if (!PyList_Check(tmp))
@@ -1100,7 +1098,7 @@ static int PDFfile_setlpival(PDFfile *se
 			PyErr_SetString(PyExc_TypeError, "elements of 'lpival' must be list of five integers.");
 			return -1;
 		}
-		int j = PyList_Size(tmp);
+		Py_ssize_t j = PyList_Size(tmp);
 		if (j != 4)
 		{
 			PyErr_SetString(PyExc_TypeError, "elements of 'lpival' must have exactly four members.");
@@ -1324,7 +1322,7 @@ static int PDFfile_setopenAction(PDFfile
 	return 0;
 }
 
-static char *effval_doc = const_cast<char*>(
+static const char *effval_doc =
 "List of effection values for each saved page.\n"
 "It is a list of list of six integers. Those int have the following meaning:\n\t"
 "- Length of time the page is shown before the presentation\n\tstarts on the selected page. (1-3600)\n\t"
@@ -1332,9 +1330,9 @@ static char *effval_doc = const_cast<cha
 "- Type of the display effect\n\t\t0 - No Effect\n\t\t1 - Blinds\n\t\t2 - Box\n\t\t3 - Dissolve\n\t\t4 - Glitter\n\t\t5 - Split\n\t\t6 - Wipe\n\t"
 "- Direction of the effect of moving lines\n\tfor the split and blind effects.\n\t\t0 - Horizontal\n\t\t1 - Vertical\n\t"
 "- Starting position for the box and split effects.\n\t\t0 - Inside\n\t\t1 - Outside\n\t"
-"- Direction of the glitter or wipe effects.\n\t\t0 - Left to Right\n\t\t1 - Top to Bottom\n\t\t2 - Bottom to Top\n\t\t3 - Right to Left\n\t\t4 - Top-left to Bottom-Right");
+"- Direction of the glitter or wipe effects.\n\t\t0 - Left to Right\n\t\t1 - Top to Bottom\n\t\t2 - Bottom to Top\n\t\t3 - Right to Left\n\t\t4 - Top-left to Bottom-Right";
 
-static char *lpival_doc = const_cast<char*>(
+static const char *lpival_doc =
 "Rendering Settings for individual colors.\n\n"
 "This is a list of values for each color\n"
 "Color values have structure [siii] which stand for:\n\t"
@@ -1342,27 +1340,27 @@ static char *lpival_doc = const_cast<cha
 "i - Frequency (10 to 1000)\n\t"
 "i - Angle (-180 to 180)\n\t"
 "i - Spot Function\n\t\t0 - Simple Dot\n\t\t1 - Line\n\t\t2 - Round\n\t\t3 - Ellipse\n"
-"Be careful when supplying these values as they\nare not checked for validity.");
+"Be careful when supplying these values as they\nare not checked for validity.";
 
 static PyGetSetDef PDFfile_getseters [] = {
-	{const_cast<char*>("file"), (getter)PDFfile_getfile, (setter)PDFfile_setfile, const_cast<char*>("Name of file to save into"), nullptr},
-	{const_cast<char*>("fontEmbedding"), (getter)PDFfile_getFontEmbeddingMode, (setter)PDFfile_setFontEmbeddingMode, const_cast<char*>("Font embedding mode.\n\tValue must be one of integers: 0 (Embed), 1 (Outline), 2 (No embedding)."), nullptr},
-	{const_cast<char*>("fonts"), (getter)PDFfile_getfonts, (setter)PDFfile_setfonts, const_cast<char*>("List of fonts to embed."), nullptr},
-	{const_cast<char*>("subsetList"), (getter)PDFfile_getSubsetList, (setter)PDFfile_setSubsetList, const_cast<char*>("List of fonts to subsetted."), nullptr},
-	{const_cast<char*>("pages"), (getter)PDFfile_getpages, (setter)PDFfile_setpages, const_cast<char*>("List of pages to print"), nullptr},
-	{const_cast<char*>("resolution"), (getter)PDFfile_getresolution, (setter)PDFfile_setresolution, const_cast<char*>("Resolution of output file. Values from 35 to 4000."), nullptr},
-	{const_cast<char*>("downsample"), (getter)PDFfile_getdownsample, (setter)PDFfile_setdownsample, const_cast<char*>("Downsample image resolusion to this value. Values from 35 to 4000\nSet 0 for not to downsample"), nullptr},
-	{const_cast<char*>("effval"), (getter)PDFfile_geteffval, (setter)PDFfile_seteffval, effval_doc, nullptr},
-	{const_cast<char*>("lpival"), (getter)PDFfile_getlpival, (setter)PDFfile_setlpival, lpival_doc, nullptr},
-	{const_cast<char*>("owner"), (getter)PDFfile_getowner, (setter)PDFfile_setowner, const_cast<char*>("Owner's password"), nullptr},
-	{const_cast<char*>("user"), (getter)PDFfile_getuser, (setter)PDFfile_setuser, const_cast<char*>("User's password"), nullptr},
-	{const_cast<char*>("solidpr"), (getter)PDFfile_getsolidpr, (setter)PDFfile_setsolidpr, const_cast<char*>("Color profile for solid colors"), nullptr},
-	{const_cast<char*>("imagepr"), (getter)PDFfile_getimagepr, (setter)PDFfile_setimagepr, const_cast<char*>("Color profile for images"), nullptr},
-	{const_cast<char*>("printprofc"), (getter)PDFfile_getprintprofc, (setter)PDFfile_setprintprofc, const_cast<char*>("Output profile for printing. If possible, get some guidance from your printer on profile selection."), nullptr},
-	{const_cast<char*>("info"), (getter)PDFfile_getinfo, (setter)PDFfile_setinfo, const_cast<char*>("Mandatory string for PDF/X or the PDF will fail\nPDF/X conformance. We recommend you use the title of the document."), nullptr},
-	{const_cast<char*>("rotateDeg"), (getter)PDFfile_getRotateDeg, (setter)PDFfile_setRotateDeg, const_cast<char*>("Automatically rotate the exported pages\n\tValue must be one of integers: 0, 90, 180 or 270"), nullptr},
-	{const_cast<char*>("openAction"), (getter)PDFfile_getopenAction, (setter)PDFfile_setopenAction, const_cast<char*>("Javascript to be executed when PDF document is opened."), nullptr},
-	{nullptr, nullptr, nullptr, nullptr, nullptr}  // sentinel
+	{ "file", (getter) PDFfile_getfile, (setter) PDFfile_setfile, "Name of file to save into", nullptr},
+	{ "fontEmbedding", (getter) PDFfile_getFontEmbeddingMode, (setter) PDFfile_setFontEmbeddingMode, "Font embedding mode.\n\tValue must be one of integers: 0 (Embed), 1 (Outline), 2 (No embedding).", nullptr},
+	{ "fonts", (getter) PDFfile_getfonts, (setter) PDFfile_setfonts, "List of fonts to embed.", nullptr},
+	{ "subsetList", (getter) PDFfile_getSubsetList, (setter) PDFfile_setSubsetList, "List of fonts to subsetted.", nullptr},
+	{ "pages", (getter) PDFfile_getpages, (setter) PDFfile_setpages, "List of pages to print", nullptr},
+	{ "resolution", (getter) PDFfile_getresolution, (setter) PDFfile_setresolution, "Resolution of output file. Values from 35 to 4000.", nullptr},
+	{ "downsample", (getter) PDFfile_getdownsample, (setter) PDFfile_setdownsample, "Downsample image resolusion to this value. Values from 35 to 4000\nSet 0 for not to downsample", nullptr},
+	{ "effval", (getter) PDFfile_geteffval, (setter) PDFfile_seteffval, effval_doc, nullptr},
+	{ "lpival", (getter) PDFfile_getlpival, (setter) PDFfile_setlpival, lpival_doc, nullptr},
+	{ "owner", (getter) PDFfile_getowner, (setter) PDFfile_setowner, "Owner's password", nullptr},
+	{ "user", (getter) PDFfile_getuser, (setter) PDFfile_setuser, "User's password", nullptr},
+	{ "solidpr", (getter) PDFfile_getsolidpr, (setter) PDFfile_setsolidpr, "Color profile for solid colors", nullptr},
+	{ "imagepr", (getter) PDFfile_getimagepr, (setter) PDFfile_setimagepr, "Color profile for images", nullptr},
+	{ "printprofc", (getter) PDFfile_getprintprofc, (setter) PDFfile_setprintprofc, "Output profile for printing. If possible, get some guidance from your printer on profile selection.", nullptr},
+	{ "info", (getter) PDFfile_getinfo, (setter) PDFfile_setinfo, "Mandatory string for PDF/X or the PDF will fail\nPDF/X conformance. We recommend you use the title of the document.", nullptr},
+	{ "rotateDeg", (getter) PDFfile_getRotateDeg, (setter) PDFfile_setRotateDeg, "Automatically rotate the exported pages\n\tValue must be one of integers: 0, 90, 180 or 270", nullptr},
+	{ "openAction", (getter) PDFfile_getopenAction, (setter) PDFfile_setopenAction, "Javascript to be executed when PDF document is opened.", nullptr},
+	{ nullptr, nullptr, nullptr, nullptr, nullptr }  // sentinel
 };
 
 static PyObject *PDFfile_save(PDFfile *self)
@@ -1415,7 +1413,7 @@ static PyObject *PDFfile_save(PDFfile *s
 	// Apply fonts attribute
 	pdfOptions.EmbedList.clear();
 	n = PyList_Size(self->fonts);
-	for (int i = 0; i < n; ++i)
+	for (Py_ssize_t i = 0; i < n; ++i)
 	{
 		QString tmpFon = PyUnicode_asQString(PyList_GetItem(self->fonts, i));
 		if (pdfOptions.SubsetList.contains(tmpFon))
@@ -1462,8 +1460,8 @@ static PyObject *PDFfile_save(PDFfile *s
 	pdfOptions.fileName = fn;
 	// Apply pages attribute
 	std::vector<int> pageNs;
-	int nn = PyList_Size(self->pages);
-	for (int i = 0; i < nn; ++i) {
+	Py_ssize_t nn = PyList_Size(self->pages);
+	for (Py_ssize_t i = 0; i < nn; ++i) {
 		pageNs.push_back((int) PyLong_AsLong(PyList_GetItem(self->pages, i)));
 	}
 	// Apply thumbnails attribute
@@ -1504,8 +1502,8 @@ static PyObject *PDFfile_save(PDFfile *s
 	// Apply presentation attribute
 	pdfOptions.PresentMode = self->presentation;
 
-	int tmpnum = PyList_Size(self->effval);
-	for (int i = 0; i < tmpnum; ++i) 
+	Py_ssize_t tmpnum = PyList_Size(self->effval);
+	for (Py_ssize_t i = 0; i < tmpnum; ++i)
 	{
 		PDFPresentationData t;
 		PyObject *ti = PyList_GetItem(self->effval, i);
@@ -1523,8 +1521,8 @@ static PyObject *PDFfile_save(PDFfile *s
 //	pdfOptions.PresentVals = PresentVals;
 
 	// Apply lpival
-	int n2 = PyList_Size(self->lpival);
-	for (int i = 0; i < n2; ++i)
+	Py_ssize_t n2 = PyList_Size(self->lpival);
+	for (Py_ssize_t i = 0; i < n2; ++i)
 	{
 		LPIData lpi;
 		PyObject *t = PyList_GetItem(self->lpival, i);
@@ -1667,100 +1665,103 @@ static PyObject *PDFfile_save(PDFfile *s
 }
 
 static PyMethodDef PDFfile_methods[] = {
-	{const_cast<char*>("save"), (PyCFunction)PDFfile_save, METH_NOARGS, pdffile_save__doc__},
-	{nullptr, (PyCFunction)(nullptr), 0, nullptr} // sentinel
+	{ "save", (PyCFunction)PDFfile_save, METH_NOARGS, pdffile_save__doc__ },
+	{ nullptr, (PyCFunction)(nullptr), 0, nullptr } // sentinel
 };
 
 PyTypeObject PDFfile_Type = {
 	PyVarObject_HEAD_INIT(nullptr, 0) // PyObject_VAR_HEAD	      //
-	const_cast<char*>("scribus.PDFfile"), // char *tp_name; /* For printing, in format "<module>.<name>" */
-	sizeof(PDFfile),     // int tp_basicsize, /* For allocation */
-	0,		    // int tp_itemsize; /* For allocation */
+	"scribus.PDFfile", // const char *tp_name /* For printing, in format "<module>.<name>" */
+	sizeof(PDFfile),     // int tp_basicsize /* For allocation */
+	0,		    // int tp_itemsize /* For allocation */
 
 	/* Methods to implement standard operations */
 
-	(destructor) PDFfile_dealloc, //     destructor tp_dealloc;
+	(destructor) PDFfile_dealloc, //     destructor tp_dealloc
 #if PY_VERSION_HEX >= 0x03080000
 	0,       //     Py_ssize_t tp_vectorcall_offset
 #else
 	nullptr, //     printfunc tp_print;
 #endif
-	nullptr, //     getattrfunc tp_getattr;
-	nullptr, //     setattrfunc tp_setattr;
-	nullptr, //     cmpfunc tp_as_async;
-	nullptr, //     reprfunc tp_repr;
+	nullptr, //     getattrfunc tp_getattr
+	nullptr, //     setattrfunc tp_setattr
+	nullptr, //     cmpfunc tp_as_async
+	nullptr, //     reprfunc tp_repr
 
 	/* Method suites for standard classes */
 
-	nullptr, //     PyNumberMethods *tp_as_number;
-	nullptr, //     PySequenceMethods *tp_as_sequence;
-	nullptr, //     PyMappingMethods *tp_as_mapping;
+	nullptr, //     PyNumberMethods *tp_as_number
+	nullptr, //     PySequenceMethods *tp_as_sequence
+	nullptr, //     PyMappingMethods *tp_as_mapping
 
 	/* More standard operations (here for binary compatibility) */
 
-	nullptr, //     hashfunc tp_hash;
-	nullptr, //     ternaryfunc tp_call;
-	nullptr, //     reprfunc tp_str;
-	nullptr, //     getattrofunc tp_getattro;
-	nullptr, //     setattrofunc tp_setattro;
+	nullptr, //     hashfunc tp_hash
+	nullptr, //     ternaryfunc tp_call
+	nullptr, //     reprfunc tp_str
+	nullptr, //     getattrofunc tp_getattro
+	nullptr, //     setattrofunc tp_setattro
 
 	/* Functions to access object as input/output buffer */
-	nullptr, //     PyBufferProcs *tp_as_buffer;
+	nullptr, //     PyBufferProcs *tp_as_buffer
 
 	/* Flags to define presence of optional/expanded features */
-	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,    // long tp_flags;
+	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,    // long tp_flags
 
-	pdffile__doc__,      // char *tp_doc; /* Documentation string */
+	pdffile__doc__,      // char *tp_doc /* Documentation string */
 
 	/* Assigned meaning in release 2.0 */
 	/* call function for all accessible objects */
-	nullptr, //     traverseproc tp_traverse;
+	nullptr, //     traverseproc tp_traverse
 
 	/* delete references to contained objects */
-	nullptr, //     inquiry tp_clear;
+	nullptr, //     inquiry tp_clear
 
 	/* Assigned meaning in release 2.1 */
 	/* rich comparisons */
-	nullptr, //     richcmpfunc tp_richcompare;
+	nullptr, //     richcmpfunc tp_richcompare
 
 	/* weak reference enabler */
-	0, //     long tp_weaklistoffset;
+	0, //     long tp_weaklistoffset
 
 	/* Added in release 2.2 */
 	/* Iterators */
-	nullptr, //     getiterfunc tp_iter;
-	nullptr, //     iternextfunc tp_iternext;
+	nullptr, //     getiterfunc tp_iter
+	nullptr, //     iternextfunc tp_iternext
 
 	/* Attribute descriptor and subclassing stuff */
-	PDFfile_methods, //     struct PyMethodDef *tp_methods;
-	PDFfile_members, //     struct PyMemberDef *tp_members;
-	PDFfile_getseters, //     struct PyGetSetDef *tp_getset;
-	nullptr, //     struct _typeobject *tp_base;
-	nullptr, //     PyObject *tp_dict;
-	nullptr, //     descrgetfunc tp_descr_get;
-	nullptr, //     descrsetfunc tp_descr_set;
-	0, //     long tp_dictoffset;
-	(initproc)PDFfile_init, //     initproc tp_init;
-	nullptr, //     allocfunc tp_alloc;
-	PDFfile_new, //     newfunc tp_new;
-	nullptr, //     freefunc tp_free; /* Low-level free-memory routine */
-	nullptr, //     inquiry tp_is_gc; /* For PyObject_IS_GC */
-	nullptr, //     PyObject *tp_bases;
-	nullptr, //     PyObject *tp_mro; /* method resolution order */
-	nullptr, //     PyObject *tp_cache;
-	nullptr, //     PyObject *tp_subclasses;
-	nullptr, //     PyObject *tp_weaklist;
-	nullptr, //     destructor tp_del;
-	0, //	 unsigned int tp_version_tag;
-	nullptr, //	 destructor tp_finalize;
+	PDFfile_methods, //     struct PyMethodDef *tp_methods
+	PDFfile_members, //     struct PyMemberDef *tp_members
+	PDFfile_getseters, //     struct PyGetSetDef *tp_getset
+	nullptr, //     struct _typeobject *tp_base
+	nullptr, //     PyObject *tp_dict
+	nullptr, //     descrgetfunc tp_descr_get
+	nullptr, //     descrsetfunc tp_descr_set
+	0, //     long tp_dictoffset
+	(initproc) PDFfile_init, //     initproc tp_init
+	nullptr, //     allocfunc tp_alloc
+	PDFfile_new, //     newfunc tp_new
+	nullptr, //     freefunc tp_free /* Low-level free-memory routine */
+	nullptr, //     inquiry tp_is_gc /* For PyObject_IS_GC */
+	nullptr, //     PyObject *tp_bases
+	nullptr, //     PyObject *tp_mro /* method resolution order */
+	nullptr, //     PyObject *tp_cache
+	nullptr, //     PyObject *tp_subclasses
+	nullptr, //     PyObject *tp_weaklist
+	nullptr, //     destructor tp_del
+	0, //	 unsigned int tp_version_tag
+	nullptr, //	 destructor tp_finalize
 #if PY_VERSION_HEX >= 0x03080000
 	nullptr, // tp_vectorcall
 #endif
 #if PY_VERSION_HEX >= 0x03080000 && PY_VERSION_HEX < 0x03090000
 	nullptr, //deprecated tp_print
 #endif
-#if PY_VERSION_HEX >= 0x03120000
-	0, // char tp_watched
+#if PY_VERSION_HEX >= 0x030C0000 // Python 3.12
+	0, // unsigned char tp_watched
+#endif
+#if PY_VERSION_HEX >= 0x030D0000 // Python 3.13
+	0, // uint16_t tp_versions_used
 #endif
 
 #if defined(COUNT_ALLOCS) && PY_VERSION_HEX < 0x03090000
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/objprinter.cpp scribus16x/scribus/plugins/scriptplugin/objprinter.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/objprinter.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/objprinter.cpp	2025-01-04 10:59:06.319376741 +0100
@@ -34,7 +34,7 @@ for which a new license (GPL+exception)
 void SCRIBUS_API ReOrderText(ScribusDoc *doc, ScribusView *view);
 // end of utils.cpp
 
-typedef struct
+struct Printer
 {
 	PyObject_HEAD
 	PyObject *allPrinters; // list of strings - names of installed printers
@@ -50,7 +50,7 @@ typedef struct
 	int mph; // bool - mirror pages horizontally
 	int mpv; // bool - mirror pages vertically
 	int ucr; // bool - Under Color Removal
-} Printer;
+};
 
 
 static void Printer_dealloc(Printer* self)
@@ -67,45 +67,53 @@ static void Printer_dealloc(Printer* sel
 static PyObject * Printer_new(PyTypeObject *type, PyObject * /*args*/, PyObject * /*kwds*/)
 {
 // do not create new object if there is no opened document
-	if (!checkHaveDocument()) {
+	if (!checkHaveDocument())
+	{
 		return nullptr;
 	}
 
 	Printer *self = (Printer *)type->tp_alloc(type, 0);
-	if (self != nullptr) {
+	if (self != nullptr) 
+	{
 // set allPrinters attribute
 		self->allPrinters = PyList_New(0);
-		if (self->allPrinters == nullptr) {
+		if (self->allPrinters == nullptr)
+		{
 			Py_DECREF(self);
 			return nullptr;
 		}
 // set printer attribute
 		self->printer = PyUnicode_FromString("");
-		if (self->printer == nullptr) {
+		if (self->printer == nullptr)
+		{
 			Py_DECREF(self);
 			return nullptr;
 		}
 // set file attribute
 		self->file = PyUnicode_FromString("");
-		if (self->file == nullptr) {
+		if (self->file == nullptr)
+		{
 			Py_DECREF(self);
 			return nullptr;
 		}
 // set cmd attribute
 		self->cmd = PyUnicode_FromString("");
-		if (self->cmd == nullptr) {
+		if (self->cmd == nullptr)
+		{
 			Py_DECREF(self);
 			return nullptr;
 		}
 // set pages attribute
 		self->pages = PyList_New(0);
-		if (self->pages == nullptr) {
+		if (self->pages == nullptr)
+		{
 			Py_DECREF(self);
 			return nullptr;
 		}
 // set separation attribute
 		self->separation = PyUnicode_FromString("No");
-		if (self->separation == nullptr) {
+		if (self->separation == nullptr)
+		{
 			Py_DECREF(self);
 			return nullptr;
 		}
@@ -129,13 +137,14 @@ static PyObject * Printer_new(PyTypeObje
 
 static int Printer_init(Printer *self, PyObject * /*args*/, PyObject * /*kwds*/)
 {
-	if (!checkHaveDocument()) {
+	if (!checkHaveDocument())
 		return -1;
-	}
+
 // pool system for installed printers
 // most code is stolen and little adopted from druck.cpp
 	PyObject *allPrinters = PyList_New(0);
-	if (allPrinters) {
+	if (allPrinters)
+	{
 		Py_DECREF(self->allPrinters);
 		self->allPrinters = allPrinters;
 	}
@@ -146,7 +155,8 @@ static int Printer_init(Printer *self, P
 		if (prn.isEmpty())
 			continue;
 		PyObject *tmppr = PyUnicode_FromString(prn.toUtf8().constData());
-		if (tmppr) {
+		if (tmppr)
+		{
 			PyList_Append(self->allPrinters, tmppr);
 			Py_DECREF(tmppr);
 		}
@@ -157,29 +167,35 @@ static int Printer_init(Printer *self, P
 // as default set to print into file
 	PyObject *printer = nullptr;
 	printer = PyUnicode_FromString("File");
-	if (printer) {
+	if (printer)
+	{
 		Py_DECREF(self->printer);
 		self->printer = printer;
 	}
 // set default name of file to print into
 	QString tf(ScCore->primaryMainWindow()->doc->pdfOptions().fileName);
-	if (tf.isEmpty()) {
-		QFileInfo fi = QFileInfo(ScCore->primaryMainWindow()->doc->documentFileName());
+	if (tf.isEmpty())
+	{
+		QFileInfo fi(ScCore->primaryMainWindow()->doc->documentFileName());
 		tf = fi.path() + "/" + fi.baseName() + ".pdf";
 	}
 	PyObject *file = nullptr;
 	file = PyUnicode_FromString(tf.toUtf8());
-	if (file) {
+	if (file)
+	{
 		Py_DECREF(self->file);
 		self->file = file;
-	} else {
+	}
+	else
+	{
 		PyErr_SetString(PyExc_SystemError, "Can not initialize 'file' attribute");
 		return -1;
 	}
 // alternative printer commands default to ""
 	PyObject *cmd = nullptr;
 	cmd = PyUnicode_FromString("");
-	if (cmd) {
+	if (cmd)
+	{
 		Py_DECREF(self->cmd);
 		self->cmd = cmd;
 	}
@@ -188,20 +204,23 @@ static int Printer_init(Printer *self, P
 	PyObject *pages = nullptr;
 	int num = ScCore->primaryMainWindow()->doc->Pages->count();
 	pages = PyList_New(num);
-	if (pages) {
+	if (pages)
+	{
 		Py_DECREF(self->pages);
 		self->pages = pages;
 	}
-	for (int i = 0; i < num; i++) {
+	for (int i = 0; i < num; i++)
+	{
 		PyObject *tmp = nullptr;
-		tmp = PyLong_FromLong((long)i+1L); // instead of 1 put here first page number
+		tmp = PyLong_FromLong((long) i + 1L); // instead of 1 put here first page number
 		if (tmp)
 			PyList_SetItem(self->pages, i, tmp);
 	}
 // do not print separation
 	PyObject *separation = nullptr;
 	separation = PyUnicode_FromString("No");
-	if (separation) {
+	if (separation)
+	{
 		Py_DECREF(self->separation);
 		self->separation = separation;
 	}
@@ -223,15 +242,15 @@ static int Printer_init(Printer *self, P
 }
 
 static PyMemberDef Printer_members[] = {
-	{const_cast<char*>("copies"), T_INT, offsetof(Printer, copies), 0, const_cast<char*>("Number of copies")},
-	{const_cast<char*>("color"), T_INT, offsetof(Printer, color), 0, const_cast<char*>("Print in color.\n\t True - color  --  Default\n\t False - greyscale")},
-	{const_cast<char*>("useICC"), T_INT, offsetof(Printer, useICC), 0, const_cast<char*>("Use ICC Profile\n\tTrue\n\tFalse  --  Default")},
-	{const_cast<char*>("pslevel"), T_INT, offsetof(Printer, prnLang), 0, const_cast<char*>("Deprecated, use prnLanguage instead.")}, // Deprecated
-	{const_cast<char*>("prnLanguage"), T_INT, offsetof(Printer, prnLang), 0, const_cast<char*>("Print Language\nOne of PRNLANG_* constants  -- Default is PRNLANG_POSTSCRIPT3.")},
-	{const_cast<char*>("mph"), T_INT, offsetof(Printer, mph), 0, const_cast<char*>("Mirror Pages Horizontal\n\tTrue\n\tFalse  --  Default")},
-	{const_cast<char*>("mpv"), T_INT, offsetof(Printer, mpv), 0, const_cast<char*>("Mirror Pages Vertical\n\t True\n\tFalse  --  Default")},
-	{const_cast<char*>("ucr"), T_INT, offsetof(Printer, ucr), 0, const_cast<char*>("Apply Under Color Removal\n\tTrue  --  Default\n\tFalse")},
-	{nullptr, 0, 0, 0, nullptr} // sentinel
+	{ "copies", T_INT, offsetof(Printer, copies), 0, "Number of copies" },
+	{ "color", T_INT, offsetof(Printer, color), 0, "Print in color.\n\t True - color  --  Default\n\t False - greyscale" },
+	{ "useICC", T_INT, offsetof(Printer, useICC), 0, "Use ICC Profile\n\tTrue\n\tFalse  --  Default" },
+	{ "pslevel", T_INT, offsetof(Printer, prnLang), 0, "Deprecated, use prnLanguage instead." }, // Deprecated
+	{ "prnLanguage", T_INT, offsetof(Printer, prnLang), 0, "Print Language\nOne of PRNLANG_* constants  -- Default is PRNLANG_POSTSCRIPT3." },
+	{ "mph", T_INT, offsetof(Printer, mph), 0, "Mirror Pages Horizontal\n\tTrue\n\tFalse  --  Default" },
+	{ "mpv", T_INT, offsetof(Printer, mpv), 0, "Mirror Pages Vertical\n\t True\n\tFalse  --  Default" },
+	{ "ucr", T_INT, offsetof(Printer, ucr), 0, "Apply Under Color Removal\n\tTrue  --  Default\n\tFalse" },
+	{ nullptr, 0, 0, 0, nullptr } // sentinel
 };
 
 /* Here begins Getter & Setter functions */
@@ -256,24 +275,29 @@ static PyObject *Printer_getprinter(Prin
 
 static int Printer_setprinter(Printer *self, PyObject *value, void * /*closure*/)
 {
-	if (value == nullptr) {
+	if (value == nullptr)
+	{
 		PyErr_SetString(PyExc_TypeError, "Cannot delete 'printer' attribute.");
 		return -1;
 	}
-	if (!PyUnicode_Check(value)) {
+	if (!PyUnicode_Check(value))
+	{
 		PyErr_SetString(PyExc_TypeError, "The 'printer' attribute value must be string.");
 		return -1;
 	}
 
-	int n = PyList_Size(self->allPrinters);
-	bool same = 0;
-	for (int i = 0; i < n; i++) {
-		if (PyObject_RichCompareBool(value, PyList_GetItem(self->allPrinters, i), Py_EQ) == 1) {
+	Py_ssize_t n = PyList_Size(self->allPrinters);
+	bool same = false;
+	for (Py_ssize_t i = 0; i < n; i++)
+	{
+		if (PyObject_RichCompareBool(value, PyList_GetItem(self->allPrinters, i), Py_EQ) == 1)
+		{
 			same = true;
 			break;
 		}
 	}
-	if (!same) {
+	if (!same)
+	{
 		PyErr_SetString(PyExc_ValueError, "'printer' value can be only one of string in 'allPrinters' attribute ");
 		return -1;
 	}
@@ -292,11 +316,13 @@ static PyObject *Printer_getfile(Printer
 
 static int Printer_setfile(Printer *self, PyObject *value, void * /*closure*/)
 {
-	if (value == nullptr) {
+	if (value == nullptr)
+	{
 		PyErr_SetString(PyExc_TypeError, "Cannot delete 'file' attribute.");
 		return -1;
 	}
-	if (!PyUnicode_Check(value)) {
+	if (!PyUnicode_Check(value))
+	{
 		PyErr_SetString(PyExc_TypeError, "The 'file' attribute value must be string.");
 		return -1;
 	}
@@ -314,11 +340,13 @@ static PyObject *Printer_getcmd(Printer
 
 static int Printer_setcmd(Printer *self, PyObject *value, void * /*closure*/)
 {
-	if (value == nullptr) {
+	if (value == nullptr)
+	{
 		PyErr_SetString(PyExc_TypeError, "Cannot delete 'cmd' attribute.");
 		return -1;
 	}
-	if (!PyUnicode_Check(value)) {
+	if (!PyUnicode_Check(value))
+	{
 		PyErr_SetString(PyExc_TypeError, "The 'cmd' attribute value must be string.");
 		return -1;
 	}
@@ -336,18 +364,22 @@ static PyObject *Printer_getpages(Printe
 
 static int Printer_setpages(Printer *self, PyObject *value, void * /*closure*/)
 {
-	if (value == nullptr) {
+	if (value == nullptr)
+	{
 		PyErr_SetString(PyExc_TypeError, "Cannot delete 'pages' attribute.");
 		return -1;
 	}
-	if (!PyList_Check(value)) {
+	if (!PyList_Check(value))
+	{
 		PyErr_SetString(PyExc_TypeError, "'pages' attribute value must be list of integers.");
 		return -1;
 	}
-	int len = PyList_Size(value);
-	for (int i = 0; i < len; i++) {
+	Py_ssize_t len = PyList_Size(value);
+	for (Py_ssize_t i = 0; i < len; i++)
+	{
 		PyObject *tmp = PyList_GetItem(value, i);
-		if (!PyLong_Check(tmp)) {
+		if (!PyLong_Check(tmp))
+		{
 			PyErr_SetString(PyExc_TypeError, "'pages' attribute must be list containing only integers.");
 			return -1;
 		}
@@ -370,11 +402,13 @@ static PyObject *Printer_getseparation(P
 
 static int Printer_setseparation(Printer *self, PyObject *value, void * /*closure*/)
 {
-	if (value == nullptr) {
+	if (value == nullptr)
+	{
 		PyErr_SetString(PyExc_TypeError, "Cannot delete 'separation' attribute.");
 		return -1;
 	}
-	if (!PyUnicode_Check(value)) {
+	if (!PyUnicode_Check(value))
+	{
 		PyErr_SetString(PyExc_TypeError, "The 'separation' attribute value must be string.");
 		return -1;
 	}
@@ -386,21 +420,20 @@ static int Printer_setseparation(Printer
 
 
 static PyGetSetDef Printer_getseters [] = {
-	{const_cast<char*>("allPrinters"), (getter)Printer_getallPrinters, (setter)Printer_setallPrinters, const_cast<char*>("List of installed printers  --  read only"), nullptr},
-	{const_cast<char*>("printer"), (getter)Printer_getprinter, (setter)Printer_setprinter, const_cast<char*>("Name of printer to use.\nDefault is 'File' for printing into file"), nullptr},
-	{const_cast<char*>("file"), (getter)Printer_getfile, (setter)Printer_setfile, const_cast<char*>("Name of file to print into"), nullptr},
-	{const_cast<char*>("cmd"), (getter)Printer_getcmd, (setter)Printer_setcmd, const_cast<char*>("Alternative Printer Command"), nullptr},
-	{const_cast<char*>("pages"), (getter)Printer_getpages, (setter)Printer_setpages, const_cast<char*>("List of pages to be printed"), nullptr},
-	{const_cast<char*>("separation"), (getter)Printer_getseparation, (setter)Printer_setseparation, const_cast<char*>("Print separationl\n\t 'No'  -- Default\n\t 'All'\n\t 'Cyan'\n\t 'Magenta'\n\t 'Yellow'\n\t 'Black'\nBeware of misspelling because check is not performed"), nullptr},
-	{nullptr, nullptr, nullptr, nullptr, nullptr}  // sentinel
+	{ "allPrinters", (getter) Printer_getallPrinters, (setter) Printer_setallPrinters, "List of installed printers  --  read only", nullptr},
+	{ "printer", (getter) Printer_getprinter, (setter) Printer_setprinter, "Name of printer to use.\nDefault is 'File' for printing into file", nullptr},
+	{ "file", (getter) Printer_getfile, (setter) Printer_setfile, "Name of file to print into", nullptr},
+	{ "cmd", (getter) Printer_getcmd, (setter) Printer_setcmd, "Alternative Printer Command", nullptr},
+	{ "pages", (getter) Printer_getpages, (setter) Printer_setpages, "List of pages to be printed", nullptr},
+	{ "separation", (getter) Printer_getseparation, (setter) Printer_setseparation, "Print separationl\n\t 'No'  -- Default\n\t 'All'\n\t 'Cyan'\n\t 'Magenta'\n\t 'Yellow'\n\t 'Black'\nBeware of misspelling because check is not performed", nullptr},
+	{ nullptr, nullptr, nullptr, nullptr, nullptr }  // sentinel
 };
 
 // Here we actually print
 static PyObject *Printer_print(Printer *self)
 {
-	if (!checkHaveDocument()) {
+	if (!checkHaveDocument())
 		return nullptr;
-	}
 
 //	ReOrderText(ScCore->primaryMainWindow()->doc, ScCore->primaryMainWindow()->view);
 	QString prn = PyUnicode_asQString(self->printer);
@@ -409,7 +442,8 @@ static PyObject *Printer_print(Printer *
 	QString sepName = PyUnicode_asQString(self->separation);
 	
 	PrintOptions options;
-	for (int i = 0; i < PyList_Size(self->pages); ++i) {
+	for (Py_ssize_t i = 0; i < PyList_Size(self->pages); ++i)
+	{
 		options.pageNumbers.push_back((int) PyLong_AsLong(PyList_GetItem(self->pages, i)));
 	}
 	options.printer   = prn;
@@ -486,13 +520,13 @@ static PyObject *Printer_print(Printer *
 }
 
 static PyMethodDef Printer_methods[] = {
-	{const_cast<char*>("printNow"), (PyCFunction)Printer_print, METH_NOARGS, printer_printnow__doc__},
-	{nullptr, (PyCFunction)(nullptr), 0, nullptr} // sentinel
+	{ "printNow", (PyCFunction)Printer_print, METH_NOARGS, printer_printnow__doc__ },
+	{ nullptr, (PyCFunction)(nullptr), 0, nullptr } // sentinel
 };
 
 PyTypeObject Printer_Type = {
 	PyVarObject_HEAD_INIT(nullptr, 0)   // PyObject_VAR_HEAD	 //
-	const_cast<char*>("scribus.Printer"), // char *tp_name; /* For printing, in format "<module>.<name>" */
+	"scribus.Printer", // const char *tp_name; /* For printing, in format "<module>.<name>" */
 	sizeof(Printer),   // int tp_basicsize, /* For allocation */
 	0,		       // int tp_itemsize; /* For allocation */
 
@@ -502,29 +536,29 @@ PyTypeObject Printer_Type = {
 #if PY_VERSION_HEX >= 0x03080000
 	0,       //     Py_ssize_t tp_vectorcall_offset
 #else
-	nullptr, //     printfunc tp_print;
+	nullptr, //     printfunc tp_print
 #endif
-	nullptr, //     getattrfunc tp_getattr;
-	nullptr, //     setattrfunc tp_setattr;
-	nullptr, //     cmpfunc tp_as_async;
-	nullptr, //     reprfunc tp_repr;
+	nullptr, //     getattrfunc tp_getattr
+	nullptr, //     setattrfunc tp_setattr
+	nullptr, //     cmpfunc tp_as_async
+	nullptr, //     reprfunc tp_repr
 
 	/* Method suites for standard classes */
 
-	nullptr, //     PyNumberMethods *tp_as_number;
-	nullptr, //     PySequenceMethods *tp_as_sequence;
-	nullptr, //     PyMappingMethods *tp_as_mapping;
+	nullptr, //     PyNumberMethods *tp_as_number
+	nullptr, //     PySequenceMethods *tp_as_sequence
+	nullptr, //     PyMappingMethods *tp_as_mapping
 
 	/* More standard operations (here for binary compatibility) */
 
-	nullptr, //     hashfunc tp_hash;
-	nullptr, //     ternaryfunc tp_call;
-	nullptr, //     reprfunc tp_str;
-	nullptr, //     getattrofunc tp_getattro;
-	nullptr, //     setattrofunc tp_setattro;
+	nullptr, //     hashfunc tp_hash
+	nullptr, //     ternaryfunc tp_call
+	nullptr, //     reprfunc tp_str
+	nullptr, //     getattrofunc tp_getattro
+	nullptr, //     setattrofunc tp_setattro
 
 	/* Functions to access object as input/output buffer */
-	nullptr, //     PyBufferProcs *tp_as_buffer;
+	nullptr, //     PyBufferProcs *tp_as_buffer
 
 	/* Flags to define presence of optional/expanded features */
 	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,    // long tp_flags;
@@ -533,53 +567,56 @@ PyTypeObject Printer_Type = {
 
 	/* Assigned meaning in release 2.0 */
 	/* call function for all accessible objects */
-	nullptr, //     traverseproc tp_traverse;
+	nullptr, //     traverseproc tp_traverse
 
 	/* delete references to contained objects */
-	nullptr, //     inquiry tp_clear;
+	nullptr, //     inquiry tp_clear
 
 	/* Assigned meaning in release 2.1 */
 	/* rich comparisons */
-	nullptr, //     richcmpfunc tp_richcompare;
+	nullptr, //     richcmpfunc tp_richcompare
 
 	/* weak reference enabler */
-	0, //     long tp_weaklistoffset;
+	0, //     long tp_weaklistoffset
 
 	/* Added in release 2.2 */
 	/* Iterators */
-	nullptr, //     getiterfunc tp_iter;
-	nullptr, //     iternextfunc tp_iternext;
+	nullptr, //     getiterfunc tp_iter
+	nullptr, //     iternextfunc tp_iternext
 
 	/* Attribute descriptor and subclassing stuff */
-	Printer_methods, //     struct PyMethodDef *tp_methods;
-	Printer_members, //     struct PyMemberDef *tp_members;
-	Printer_getseters, //     struct PyGetSetDef *tp_getset;
-	nullptr, //     struct _typeobject *tp_base;
-	nullptr, //     PyObject *tp_dict;
-	nullptr, //     descrgetfunc tp_descr_get;
-	nullptr, //     descrsetfunc tp_descr_set;
-	0, //     long tp_dictoffset;
-	(initproc)Printer_init, //     initproc tp_init;
-	nullptr, //     allocfunc tp_alloc;
-	Printer_new, //     newfunc tp_new;
+	Printer_methods, //     struct PyMethodDef *tp_methods
+	Printer_members, //     struct PyMemberDef *tp_members
+	Printer_getseters, //     struct PyGetSetDef *tp_getset
+	nullptr, //     struct _typeobject *tp_base
+	nullptr, //     PyObject *tp_dict
+	nullptr, //     descrgetfunc tp_descr_get
+	nullptr, //     descrsetfunc tp_descr_set
+	0, //     long tp_dictoffset
+	(initproc) Printer_init, //     initproc tp_init
+	nullptr, //     allocfunc tp_alloc
+	Printer_new, //     newfunc tp_new
 	nullptr, //     freefunc tp_free; /* Low-level free-memory routine */
 	nullptr, //     inquiry tp_is_gc; /* For PyObject_IS_GC */
-	nullptr, //     PyObject *tp_bases;
+	nullptr, //     PyObject *tp_bases
 	nullptr, //     PyObject *tp_mro; /* method resolution order */
-	nullptr, //     PyObject *tp_cache;
-	nullptr, //     PyObject *tp_subclasses;
-	nullptr, //     PyObject *tp_weaklist;
-	nullptr, //     destructor tp_del;
-	0, //	 unsigned int tp_version_tag;
-	nullptr, //	 destructor tp_finalize;
+	nullptr, //     PyObject *tp_cache
+	nullptr, //     PyObject *tp_subclasses
+	nullptr, //     PyObject *tp_weaklist
+	nullptr, //     destructor tp_del
+	0, //	 unsigned int tp_version_tag
+	nullptr, //	 destructor tp_finalize
 #if PY_VERSION_HEX >= 0x03080000
 	nullptr, // tp_vectorcall
 #endif
 #if PY_VERSION_HEX >= 0x03080000 && PY_VERSION_HEX < 0x03090000
 	nullptr, //deprecated tp_print
 #endif
-#if PY_VERSION_HEX >= 0x03120000
-	0, // char tp_watched
+#if PY_VERSION_HEX >= 0x030C0000 // Python 3.12
+	0, // unsigned char tp_watched
+#endif
+#if PY_VERSION_HEX >= 0x030D0000 // Python 3.13
+	0, // uint16_t tp_versions_used
 #endif
 
 #if defined(COUNT_ALLOCS) && PY_VERSION_HEX < 0x03090000
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/pconsole.cpp scribus16x/scribus/plugins/scriptplugin/pconsole.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/pconsole.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/pconsole.cpp	2025-01-04 10:59:06.319376741 +0100
@@ -21,6 +21,7 @@ the Free Software Foundation; either ver
 #include "prefsfile.h"
 #include "prefsmanager.h"
 #include "scribuscore.h"
+#include "util_keyboard.h"
 
 
 PythonConsole::PythonConsole( QWidget* parent)
@@ -290,7 +291,7 @@ SyntaxHighlighter::SyntaxHighlighter(QTe
 	numberFormat.setForeground(colors.numberColor);
 	operatorFormat.setForeground(colors.signColor);
 
-	foreach (const QString& kw, keywords)
+	for (const QString& kw : keywords)
 	{
 		rule.pattern = QRegExp("\\b" + kw + "\\b", Qt::CaseInsensitive);
 		rule.format = keywordFormat;
@@ -327,7 +328,7 @@ void SyntaxHighlighter::highlightBlock(c
 	// Apply default text color
 	setFormat(0, text.length(), colors.textColor);
 
-	foreach (HighlightingRule rule, highlightingRules)
+	for (const HighlightingRule& rule : highlightingRules)
 	{
 		QRegExp expression(rule.pattern);
 		int index = expression.indexIn(text);
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/prefs_scripter.cpp scribus16x/scribus/plugins/scriptplugin/prefs_scripter.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/prefs_scripter.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/prefs_scripter.cpp	2025-01-04 10:59:06.319376741 +0100
@@ -8,6 +8,7 @@ for which a new license (GPL+exception)
 // include the python header first because on OSX that uses the name "slots"
 #include "cmdvar.h"
 
+#include <memory>
 #include <QColorDialog>
 #include <QFileDialog>
 #include <QPalette>
@@ -122,7 +123,8 @@ void Prefs_Scripter::setColor()
 
 void Prefs_Scripter::setupSyntaxColors()
 {
-	SyntaxColors* syntax = new SyntaxColors();
+	std::unique_ptr<SyntaxColors> syntax(new SyntaxColors());
+
 	textColor = syntax->textColor;
 	commentColor = syntax->commentColor;
 	keywordColor = syntax->keywordColor;
@@ -146,8 +148,6 @@ void Prefs_Scripter::setupSyntaxColors()
 	stringButton->setIcon(pm);
 	pm.fill(numberColor);
 	numberButton->setIcon(pm);
-
-	delete(syntax);
 }
 
 void Prefs_Scripter::changeStartupScript()
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/runscriptdialog.cpp scribus16x/scribus/plugins/scriptplugin/runscriptdialog.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/runscriptdialog.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/runscriptdialog.cpp	2025-01-04 10:59:06.319376741 +0100
@@ -17,7 +17,7 @@ RunScriptDialog::RunScriptDialog(QWidget
 	setupUi(this);
 
 	m_extEnable = extEnable;
-	PrefsManager& prefsManager = PrefsManager::instance();
+	const PrefsManager& prefsManager = PrefsManager::instance();
 	QString scriptDir(prefsManager.appPrefs.pathPrefs.scripts);
 	if (!m_lastScriptDir.isEmpty() && QDir(m_lastScriptDir).exists())
 		fileWidget->setDirectory(m_lastScriptDir);
@@ -37,23 +37,19 @@ RunScriptDialog::RunScriptDialog(QWidget
 	connect(buttonBox, SIGNAL(rejected()), this, SLOT(reject()));
 }
 
-RunScriptDialog::~RunScriptDialog()
-{
-}
-
-bool RunScriptDialog::extensionRequested()
+bool RunScriptDialog::extensionRequested() const
 {
 	if (m_extEnable)
 		return extChk->isChecked();
 	return false;
 }
 
-QString RunScriptDialog::selectedFile()
+QString RunScriptDialog::selectedFile() const
 {
 	return fileWidget->selectedFile();
 }
 
-void RunScriptDialog:: accept()
+void RunScriptDialog::accept()
 {
 	m_lastScriptDir = fileWidget->directory().path();
 	QDialog::accept();
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/runscriptdialog.h scribus16x/scribus/plugins/scriptplugin/runscriptdialog.h
--- scribus-1.6.2/scribus/plugins/scriptplugin/runscriptdialog.h	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/runscriptdialog.h	2025-01-04 10:59:06.319376741 +0100
@@ -22,16 +22,15 @@ class RunScriptDialog : public QDialog,
 
 	public:
 		RunScriptDialog(QWidget* parent, bool extEnable = false);
-		~RunScriptDialog();
 
 		//! \brief Check if the user wanted the script run as an extension script
-		bool extensionRequested();
+		bool extensionRequested() const;
 		//! \brief Return chosen filename
-		QString selectedFile();
+		QString selectedFile() const;
 
 	protected:
 		// true id there is "scripter extensions" feature enabled
-		bool m_extEnable;
+		bool m_extEnable { false };
 
 		static QString m_lastScriptDir;
 
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/scriptercore.cpp scribus16x/scribus/plugins/scriptplugin/scriptercore.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/scriptercore.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/scriptercore.cpp	2025-01-04 10:59:06.319376741 +0100
@@ -203,9 +203,8 @@ void ScripterCore::runScriptDialog()
 void ScripterCore::StdScript(const QString& baseFilename)
 {
 	QString pfad = ScPaths::instance().scriptDir();
-	QString pfad2;
-	pfad2 = QDir::toNativeSeparators(pfad);
-	QString fn = pfad2+baseFilename+".py";
+	QString pfad2 = QDir::toNativeSeparators(pfad);
+	QString fn = pfad2 + baseFilename + ".py";
 	QFileInfo fd(fn);
 	if (!fd.exists())
 		return;
@@ -250,7 +249,7 @@ void ScripterCore::slotRunScriptFile(con
 		ScCore->primaryMainWindow()->contentPalette->unsetDoc();
 		ScCore->primaryMainWindow()->pagePalette->setView(nullptr);
 		ScCore->primaryMainWindow()->setScriptRunning(true);
-		qApp->setOverrideCursor(QCursor(Qt::WaitCursor));
+		QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
 		// Create the sub-interpreter
 		// FIXME: This calls abort() in a Python debug build. We're doing something wrong.
 		//stateo = PyEval_SaveThread();
@@ -279,7 +278,7 @@ void ScripterCore::slotRunScriptFile(con
 	delete[] comm;
 	
 	// call python script
-	PyObject* m = PyImport_AddModule((char*)"__main__");
+	PyObject* m = PyImport_AddModule("__main__");
 	if (m == nullptr)
 		qDebug("Failed to get __main__ - aborting script");
 	else
@@ -334,7 +333,7 @@ void ScripterCore::slotRunScriptFile(con
 		// other return value (most likely None anyway) and can ignore it.
 		if (result == nullptr)
 		{
-			PyObject* errorMsgPyStr = PyMapping_GetItemString(globals, (char*)"_errorMsg");
+			PyObject* errorMsgPyStr = PyMapping_GetItemString(globals, "_errorMsg");
 			if (errorMsgPyStr == nullptr)
 			{
 				// It's rather unlikely that this will ever be reached - to get here
@@ -350,7 +349,7 @@ void ScripterCore::slotRunScriptFile(con
 				QClipboard *cp = QApplication::clipboard();
 				cp->setText(errorMsg);
 				ScCore->closeSplash();
-				qApp->changeOverrideCursor(QCursor(Qt::ArrowCursor));
+				QApplication::changeOverrideCursor(QCursor(Qt::ArrowCursor));
 				ScMessageBox::warning(ScCore->primaryMainWindow(),
 									tr("Script error"),
 									"<qt><p>"
@@ -370,7 +369,7 @@ void ScripterCore::slotRunScriptFile(con
 		Py_EndInterpreter(state);
 		PyThreadState_Swap(global_state);
 		//PyEval_RestoreThread(stateo);
-		qApp->restoreOverrideCursor();
+		QApplication::restoreOverrideCursor();
 		ScCore->primaryMainWindow()->setScriptRunning(false);
 	}
 
@@ -439,7 +438,7 @@ void ScripterCore::slotRunScript(const Q
 	comm[0] = const_cast<char*>("scribus");
 	PySys_SetArgv(1, comm); */
 	// then run the code
-	PyObject* m = PyImport_AddModule((char*)"__main__");
+	PyObject* m = PyImport_AddModule("__main__");
 	if (m == nullptr)
 		qDebug("Failed to get __main__ - aborting script");
 	else
@@ -539,7 +538,7 @@ void ScripterCore::aboutScript()
 	if (fname.isNull())
 		return;
 	QString html("<html><body>");
-	QFileInfo fi = QFileInfo(fname);
+	QFileInfo fi(fname);
 	QFile input(fname);
 	if (!input.open(QIODevice::ReadOnly))
 		return;
@@ -570,7 +569,7 @@ void ScripterCore::initExtensionScripts(
 
 void ScripterCore::runStartupScript()
 {
-	if ((m_enableExtPython) && (!m_startupScript.isEmpty()))
+	if (m_enableExtPython && !m_startupScript.isEmpty())
 	{
 		if (QFile::exists(this->m_startupScript))
 		{
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/scriptplugin.cpp scribus16x/scribus/plugins/scriptplugin/scriptplugin.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/scriptplugin.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/scriptplugin.cpp	2025-01-04 10:59:06.320376720 +0100
@@ -336,6 +336,8 @@ PyMethodDef scribus_methods[] = {
 	{ "getAllObjects", (PyCFunction) scribus_getallobjects, METH_VARARGS|METH_KEYWORDS, tr(scribus_getallobjects__doc__)},
 	{ "getAllStyles", (PyCFunction) scribus_getparagraphstyles, METH_NOARGS, tr(scribus_getallstyles__doc__)}, //Deprecated
 	{ "getAllText", scribus_getalltext, METH_VARARGS, tr(scribus_getalltext__doc__)},
+	{ "getBaseLine", (PyCFunction) scribus_getbaseline, METH_NOARGS, tr(scribus_getbaseline__doc__)},
+	{ "getBleeds", scribus_getbleeds, METH_NOARGS, tr(scribus_getbleeds__doc__)},
 	{ "getCellColumnSpan", scribus_getcellcolumnspan, METH_VARARGS, tr(scribus_getcellcolumnspan__doc__)},
 	{ "getCellFillColor", scribus_getcellfillcolor, METH_VARARGS, tr(scribus_getcellfillcolor__doc__)},
 	{ "getCellRowSpan", scribus_getcellrowspan, METH_VARARGS, tr(scribus_getcellrowspan__doc__)},
@@ -391,6 +393,7 @@ PyMethodDef scribus_methods[] = {
 	{ "getLineStyles", (PyCFunction) scribus_getlinestyles, METH_VARARGS, tr(scribus_getlinestyles__doc__)},
 	{ "getLineTransparency", scribus_getlinetransparency, METH_VARARGS, tr(scribus_getlinetransparency__doc__)},
 	{ "getLineWidth", scribus_getlinewidth, METH_VARARGS, tr(scribus_getlinewidth__doc__)},
+	{ "getMargins", scribus_getmargins, METH_NOARGS, tr(scribus_getmargins__doc__) },
 	{ "getMasterPage", scribus_getmasterpage, METH_VARARGS, tr(scribus_getmasterpage__doc__)},
 	{ "getNextLinkedFrame", scribus_getnextlinkedframe, METH_VARARGS, tr(scribus_getnextlinkedframe__doc__)},
 	{ "getObjectAttributes", scribus_getobjectattributes, METH_VARARGS, tr(scribus_getobjectattributes__doc__)},
@@ -427,6 +430,9 @@ PyMethodDef scribus_methods[] = {
 	{ "getTextShade", scribus_gettextshade, METH_VARARGS, tr(scribus_gettextshade__doc__)},
 	{ "getTextVerticalAlignment", scribus_gettextverticalalignment, METH_VARARGS, tr(scribus_gettextverticalalignment__doc__)},
 	{ "getUnit", (PyCFunction) scribus_getunit, METH_NOARGS, tr(scribus_getunit__doc__)},
+	{ "pointsToDocUnit", scribus_pointstodocunit, METH_VARARGS, tr(scribus_pointstodocunit__doc__)},
+	{ "docUnitToPoints", scribus_docunittopoints, METH_VARARGS, tr(scribus_docunittopoints__doc__)},
+	{ "stringValueToPoints", scribus_stringvaluetopoints, METH_VARARGS, tr(scribus_stringvaluetopoints__doc__)},
 	{ "getVGuides", (PyCFunction) scribus_getVguides, METH_NOARGS, tr(scribus_getVguides__doc__)},
 	{ "getXFontNames", (PyCFunction) scribus_xfontnames, METH_NOARGS, tr(scribus_xfontnames__doc__)},
 	{ "gotoPage", scribus_gotopage, METH_VARARGS, tr(scribus_gotopage__doc__)},
@@ -1073,5 +1079,16 @@ PV */
 void scriptplugindocwarnings()
 {
 	QStringList s;
-	s <<printer__doc__<<pdffile__doc__<<imgexp__doc__<<imgexp_dpi__doc__<<imgexp_scale__doc__ << imgexp_transparentBkgnd__doc__ <<imgexp_quality__doc__<<imgexp_filename__doc__<<imgexp_type__doc__<<imgexp_alltypes__doc__ << imgexp_save__doc__ << imgexp_saveas__doc__;
+	s << imgexp__doc__
+	  << imgexp_alltypes__doc__
+	  << imgexp_dpi__doc__
+	  << imgexp_filename__doc__
+	  << imgexp_quality__doc__
+	  << imgexp_save__doc__
+	  << imgexp_saveas__doc__
+	  << imgexp_scale__doc__
+	  << imgexp_transparentBkgnd__doc__
+	  << imgexp_type__doc__
+	  << pdffile__doc__
+	  << printer__doc__;
 }
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/scripts/FrenchAutotypo.py scribus16x/scribus/plugins/scriptplugin/scripts/FrenchAutotypo.py
--- scribus-1.6.2/scribus/plugins/scriptplugin/scripts/FrenchAutotypo.py	1970-01-01 01:00:00.000000000 +0100
+++ scribus16x/scribus/plugins/scriptplugin/scripts/FrenchAutotypo.py	2025-01-04 10:59:06.320376720 +0100
@@ -0,0 +1,415 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+# File: fr_autotypo².py Version : 1.1.3 - 2023 10 18
+# Fixes typewriter, single and double quotes along with their leading and following spaces 
+# + fixes double spaces everywhere 
+# + applies french typography (since default langage is french)
+#
+# © 2020.06 Creation of autotypo by JLuc 
+# following © 2013 autoquote2 enhancements by JLuc 
+# of © 2010 autoquote.py by Gregory Pittman 
+# and including 2023.10 fixes by Vincent
+#
+# For issues or enhancements, use https://bugs.scribus.net/view.php?id=16804
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+
+# INPUTS
+# - choose a text frame, launch script
+# - it defaults to french but altering the script enables to choose other language or painfull interactive mode
+# - default space to add for typography is thin nonbreakable space. 
+# - existing spaces should be replaced
+# - multiple spaces should be merged into single space
+# FEATURES
+# - replaces " with « and » as required
+# - warns when « and » dont match or for other such issues
+# - adds choosen spaces after « and before »
+# - applies some heuristics (some would call that AI) to best deal with ' and "
+# - replace multiple following spaces with just one
+# - when langages is french, does more typography job :
+# - - replaces or adds the choosen space before ! ? ; : and …
+# - - doesnt mess urls = doesnt change http://scribus.net
+# - - only adds one choosen space before a set of double spaces as !!!?!
+# - provides a just-go-ahead-dont-ask-for-options mode for geeks : juste change do_ask value to False in script
+# LIMITS
+# - recognizes urls with "p:/" or "ww." patterns (=> possible false positive)
+# - same choosen space for « » ; ! ; : …
+# - space is added or replaced with absolutely no local-font awareness
+# - only manages selected frame and doesnt follow links accross linked text frames <-- PR wanted
+
+import scribus
+
+non_breaking_space = u"\u00a0"
+non_breaking_thin_space = u"\u202f"
+thin_space = u"\u2009"
+ensure_space_before_list = '»;!?:…€%';
+
+# Comment whichever line you wish to avoid
+# do_ask = True
+do_ask=False
+
+# default values when not asking
+lang='fr'
+space_character=non_breaking_thin_space
+space_len=1
+replace_existing=True
+merge_spaces=True
+do_hyphenate=True
+with_feedback=False
+
+if do_ask:
+	do_hyphenate=False
+	with_feedback=True
+
+def is_a_space(text):
+    return (text == ' ') or (text == non_breaking_space) or (text == non_breaking_thin_space) or (text == thin_space)
+
+def ensure_space_before(char):
+    return (lang == 'fr') and (char in ensure_space_before_list );
+
+if scribus.haveDoc() <= 0:
+    scribus.messageBox('Error - (fr) Erreur', 'You need a Document open\n(fr) Ouvrez un document avant de lancer le script', scribus.ICON_WARNING, scribus.BUTTON_OK)
+    sys.exit(2)
+
+#
+# First choice for langage
+#
+if do_ask:
+    lang = scribus.valueDialog("Language", 'Choose language or country\nChoisissez la langue du texte ou le pays :\n  af, be, ch, cs, de, de-g, en, es, et, fi, fr,\n  hu, is, lt, mk, nl, pl, ru, se, sk, sl, sq and uk', 'fr')
+
+if (lang == 'en'):
+    lead_double = u"\u201c" #lead_double
+    follow_double = u"\u201d" #follow_double
+    lead_single = u"\u2018"
+    follow_single = u"\u2019"
+elif (lang == 'de'):
+    lead_double = u"\u201e"
+    follow_double = u"\u201c"
+    lead_single = u"\u2019"
+    follow_single = u"\u201a"
+elif (lang == 'de-g'):          # German with inverted guillemets for double quote
+    lead_double = u"\u00bb"
+    follow_double = u"\u00ab"
+    lead_single = u"\u2019"
+    follow_single = u"\u201a"
+elif (lang == 'fr'):
+    lead_double = u"\u00ab"  #  &laquo; LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
+    follow_double = u"\u00bb"  #  &raquo; LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
+    lead_single = u"\u2018"     # RIGHT SINGLE QUOTATION MARK
+    follow_single = u"\u2019"   # LEFT SINGLE QUOTATION MARK
+elif (lang == 'pl'):
+    lead_double = u"\u201e"
+    follow_double = u"\u201d"
+    lead_single = u"\u201a"
+    follow_single = u"\u2019"
+elif ((lang == 'se') or (lang == 'fi')):
+    lead_double = u"\u201d"
+    follow_double = u"\u201d"
+    lead_single = u"\u2019"
+    follow_single = u"\u2019"
+elif (lang == 'af'):
+    lead_double = u"\u201c"
+    follow_double = u"\u201d"
+    lead_single = u"\u2018"
+    follow_single = u"\u2019"
+elif (lang == 'sq'):
+    lead_double = u"\u201e"
+    follow_double = u"\u201c"
+    lead_single = u"\u2018"
+    follow_single = u"\u2019"
+elif ((lang == 'be') or (lang == 'ch') or (lang == 'uk') or (lang == 'ru')):
+    lead_double = u"\u00ab"
+    follow_double = u"\u00bb"
+    lead_single = u"\u2039"
+    follow_single = u"\u203a"
+elif (lang == 'uk'):
+    lead_double = u"\u00ab"
+    follow_double = u"\u00bb"
+    lead_single = u"\u2039"
+    follow_single = u"\u203a"
+elif (lang == 'es'):
+    lead_double = u"\u00ab"
+    follow_double = u"\u00bb"
+    lead_single = u"\u2018"
+    follow_double = u"\u2019"
+elif ((lang == 'lt') or (lang == 'is') or (lang == 'sk') or (lang == 'sl') or (lang == 'cs') or (lang == 'et')):
+    lead_double = u"\u201e"
+    follow_double = u"\u201c"
+    lead_single = u"\u201a"
+    follow_single = u"\u2018"
+elif (lang == 'mk'):
+    lead_double = u"\u201e"
+    follow_double = u"\u201c"
+    lead_single = u"\u2019"
+    follow_single = u"\u2018"
+elif ((lang == 'hu') or (lang == 'nl')):
+    lead_double = u"\u201e"
+    follow_double = u"\u201d"
+    lead_single = u"\u00bb"
+    follow_single = u"\u00ab"
+else:
+    scribus.messageBox('Language Error', 'You need to choose an available language', scribus.ICON_WARNING, scribus.BUTTON_OK)
+    sys.exit(2)
+
+if scribus.selectionCount() == 0:
+    if (lang == 'fr'):
+        scribus.messageBox('Scribus - Erreur',
+            "Aucun objet n'est sélectionné.\nSélectionnez un cadre de texte et recommencez.",
+            scribus.ICON_WARNING, scribus.BUTTON_OK)
+    else:
+        scribus.messageBox('Scribus - Usage Error',
+            "There is no object selected.\nPlease select a text frame and try again.",
+            scribus.ICON_WARNING, scribus.BUTTON_OK)
+    sys.exit(2)
+
+if scribus.selectionCount() > 1:
+    if (lang == 'fr'):
+        scribus.messageBox('Scribus - Erreur',
+            "Désolé, ce script ne peut pas fonctionner lorsque plusieurs objets sont sélectionnés.\nVeuillez sélectionner un seul cadre de texte, puis recommencez.",
+            scribus.ICON_WARNING, scribus.BUTTON_OK)
+    else:
+        scribus.messageBox('Scribus - Usage Error',
+            "You have more than one object selected.\nPlease select one text frame and try again.", scribus.ICON_WARNING, scribus.BUTTON_OK)
+    sys.exit(2)
+
+# Following dialogs are i18ned
+if do_ask:
+  if (lang =='fr'):
+    space_type = scribus.valueDialog("Type d'espace",
+                "Selon les polices de caractère utilisées,\nchoisissez le type d'espace ajouté avec les doubles guillemets français\net avant les signes doubles :\n  0 : aucun espace ajouté\n  1 : insécable fine\n  2 : insécable\n  3 : fine",
+                '1')
+  else:
+    space_type = scribus.valueDialog("Inside quote added space",
+                "Depending on the used fonts, choose the space to be added inside \ndouble quotes, in case there are none already.\n  0 : dont add a space\n  1 : non breaking thin\n  2 : non breaking\n  3 : thin",
+                '0')
+
+  if (space_type == '3'):
+    space_character = thin_space
+    space_len = 1
+  elif (space_type == '1'):
+    space_character = non_breaking_thin_space
+    space_len = 1
+  elif (space_type == '0'):
+    space_character = ''
+    space_len = 0
+  else:
+    space_character = non_breaking_space
+    space_len = 1
+
+  if (lang =='fr'):
+    replace_existing = scribus.valueDialog("Agir sur l'existant ?",
+            "Voulez vous aussi appliquer votre choix d'espaces sur les espaces déjà en place pour les double-guillemets et signes doubles (si cette option est retenue) ?\n  O : Oui\n  N : Non ",
+            'O')
+  else:
+    replace_existing = scribus.valueDialog("What about existing quotes ?",
+            "Should the script ALSO apply your spaces-choice on already existing quotes?\n  Y : Yes\n  N : No",
+            'N')
+  if (replace_existing == 'n') or (replace_existing == 'N'):
+    replace_existing=False
+  else:
+    replace_existing=True
+
+  if (lang =='fr'):
+    merge_spaces = scribus.valueDialog("Espaces multiples",
+      "Voulez vous dédoublonner les espaces qui se suivent ?\n  O : Oui\n  N : Non ",
+      'O')
+  else:
+    merge_spaces = scribus.valueDialog("Space'n'spaces",
+      "Do you want to merge spaces ?\n  Y : Yes\n  N : No ",
+      'Y')
+  if (merge_spaces == 'N') or (merge_spaces == 'n'):
+    merge_spaces = False
+  else:
+    merge_spaces = True
+
+textbox = scribus.getSelectedObject()
+boxcount = 1
+
+for item in scribus.getPageItems():
+    if (item[0] == textbox):
+        if (item[1] != 4):
+            if (lang == 'fr'):
+                scribus.messageBox('Scribus - Erreur',
+                "L'objet sélectionné n'est pas un cadre de texte.\nVeuillez sélectionner un cadre de texte, puis recommencez.",
+                scribus.ICON_WARNING, scribus.BUTTON_OK)
+            else:
+                scribus.messageBox('Scribus - Usage Error', "This is not a textframe. Try again.", scribus.ICON_WARNING, scribus.BUTTON_OK)
+               
+            sys.exit(2)
+           
+textlen = scribus.getTextLength(textbox)
+c = 0
+nbchange = 0
+quotes_lastchange = 'close' # la prochaine quote doit être ouvrante
+prevchar = ' '
+is_in_url = False
+
+if do_hyphenate:
+    scribus.hyphenateText();
+
+while c <= (textlen - 1):
+    # si on est à la fin, il faut tricher pour le dernier caractère
+    if ((c + 1) > textlen - 1):
+        end_reached = True
+        nextchar = ' '
+    else:
+        end_reached = False
+        scribus.selectText(c+1, 1, textbox)
+        nextchar = scribus.getText(textbox)
+       
+    scribus.selectText(c, 1, textbox)
+    char = scribus.getText(textbox)
+#    scribus.messageBox("Ce qui est", "position:"+str(c) +'\nchar'+str(char)+'\nPrec:'+str(prevchar)+'\nsuiv:'+str(nextchar),
+#          scribus.ICON_WARNING, scribus.BUTTON_OK)
+
+    if (char==lead_double):
+        if (quotes_lastchange=='open'):
+            if (lang=='fr'):
+                scribus.messageBox("Oups !", 'Incohérence dans les enchaînements de guillemets ouvrant et fermant. Un guillemet fermant manque avant la position '+str(c) +'\nOn continue quand même',
+                        scribus.ICON_WARNING, scribus.BUTTON_OK)
+            else:
+                scribus.messageBox("Oops !", 'The text is not consistent. Closing doublequote missing before position '+str(c),
+                        scribus.ICON_WARNING, scribus.BUTTON_OK)
+        quotes_lastchange='open'
+        if (replace_existing and (nextchar != space_character) and (not end_reached)):
+            if (is_a_space(nextchar)):
+                scribus.selectText(c+1, 1, textbox)
+                scribus.deleteText(textbox)
+            scribus.insertText(space_character, c+1, textbox)
+            nbchange = nbchange+1
+
+    elif (char==follow_double):
+        if (quotes_lastchange=='close'):
+            if (lang=='fr'):
+                scribus.messageBox("Oups !", 'Incohérence dans les enchaînements de guillemets ouvrant et fermant. Un guillemet ouvrant manque avant la position '+str(c) +'\nOn continue quand même',
+                        scribus.ICON_WARNING, scribus.BUTTON_OK)
+            else:
+                scribus.messageBox("Oops !", 'The text is not consistent. Opening doublequote missing before position '+str(c),
+                        scribus.ICON_WARNING, scribus.BUTTON_OK)
+        quotes_lastchange = 'close'
+        if (replace_existing  and (prevchar != space_character) and (c > 1)):
+            if (is_a_space(prevchar)):
+                scribus.selectText(c-1, 1, textbox)
+                scribus.deleteText(textbox)
+                c=c-1
+            scribus.insertText(space_character, c, textbox)
+            nbchange = nbchange+1
+            c=c+space_len
+   
+    elif (len(char) != 1):         # en utf8 certains caractères ont len 2, par ex les espaces spéciaux qu'on teste au dessus
+         do_nothing = "nothing_at_all"      # et ça ferait planter ord()
+         
+    elif (char == '"'): # autrement dit : ord (char)==34
+        #si on trouve une double guillemet droit " en premier caractère du texte, c'est un ouvrant !
+        if (c == 0):
+            scribus.deleteText(textbox)
+            if (not is_a_space(nextchar)):
+                scribus.insertText(space_character, 0, textbox)
+            scribus.insertText(lead_double, 0, textbox)
+            quotes_lastchange='open'
+        elif ((prevchar == '.') or (prevchar == ',') or (prevchar == '?') or (prevchar == '!')):
+         # lets close after the end of a sentence
+            scribus.deleteText(textbox)
+            scribus.insertText(follow_double, c, textbox)
+            scribus.insertText(space_character, c, textbox)
+            quotes_lastchange='close'
+            c=c+space_len
+        # 39 = ' straight apostrophe
+        elif ((ord(prevchar) == 39) and ((nextchar != ' ') and (nextchar != ',') and (nextchar != ';') and (nextchar != '.'))):
+            scribus.deleteText(textbox)
+            if (not is_a_space(nextchar)):
+                scribus.insertText(space_character, c, textbox)
+            scribus.insertText(lead_double, c, textbox)
+            quotes_lastchange='open'
+        elif ((nextchar == '.') or (nextchar == ',') or (nextchar == ';')):
+            scribus.deleteText(textbox)
+            scribus.insertText(follow_double, c, textbox)
+            if (not is_a_space(prevchar)):
+                scribus.insertText(space_character, c, textbox)
+                c=c+space_len
+            quotes_lastchange='close'
+        elif (quotes_lastchange!='open'):
+            scribus.deleteText(textbox)
+            if (not is_a_space(nextchar)):
+                scribus.insertText(space_character, c, textbox)
+            scribus.insertText(lead_double, c, textbox)
+            quotes_lastchange='open'
+        else:
+            scribus.deleteText(textbox)
+            scribus.insertText(follow_double, c, textbox)
+            if (not is_a_space(prevchar)):
+                scribus.insertText(space_character, c, textbox)
+                c=c+space_len
+            quotes_lastchange='close'
+        nbchange = nbchange+1
+
+    elif (ord(char) == 39):                   # typewriter quote
+        if (c==0):                            # au tout début du texte
+            scribus.deleteText(textbox)
+            scribus.insertText(lead_single, c, textbox)
+            nbchange = nbchange+1    
+        if ((prevchar == '.') or (prevchar == ',') or (prevchar == '?') or (prevchar == '!')):
+            scribus.deleteText(textbox)
+            scribus.insertText(follow_single, c, textbox)
+        elif ((ord(prevchar) == 34) and ((nextchar != ' ') and (nextchar != ',') and (nextchar != '.'))):
+            # " puis ' puis espace, virgule ou point
+            scribus.deleteText(textbox)
+            scribus.insertText(lead_single, c, textbox)
+        elif ((prevchar != ' ') and (ord(prevchar) != 34) and (nextchar != ' ')):
+            scribus.deleteText(textbox)
+            scribus.insertText(follow_single, c, textbox)
+        elif ((prevchar == ' ') or ((nextchar != ' ') and (ord(nextchar) != 34))):
+            scribus.deleteText(textbox)
+            scribus.insertText(lead_single, c, textbox)
+        else:
+            scribus.deleteText(textbox)
+            scribus.insertText(follow_single, c, textbox)
+        nbchange = nbchange+1
+
+    elif (c>0) and ensure_space_before(char):
+        if (not is_in_url):
+            is_in_url = ((prevchar=='p') and (char==':') and (nextchar=='/')) or ((prevchar=='w') and (char=='w') and (nextchar=='.'))
+                  
+        if (not is_in_url) and (prevchar != space_character) and (not ensure_space_before(prevchar)):
+
+            if (is_a_space(prevchar) and replace_existing):
+                c -= 1
+                scribus.selectText(c, 1, textbox)    
+                scribus.deleteText(textbox)        # deletes previous unwanted space
+                scribus.selectText(c, 1, textbox)    
+                scribus.insertText(space_character, c, textbox)
+                c += space_len
+                nbchange = nbchange+1
+                scribus.setRedraw(1)
+
+            elif (not is_a_space(prevchar)):
+                scribus.insertText(space_character, c, textbox)
+                c += space_len
+                nbchange = nbchange+1
+                scribus.setRedraw(1)
+
+    elif is_a_space(char):
+      is_in_url = False
+      if merge_spaces and is_a_space(nextchar): # only keeps last space of a set
+        scribus.deleteText(textbox)
+        c -= 1
+        nbchange = nbchange+1
+        scribus.setRedraw(1)
+
+    c += 1
+    prevchar = char
+    textlen = scribus.getTextLength(textbox)
+
+debugmessage = ''
+scribus.setRedraw(1)
+scribus.docChanged(1)
+if with_feedback:
+  if (lang == 'fr'):
+    scribus.messageBox("Fini", 'Les corrections typographiques ont été faites.\n'+str(nbchange)+' changements' + debugmessage,
+                        icon=scribus.ICON_NONE, button1=scribus.BUTTON_OK)
+  else:
+    scribus.messageBox("Done", 'Successfully ran script\n'+str(nbchange)+' replacements have occurred' + debugmessage, # Change this message to your liking
+                        icon=scribus.ICON_NONE, button1=scribus.BUTTON_OK)
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin/svgimport.cpp scribus16x/scribus/plugins/scriptplugin/svgimport.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin/svgimport.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin/svgimport.cpp	2025-01-04 10:59:06.319376741 +0100
@@ -33,7 +33,7 @@ PyObject *scribus_placevec(PyObject* /*
 		return nullptr;
 	QStringList allFormatsV = LoadSavePlugin::getExtensionsForImport(FORMATID_FIRSTUSER);
 	QString fName = QString::fromUtf8(image.c_str());
-	QFileInfo fi = QFileInfo(fName);
+	QFileInfo fi(fName);
 	QString ext = fi.suffix().toLower();
 	if (!allFormatsV.contains(ext))
 	{
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin_py2x/objimageexport.cpp scribus16x/scribus/plugins/scriptplugin_py2x/objimageexport.cpp
--- scribus-1.6.2/scribus/plugins/scriptplugin_py2x/objimageexport.cpp	2024-06-15 16:22:27.000000000 +0200
+++ scribus16x/scribus/plugins/scriptplugin_py2x/objimageexport.cpp	2025-01-04 10:59:06.822366243 +0100
@@ -160,14 +160,11 @@ static PyObject *ImageExport_save(ImageE
 	int dpi = qRound(100.0 / 2.54 * self->dpi);
 	im.setDotsPerMeterY(dpi);
 	im.setDotsPerMeterX(dpi);
-	if (!im.save(PyString_AsString(self->name), PyString_AsString(self->type)))
+	if (!im.save(PyString_AsString(self->name), PyString_AsString(self->type), self->quality))
 	{
 		PyErr_SetString(ScribusException, QObject::tr("Failed to export image", "python error").toLocal8Bit().constData());
 		return nullptr;
 	}
-// 	Py_INCREF(Py_True); // return True not None for backward compat
- //	return Py_True;
-//	Py_RETURN_TRUE;
 	return PyBool_FromLong(static_cast<long>(true));
 }
 
@@ -194,14 +191,11 @@ static PyObject *ImageExport_saveAs(Imag
 	int dpi = qRound(100.0 / 2.54 * self->dpi);
 	im.setDotsPerMeterY(dpi);
 	im.setDotsPerMeterX(dpi);
-	if (!im.save(value, PyString_AsString(self->type)))
+	if (!im.save(value, PyString_AsString(self->type), self->quality))
 	{
 		PyErr_SetString(ScribusException, QObject::tr("Failed to export image", "python error").toLocal8Bit().constData());
 		return nullptr;
 	}
-// 	Py_INCREF(Py_True); // return True not None for backward compat
- //	return Py_True;
-//	Py_RETURN_TRUE;
 	return PyBool_FromLong(static_cast<long>(true));
 }
 
diff -Naupr scribus-1.6.2/scribus/plugins/scriptplugin_py2x/scripts/FrenchAutotypo.py scribus16x/scribus/plugins/scriptplugin_py2x/scripts/FrenchAutotypo.py
--- scribus-1.6.2/scribus/plugins/scriptplugin_py2x/scripts/FrenchAutotypo.py	1970-01-01 01:00:00.000000000 +0100
+++ scribus16x/scribus/plugins/scriptplugin_py2x/scripts/FrenchAutotypo.py	2025-01-04 10:59:06.822366243 +0100
@@ -0,0 +1,415 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+# File: fr_autotypo².py Version : 1.1.3 - 2023 10 18
+# Fixes typewriter, single and double quotes along with their leading and following spaces 
+# + fixes double spaces everywhere 
+# + applies french typography (since default langage is french)
+#
+# © 2020.06 Creation of autotypo by JLuc 
+# following © 2013 autoquote2 enhancements by JLuc 
+# of © 2010 autoquote.py by Gregory Pittman 
+# and including 2023.10 fixes by Vincent
+#
+# For issues or enhancements, use https://bugs.scribus.net/view.php?id=16804
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+
+# INPUTS
+# - choose a text frame, launch script
+# - it defaults to french but altering the script enables to choose other language or painfull interactive mode
+# - default space to add for typography is thin nonbreakable space. 
+# - existing spaces should be replaced
+# - multiple spaces should be merged into single space
+# FEATURES
+# - replaces " with « and » as required
+# - warns when « and » dont match or for other such issues
+# - adds choosen spaces after « and before »
+# - applies some heuristics (some would call that AI) to best deal with ' and "
+# - replace multiple following spaces with just one
+# - when langages is french, does more typography job :
+# - - replaces or adds the choosen space before ! ? ; : and …
+# - - doesnt mess urls = doesnt change http://scribus.net
+# - - only adds one choosen space before a set of double spaces as !!!?!
+# - provides a just-go-ahead-dont-ask-for-options mode for geeks : juste change do_ask value to False in script
+# LIMITS
+# - recognizes urls with "p:/" or "ww." patterns (=> possible false positive)
+# - same choosen space for « » ; ! ; : …
+# - space is added or replaced with absolutely no local-font awareness
+# - only manages selected frame and doesnt follow links accross linked text frames <-- PR wanted
+
+import scribus
+
+non_breaking_space = u"\u00a0"
+non_breaking_thin_space = u"\u202f"
+thin_space = u"\u2009"
+ensure_space_before_list = '»;!?:…€%';
+
+# Comment whichever line you wish to avoid
+# do_ask = True
+do_ask=False
+
+# default values when not asking
+lang='fr'
+space_character=non_breaking_thin_space
+space_len=1
+replace_existing=True
+merge_spaces=True
+do_hyphenate=True
+with_feedback=False
+
+if do_ask:
+	do_hyphenate=False
+	with_feedback=True
+
+def is_a_space(text):
+    return (text == ' ') or (text == non_breaking_space) or (text == non_breaking_thin_space) or (text == thin_space)
+
+def ensure_space_before(char):
+    return (lang == 'fr') and (char in ensure_space_before_list );
+
+if scribus.haveDoc() <= 0:
+    scribus.messageBox('Error - (fr) Erreur', 'You need a Document open\n(fr) Ouvrez un document avant de lancer le script', scribus.ICON_WARNING, scribus.BUTTON_OK)
+    sys.exit(2)
+
+#
+# First choice for langage
+#
+if do_ask:
+    lang = scribus.valueDialog("Language", 'Choose language or country\nChoisissez la langue du texte ou le pays :\n  af, be, ch, cs, de, de-g, en, es, et, fi, fr,\n  hu, is, lt, mk, nl, pl, ru, se, sk, sl, sq and uk', 'fr')
+
+if (lang == 'en'):
+    lead_double = u"\u201c" #lead_double
+    follow_double = u"\u201d" #follow_double
+    lead_single = u"\u2018"
+    follow_single = u"\u2019"
+elif (lang == 'de'):
+    lead_double = u"\u201e"
+    follow_double = u"\u201c"
+    lead_single = u"\u2019"
+    follow_single = u"\u201a"
+elif (lang == 'de-g'):          # German with inverted guillemets for double quote
+    lead_double = u"\u00bb"
+    follow_double = u"\u00ab"
+    lead_single = u"\u2019"
+    follow_single = u"\u201a"
+elif (lang == 'fr'):
+    lead_double = u"\u00ab"  #  &laquo; LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
+    follow_double = u"\u00bb"  #  &raquo; LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
+    lead_single = u"\u2018"     # RIGHT SINGLE QUOTATION MARK
+    follow_single = u"\u2019"   # LEFT SINGLE QUOTATION MARK
+elif (lang == 'pl'):
+    lead_double = u"\u201e"
+    follow_double = u"\u201d"
+    lead_single = u"\u201a"
+    follow_single = u"\u2019"
+elif ((lang == 'se') or (lang == 'fi')):
+    lead_double = u"\u201d"
+    follow_double = u"\u201d"
+    lead_single = u"\u2019"
+    follow_single = u"\u2019"
+elif (lang == 'af'):
+    lead_double = u"\u201c"
+    follow_double = u"\u201d"
+    lead_single = u"\u2018"
+    follow_single = u"\u2019"
+elif (lang == 'sq'):
+    lead_double = u"\u201e"
+    follow_double = u"\u201c"
+    lead_single = u"\u2018"
+    follow_single = u"\u2019"
+elif ((lang == 'be') or (lang == 'ch') or (lang == 'uk') or (lang == 'ru')):
+    lead_double = u"\u00ab"
+    follow_double = u"\u00bb"
+    lead_single = u"\u2039"
+    follow_single = u"\u203a"
+elif (lang == 'uk'):
+    lead_double = u"\u00ab"
+    follow_double = u"\u00bb"
+    lead_single = u"\u2039"
+    follow_single = u"\u203a"
+elif (lang == 'es'):
+    lead_double = u"\u00ab"
+    follow_double = u"\u00bb"
+    lead_single = u"\u2018"
+    follow_double = u"\u2019"
+elif ((lang == 'lt') or (lang == 'is') or (lang == 'sk') or (lang == 'sl') or (lang == 'cs') or (lang == 'et')):
+    lead_double = u"\u201e"
+    follow_double = u"\u201c"
+    lead_single = u"\u201a"
+    follow_single = u"\u2018"
+elif (lang == 'mk'):
+    lead_double = u"\u201e"
+    follow_double = u"\u201c"
+    lead_single = u"\u2019"
+    follow_single = u"\u2018"
+elif ((lang == 'hu') or (lang == 'nl')):
+    lead_double = u"\u201e"
+    follow_double = u"\u201d"
+    lead_single = u"\u00bb"
+    follow_single = u"\u00ab"
+else:
+    scribus.messageBox('Language Error', 'You need to choose an available language', scribus.ICON_WARNING, scribus.BUTTON_OK)
+    sys.exit(2)
+
+if scribus.selectionCount() == 0:
+    if (lang == 'fr'):
+        scribus.messageBox('Scribus - Erreur',
+            "Aucun objet n'est sélectionné.\nSélectionnez un cadre de texte et recommencez.",
+            scribus.ICON_WARNING, scribus.BUTTON_OK)
+    else:
+        scribus.messageBox('Scribus - Usage Error',
+            "There is no object selected.\nPlease select a text frame and try again.",
+            scribus.ICON_WARNING, scribus.BUTTON_OK)
+    sys.exit(2)
+
+if scribus.selectionCount() > 1:
+    if (lang == 'fr'):
+        scribus.messageBox('Scribus - Erreur',
+            "Désolé, ce script ne peut pas fonctionner lorsque plusieurs objets sont sélectionnés.\nVeuillez sélectionner un seul cadre de texte, puis recommencez.",
+            scribus.ICON_WARNING, scribus.BUTTON_OK)
+    else:
+        scribus.messageBox('Scribus - Usage Error',
+            "You have more than one object selected.\nPlease select one text frame and try again.", scribus.ICON_WARNING, scribus.BUTTON_OK)
+    sys.exit(2)
+
+# Following dialogs are i18ned
+if do_ask:
+  if (lang =='fr'):
+    space_type = scribus.valueDialog("Type d'espace",
+                "Selon les polices de caractère utilisées,\nchoisissez le type d'espace ajouté avec les doubles guillemets français\net avant les signes doubles :\n  0 : aucun espace ajouté\n  1 : insécable fine\n  2 : insécable\n  3 : fine",
+                '1')
+  else:
+    space_type = scribus.valueDialog("Inside quote added space",
+                "Depending on the used fonts, choose the space to be added inside \ndouble quotes, in case there are none already.\n  0 : dont add a space\n  1 : non breaking thin\n  2 : non breaking\n  3 : thin",
+                '0')
+
+  if (space_type == '3'):
+    space_character = thin_space
+    space_len = 1
+  elif (space_type == '1'):
+    space_character = non_breaking_thin_space
+    space_len = 1
+  elif (space_type == '0'):
+    space_character = ''
+    space_len = 0
+  else:
+    space_character = non_breaking_space
+    space_len = 1
+
+  if (lang =='fr'):
+    replace_existing = scribus.valueDialog("Agir sur l'existant ?",
+            "Voulez vous aussi appliquer votre choix d'espaces sur les espaces déjà en place pour les double-guillemets et signes doubles (si cette option est retenue) ?\n  O : Oui\n  N : Non ",
+            'O')
+  else:
+    replace_existing = scribus.valueDialog("What about existing quotes ?",
+            "Should the script ALSO apply your spaces-choice on already existing quotes?\n  Y : Yes\n  N : No",
+            'N')
+  if (replace_existing == 'n') or (replace_existing == 'N'):
+    replace_existing=False
+  else:
+    replace_existing=True
+
+  if (lang =='fr'):
+    merge_spaces = scribus.valueDialog("Espaces multiples",
+      "Voulez vous dédoublonner les espaces qui se suivent ?\n  O : Oui\n  N : Non ",
+      'O')
+  else:
+    merge_spaces = scribus.valueDialog("Space'n'spaces",
+      "Do you want to merge spaces ?\n  Y : Yes\n  N : No ",
+      'Y')
+  if (merge_spaces == 'N') or (merge_spaces == 'n'):
+    merge_spaces = False
+  else:
+    merge_spaces = True
+
+textbox = scribus.getSelectedObject()
+boxcount = 1
+
+for item in scribus.getPageItems():
+    if (item[0] == textbox):
+        if (item[1] != 4):
+            if (lang == 'fr'):
+                scribus.messageBox('Scribus - Erreur',
+                "L'objet sélectionné n'est pas un cadre de texte.\nVeuillez sélectionner un cadre de texte, puis recommencez.",
+                scribus.ICON_WARNING, scribus.BUTTON_OK)
+            else:
+                scribus.messageBox('Scribus - Usage Error', "This is not a textframe. Try again.", scribus.ICON_WARNING, scribus.BUTTON_OK)
+               
+            sys.exit(2)
+           
+textlen = scribus.getTextLength(textbox)
+c = 0
+nbchange = 0
+quotes_lastchange = 'close' # la prochaine quote doit être ouvrante
+prevchar = ' '
+is_in_url = False
+
+if do_hyphenate:
+    scribus.hyphenateText();
+
+while c <= (textlen - 1):
+    # si on est à la fin, il faut tricher pour le dernier caractère
+    if ((c + 1) > textlen - 1):
+        end_reached = True
+        nextchar = ' '
+    else:
+        end_reached = False
+        scribus.selectText(c+1, 1, textbox)
+        nextchar = scribus.getText(textbox)
+       
+    scribus.selectText(c, 1, textbox)
+    char = scribus.getText(textbox)
+#    scribus.messageBox("Ce qui est", "position:"+str(c) +'\nchar'+str(char)+'\nPrec:'+str(prevchar)+'\nsuiv:'+str(nextchar),
+#          scribus.ICON_WARNING, scribus.BUTTON_OK)
+
+    if (char==lead_double):
+        if (quotes_lastchange=='open'):
+            if (lang=='fr'):
+                scribus.messageBox("Oups !", 'Incohérence dans les enchaînements de guillemets ouvrant et fermant. Un guillemet fermant manque avant la position '+str(c) +'\nOn continue quand même',
+                        scribus.ICON_WARNING, scribus.BUTTON_OK)
+            else:
+                scribus.messageBox("Oops !", 'The text is not consistent. Closing doublequote missing before position '+str(c),
+                        scribus.ICON_WARNING, scribus.BUTTON_OK)
+        quotes_lastchange='open'
+        if (replace_existing and (nextchar != space_character) and (not end_reached)):
+            if (is_a_space(nextchar)):
+                scribus.selectText(c+1, 1, textbox)
+                scribus.deleteText(textbox)
+            scribus.insertText(space_character, c+1, textbox)
+            nbchange = nbchange+1
+
+    elif (char==follow_double):
+        if (quotes_lastchange=='close'):
+            if (lang=='fr'):
+                scribus.messageBox("Oups !", 'Incohérence dans les enchaînements de guillemets ouvrant et fermant. Un guillemet ouvrant manque avant la position '+str(c) +'\nOn continue quand même',
+                        scribus.ICON_WARNING, scribus.BUTTON_OK)
+            else:
+                scribus.messageBox("Oops !", 'The text is not consistent. Opening doublequote missing before position '+str(c),
+                        scribus.ICON_WARNING, scribus.BUTTON_OK)
+        quotes_lastchange = 'close'
+        if (replace_existing  and (prevchar != space_character) and (c > 1)):
+            if (is_a_space(prevchar)):
+                scribus.selectText(c-1, 1, textbox)
+                scribus.deleteText(textbox)
+                c=c-1
+            scribus.insertText(space_character, c, textbox)
+            nbchange = nbchange+1
+            c=c+space_len
+   
+    elif (len(char) != 1):         # en utf8 certains caractères ont len 2, par ex les espaces spéciaux qu'on teste au dessus
+         do_nothing = "nothing_at_all"      # et ça ferait planter ord()
+         
+    elif (char == '"'): # autrement dit : ord (char)==34
+        #si on trouve une double guillemet droit " en premier caractère du texte, c'est un ouvrant !
+        if (c == 0):
+            scribus.deleteText(textbox)
+            if (not is_a_space(nextchar)):
+                scribus.insertText(space_character, 0, textbox)
+            scribus.insertText(lead_double, 0, textbox)
+            quotes_lastchange='open'
+        elif ((prevchar == '.') or (prevchar == ',') or (prevchar == '?') or (prevchar == '!')):
+         # lets close after the end of a sentence
+            scribus.deleteText(textbox)
+            scribus.insertText(follow_double, c, textbox)
+            scribus.insertText(space_character, c, textbox)
+            quotes_lastchange='close'
+            c=c+space_len
+        # 39 = ' straight apostrophe
+        elif ((ord(prevchar) == 39) and ((nextchar != ' ') and (nextchar != ',') and (nextchar != ';') and (nextchar != '.'))):
+            scribus.deleteText(textbox)
+            if (not is_a_space(nextchar)):
+                scribus.insertText(space_character, c, textbox)
+            scribus.insertText(lead_double, c, textbox)
+            quotes_lastchange='open'
+        elif ((nextchar == '.') or (nextchar == ',') or (nextchar == ';')):
+            scribus.deleteText(textbox)
+            scribus.insertText(follow_double, c, textbox)
+            if (not is_a_space(prevchar)):
+                scribus.insertText(space_character, c, textbox)
+                c=c+space_len
+            quotes_lastchange='close'
+        elif (quotes_lastchange!='open'):
+            scribus.deleteText(textbox)
+            if (not is_a_space(nextchar)):
+                scribus.insertText(space_character, c, textbox)
+            scribus.insertText(lead_double, c, textbox)
+            quotes_lastchange='open'
+        else:
+            scribus.deleteText(textbox)
+            scribus.insertText(follow_double, c, textbox)
+            if (not is_a_space(prevchar)):
+                scribus.insertText(space_character, c, textbox)
+                c=c+space_len
+            quotes_lastchange='close'
+        nbchange = nbchange+1
+
+    elif (ord(char) == 39):                   # typewriter quote
+        if (c==0):                            # au tout début du texte
+            scribus.deleteText(textbox)
+            scribus.insertText(lead_single, c, textbox)
+            nbchange = nbchange+1    
+        if ((prevchar == '.') or (prevchar == ',') or (prevchar == '?') or (prevchar == '!')):
+            scribus.deleteText(textbox)
+            scribus.insertText(follow_single, c, textbox)
+        elif ((ord(prevchar) == 34) and ((nextchar != ' ') and (nextchar != ',') and (nextchar != '.'))):
+            # " puis ' puis espace, virgule ou point
+            scribus.deleteText(textbox)
+            scribus.insertText(lead_single, c, textbox)
+        elif ((prevchar != ' ') and (ord(prevchar) != 34) and (nextchar != ' ')):
+            scribus.deleteText(textbox)
+            scribus.insertText(follow_single, c, textbox)
+        elif ((prevchar == ' ') or ((nextchar != ' ') and (ord(nextchar) != 34))):
+            scribus.deleteText(textbox)
+            scribus.insertText(lead_single, c, textbox)
+        else:
+            scribus.deleteText(textbox)
+            scribus.insertText(follow_single, c, textbox)
+        nbchange = nbchange+1
+
+    elif (c>0) and ensure_space_before(char):
+        if (not is_in_url):
+            is_in_url = ((prevchar=='p') and (char==':') and (nextchar=='/')) or ((prevchar=='w') and (char=='w') and (nextchar=='.'))
+                  
+        if (not is_in_url) and (prevchar != space_character) and (not ensure_space_before(prevchar)):
+
+            if (is_a_space(prevchar) and replace_existing):
+                c -= 1
+                scribus.selectText(c, 1, textbox)    
+                scribus.deleteText(textbox)        # deletes previous unwanted space
+                scribus.selectText(c, 1, textbox)    
+                scribus.insertText(space_character, c, textbox)
+                c += space_len
+                nbchange = nbchange+1
+                scribus.setRedraw(1)
+
+            elif (not is_a_space(prevchar)):
+                scribus.insertText(space_character, c, textbox)
+                c += space_len
+                nbchange = nbchange+1
+                scribus.setRedraw(1)
+
+    elif is_a_space(char):
+      is_in_url = False
+      if merge_spaces and is_a_space(nextchar): # only keeps last space of a set
+        scribus.deleteText(textbox)
+        c -= 1
+        nbchange = nbchange+1
+        scribus.setRedraw(1)
+
+    c += 1
+    prevchar = char
+    textlen = scribus.getTextLength(textbox)
+
+debugmessage = ''
+scribus.setRedraw(1)
+scribus.docChanged(1)
+if with_feedback:
+  if (lang == 'fr'):
+    scribus.messageBox("Fini", 'Les corrections typographiques ont été faites.\n'+str(nbchange)+' changements' + debugmessage,
+                        icon=scribus.ICON_NONE, button1=scribus.BUTTON_OK)
+  else:
+    scribus.messageBox("Done", 'Successfully ran script\n'+str(nbchange)+' replacements have occurred' + debugmessage, # Change this message to your liking
+                        icon=scribus.ICON_NONE, button1=scribus.BUTTON_OK)
diff -Naupr scribus-1.6.2/scribus/plugins/tools/2geomtools/meshdistortion/meshdistortiondialog.cpp scribus16x/scribus/plugins/tools/2geomtools/meshdistortion/meshdistortiondialog.cpp
--- scribus-1.6.2/scribus/plugins/tools/2geomtools/meshdistortion/meshdistortiondialog.cpp	2024-06-15 16:22:28.000000000 +0200
+++ scribus16x/scribus/plugins/tools/2geomtools/meshdistortion/meshdistortiondialog.cpp	2025-01-04 10:59:07.001362507 +0100
@@ -312,7 +312,7 @@ void MeshDistortionDialog::addItemsToSce
 						qmatrix.scale(-1, 1);
 					if (mirrorY)
 						qmatrix.scale(1, -1);
-					QImage pat = *doc->docPatterns[currItem->pattern()].getPattern();
+					QImage pat = doc->docPatterns[currItem->pattern()].getPattern();
 					QBrush brush(pat);
 					brush.setTransform(qmatrix);
 					pItem->setBrush(brush);
@@ -344,7 +344,7 @@ void MeshDistortionDialog::addItemsToSce
 					qmatrix.scale(-1, 1);
 				if (mirrorY)
 					qmatrix.scale(1, -1);
-				QImage pat = *doc->docPatterns[currItem->strokePattern()].getPattern();
+				QImage pat = doc->docPatterns[currItem->strokePattern()].getPattern();
 				QBrush brush(pat);
 				brush.setTransform(qmatrix);
 				pItem->setPen(QPen(brush, currItem->lineWidth(), currItem->lineStyle(), currItem->lineEnd(), currItem->lineJoin()));
diff -Naupr scribus-1.6.2/scribus/plugins/tools/lenseffects/lensdialog.cpp scribus16x/scribus/plugins/tools/lenseffects/lensdialog.cpp
--- scribus-1.6.2/scribus/plugins/tools/lenseffects/lensdialog.cpp	2024-06-15 16:22:28.000000000 +0200
+++ scribus16x/scribus/plugins/tools/lenseffects/lensdialog.cpp	2025-01-04 10:59:07.016362194 +0100
@@ -366,7 +366,7 @@ void LensDialog::addItemsToScene(Selecti
 						qmatrix.scale(-1, 1);
 					if (mirrorY)
 						qmatrix.scale(1, -1);
-					QImage pat = *doc->docPatterns[currItem->pattern()].getPattern();
+					QImage pat = doc->docPatterns[currItem->pattern()].getPattern();
 					QBrush brush(pat);
 					brush.setTransform(qmatrix);
 					pItem->setBrush(brush);
@@ -398,7 +398,7 @@ void LensDialog::addItemsToScene(Selecti
 					qmatrix.scale(-1, 1);
 				if (mirrorY)
 					qmatrix.scale(1, -1);
-				QImage pat = *doc->docPatterns[currItem->strokePattern()].getPattern();
+				QImage pat = doc->docPatterns[currItem->strokePattern()].getPattern();
 				QBrush brush(pat);
 				brush.setTransform(qmatrix);
 				pItem->setPen(QPen(brush, currItem->lineWidth(), currItem->lineStyle(), currItem->lineEnd(), currItem->lineJoin()));
diff -Naupr scribus-1.6.2/scribus/prefsfile.h scribus16x/scribus/prefsfile.h
--- scribus-1.6.2/scribus/prefsfile.h	2024-06-15 16:22:36.000000000 +0200
+++ scribus16x/scribus/prefsfile.h	2025-01-04 10:59:08.898322920 +0100
@@ -33,7 +33,7 @@ for which a new license (GPL+exception)
 #include "scribusapi.h"
 #include "prefscontext.h"
 
-typedef QMap<QString, PrefsContext*> ContextMap;
+using ContextMap = QMap<QString, PrefsContext*>;
 
 class SCRIBUS_API PrefsFile
 {
diff -Naupr scribus-1.6.2/scribus/prefsmanager.cpp scribus16x/scribus/prefsmanager.cpp
--- scribus-1.6.2/scribus/prefsmanager.cpp	2024-06-15 16:22:33.000000000 +0200
+++ scribus16x/scribus/prefsmanager.cpp	2025-01-04 10:59:08.676327553 +0100
@@ -296,7 +296,7 @@ void PrefsManager::initDefaults()
 	appPrefs.itemToolPrefs.imageAspectRatio = true;
 	appPrefs.itemToolPrefs.imageLowResType = 1;
 	appPrefs.itemToolPrefs.imageUseEmbeddedPath = false;
-//	appPrefs.PSize = 40;
+
 	appPrefs.printerPrefs.ClipMargin = false;
 	appPrefs.printerPrefs.GCRMode = false;
 	appPrefs.scrapbookPrefs.RecentScrapbooks.clear();
@@ -1096,14 +1096,14 @@ void PrefsManager::setLatexCommands(cons
 	appPrefs.extToolPrefs.latexCommands = commands;
 }
 
-bool PrefsManager::renderFrameConfigured()
+bool PrefsManager::renderFrameConfigured() const
 {
 	if (appPrefs.extToolPrefs.latexConfigs.isEmpty())
 		return false;
 	if (appPrefs.extToolPrefs.latexCommands.isEmpty())
 		return false;
 	bool foundAny = false;
-	foreach (QString cmd, appPrefs.extToolPrefs.latexCommands)
+	for (const QString& cmd : appPrefs.extToolPrefs.latexCommands)
 	{
 		QStringList args = splitCommandLineArgs(cmd);
 		if (args.isEmpty())
@@ -1691,7 +1691,7 @@ bool PrefsManager::writePref(const QStri
 	dcPreflightVerifier.setAttribute("ShowNonPrintingLayerErrors", appPrefs.verifierPrefs.showNonPrintingLayerErrors);
 	elem.appendChild(dcPreflightVerifier);
 
-	CheckerPrefsList::Iterator itcpend = appPrefs.verifierPrefs.checkerPrefsList.end();
+	auto itcpend = appPrefs.verifierPrefs.checkerPrefsList.end();
 	for (auto itcp = appPrefs.verifierPrefs.checkerPrefsList.begin(); itcp != itcpend; ++itcp)
 	{
 		QDomElement dcVerifierProfile = docu.createElement("VerifierProfile");
@@ -2020,18 +2020,20 @@ bool PrefsManager::readPref(const QStrin
 	m_firstTimeIgnoreOldPrefs = !prefs150FileFound;
 	if (!prefs150FileFound)
 		return false;
+
 	appPrefs.colorPrefs.DColors.clear();
 	ColorSetManager csm;
 	csm.initialiseDefaultPrefs(appPrefs);
 	csm.findPaletteLocations();
 	csm.findPalettes();
 	csm.findUserPalettes();
-	QDomNode DOC = elem.firstChild();
-	if (!DOC.namedItem("CheckProfile").isNull())
+
+	QDomNode domNode = elem.firstChild();
+	if (!domNode.namedItem("CheckProfile").isNull())
 		appPrefs.verifierPrefs.checkerPrefsList.clear();
-	while (!DOC.isNull())
+	while (!domNode.isNull())
 	{
-		ScDomElement dc = DOC.toElement();
+		ScDomElement dc = domNode.toElement();
 
 		if (dc.tagName() == "UI")
 		{
@@ -2079,7 +2081,6 @@ bool PrefsManager::readPref(const QStrin
 			appPrefs.docSetupPrefs.bleeds.setLeft(ScCLocale::toDoubleC(dc.attribute("BleedLeft"), 0.0));
 			appPrefs.docSetupPrefs.bleeds.setRight(ScCLocale::toDoubleC(dc.attribute("BleedRight"), 0.0));
 			appPrefs.docSetupPrefs.bleeds.setBottom(ScCLocale::toDoubleC(dc.attribute("BleedBottom"), 0.0));
-
 		}
 
 		if (dc.tagName() == "Miscellaneous")
@@ -2167,12 +2168,18 @@ bool PrefsManager::readPref(const QStrin
 			}
 			appPrefs.guidesPrefs.gridType = dc.attribute("GridType", "0").toInt();
 			appPrefs.guidesPrefs.gridShown = static_cast<bool>(dc.attribute("ShowGrid", "0").toInt());
-			if (dc.hasAttribute("GuideC"))
-				appPrefs.guidesPrefs.guideColor = QColor(dc.attribute("GuideC"));
-			if (dc.hasAttribute("GuideZ"))
+			if (dc.hasAttribute("GuideC")) // legacy < 1.7.x
+				appPrefs.guidesPrefs.guideColor = QColor(dc.attribute("GuideC", "#000080"));
+			if (dc.hasAttribute("GuidesColor"))
+				appPrefs.guidesPrefs.guideColor = QColor(dc.attribute("GuidesColor", "#000080"));
+			if (dc.hasAttribute("GuideZ")) // legacy
+				appPrefs.guidesPrefs.guideRad = ScCLocale::toDoubleC(dc.attribute("GuideZ"), 10.0);
+			if (dc.hasAttribute("ObjectToGuideSnapRadius"))
 				appPrefs.guidesPrefs.guideRad = ScCLocale::toDoubleC(dc.attribute("ObjectToGuideSnapRadius"), 10.0);
-			if (dc.hasAttribute("BaseC"))
-				appPrefs.guidesPrefs.baselineGridColor = QColor(dc.attribute("BaselineGridColor"));
+			if (dc.hasAttribute("BaseC")) // legacy < 1.7.x
+				appPrefs.guidesPrefs.baselineGridColor = QColor(dc.attribute("BaseC", "#c0c0c0"));
+			if (dc.hasAttribute("BaselineGridColor"))
+				appPrefs.guidesPrefs.baselineGridColor = QColor(dc.attribute("BaselineGridColor", "#c0c0c0"));
 			appPrefs.guidesPrefs.marginColor = QColor(dc.attribute("MarginColor", "#0000ff"));
 			appPrefs.guidesPrefs.valueBaselineGrid   = ScCLocale::toDoubleC(dc.attribute("BaselineGridDistance"), 12.0);
 			appPrefs.guidesPrefs.offsetBaselineGrid  = ScCLocale::toDoubleC(dc.attribute("BaselineGridOffset"), 0.0);
@@ -2378,7 +2385,7 @@ bool PrefsManager::readPref(const QStrin
 		if (dc.tagName() == "PageSets")
 		{
 			QList<PageSet> newPageSets;
-			for (QDomNode pgs = DOC.firstChild(); !pgs.isNull(); pgs = pgs.nextSibling())
+			for (QDomNode pgs = domNode.firstChild(); !pgs.isNull(); pgs = pgs.nextSibling())
 			{
 				QDomElement pgsAttr = pgs.toElement();
 				if (pgsAttr.tagName() != "Set")
@@ -2691,7 +2698,7 @@ bool PrefsManager::readPref(const QStrin
 			appPrefs.pdfPrefs.openAfterExport = static_cast<bool>(dc.attribute("openAfterExport", "0").toInt());
 			appPrefs.pdfPrefs.PageLayout = dc.attribute("PageLayout", "0").toInt();
 			appPrefs.pdfPrefs.openAction = dc.attribute("OpenAction", "");
-			QDomNode pfoNode = DOC.firstChild();
+			QDomNode pfoNode = domNode.firstChild();
 			appPrefs.pdfPrefs.LPISettings.clear();
 			while (!pfoNode.isNull())
 			{
@@ -2709,7 +2716,7 @@ bool PrefsManager::readPref(const QStrin
 		}
 		if (dc.tagName() == "DefaultItemAttributes")
 		{
-			QDomNode diaNode = DOC.firstChild();
+			QDomNode diaNode = domNode.firstChild();
 			appPrefs.itemAttrPrefs.defaultItemAttributes.clear();
 			while (!diaNode.isNull())
 			{
@@ -2731,7 +2738,7 @@ bool PrefsManager::readPref(const QStrin
 		}
 		if (dc.tagName() == "TablesOfContents")
 		{
-			QDomNode tocNode = DOC.firstChild();
+			QDomNode tocNode = domNode.firstChild();
 			appPrefs.tocPrefs.defaultToCSetups.clear();
 			while (!tocNode.isNull())
 			{
@@ -2775,8 +2782,7 @@ bool PrefsManager::readPref(const QStrin
 			appPrefs.experimentalFeaturePrefs.notesEnabled = static_cast<bool>(dc.attribute("NotesEnabled", "0").toInt());
 		}
 
-		//
-		DOC = DOC.nextSibling();
+		domNode = domNode.nextSibling();
 	}
 	// Some sanity checks
 	appPrefs.colorPrefs.DColors.ensureDefaultColors();
@@ -2784,22 +2790,9 @@ bool PrefsManager::readPref(const QStrin
 		appPrefs.docSetupPrefs.pagePositioning = 0;
 	if ((appPrefs.docSetupPrefs.docUnitIndex < UNITMIN) || (appPrefs.docSetupPrefs.docUnitIndex > UNITMAX))
 		appPrefs.docSetupPrefs.docUnitIndex = int(SC_POINTS);
-	// Configure GUI
+
 	appPrefs.ui_SystemTheme = QApplication::style()->objectName();
-	if (appPrefs.uiPrefs.style.length() > 0)
-	{
-		QStyle* qtStyle = nullptr;
-		QStringList availableStyles = QStyleFactory::keys();
-		if (availableStyles.contains(appPrefs.uiPrefs.style))
-			qtStyle = QStyleFactory::create(appPrefs.uiPrefs.style);
-		if (qtStyle)
-			QApplication::setStyle(qtStyle);
-		else
-			appPrefs.uiPrefs.style.clear();
-	}
-	QFont apf = QApplication::font();
-	apf.setPointSize(appPrefs.uiPrefs.applicationFontSize);
-	QApplication::setFont(apf);
+
 	return true;
 }
 
diff -Naupr scribus-1.6.2/scribus/prefsmanager.h scribus16x/scribus/prefsmanager.h
--- scribus-1.6.2/scribus/prefsmanager.h	2024-06-15 16:22:35.000000000 +0200
+++ scribus16x/scribus/prefsmanager.h	2025-01-04 10:59:08.679327490 +0100
@@ -129,7 +129,7 @@ public:
 	QString uniconvExecutable() const {return appPrefs.extToolPrefs.uniconvExecutable;}
 	QStringList latexConfigs() const {return appPrefs.extToolPrefs.latexConfigs;}
 	QMap<QString, QString> latexCommands() const {return appPrefs.extToolPrefs.latexCommands;}
-	bool renderFrameConfigured();
+	bool renderFrameConfigured() const;
 	QString latexEditorExecutable() const {return appPrefs.extToolPrefs.latexEditorExecutable;}
 	bool latexStartWithEmptyFrames() const {return appPrefs.extToolPrefs.latexStartWithEmptyFrames;}
 	//! \brief Get the users preferred preview resolution
diff -Naupr scribus-1.6.2/scribus/prefsstructs.h scribus16x/scribus/prefsstructs.h
--- scribus-1.6.2/scribus/prefsstructs.h	2024-06-15 16:22:35.000000000 +0200
+++ scribus16x/scribus/prefsstructs.h	2025-01-04 10:59:08.898322920 +0100
@@ -58,7 +58,7 @@ struct CheckerPrefs
 	bool checkEmptyTextFrames;
 };
 
-typedef QMap<QString, CheckerPrefs> CheckerPrefsList;
+using CheckerPrefsList = QMap<QString, CheckerPrefs>;
 
 struct VerifierPrefs
 {
diff -Naupr scribus-1.6.2/scribus/scfonts.cpp scribus16x/scribus/scfonts.cpp
--- scribus-1.6.2/scribus/scfonts.cpp	2024-06-15 16:22:33.000000000 +0200
+++ scribus16x/scribus/scfonts.cpp	2025-01-04 10:59:08.679327490 +0100
@@ -131,15 +131,16 @@ void SCFonts::addScalableFonts(const QSt
 	//QString()+/ is / of course.
 	if (path.isEmpty())
 		return;
-	FT_Library library = nullptr;
 	QString pathfile, fullpath;
-//	bool error;
-//	error =
+
+	FT_Library library = nullptr;
 	FT_Init_FreeType( &library );
+
 	QString pathname(path);
-	if ( !pathname.endsWith("/") )
+	if (!pathname.endsWith("/"))
 		pathname += "/";
 	pathname = QDir::toNativeSeparators(pathname);
+
 	QDir d(pathname, "*", QDir::Name, QDir::Dirs | QDir::Files | QDir::Readable);
 	if ((d.exists()) && (d.count() != 0))
 	{
@@ -315,7 +316,7 @@ void getSubFontType(FT_Face face, ScFace
 } 
 
 // sort name records so the preferred ones come first
-static bool nameComp(const FT_SfntName a, const FT_SfntName b)
+static bool nameComp(const FT_SfntName& a, const FT_SfntName& b)
 {
 	// sort preferred family first
 	if (a.name_id != b.name_id)
@@ -373,7 +374,7 @@ static bool nameComp(const FT_SfntName a
 	return false;
 }
 
-static QString decodeNameRecord(FT_SfntName name)
+static QString decodeNameRecord(const FT_SfntName& name)
 {
 	if (!name.string || name.string_len == 0)
 		return QString();
@@ -509,19 +510,21 @@ ScFace SCFonts::loadScalableFont(const Q
 	ScFace t;
 	if (filename.isEmpty())
 		return t;
+
 	FT_Library library = nullptr;
-	bool error;
-	error = FT_Init_FreeType( &library );
+	FT_Init_FreeType( &library );
+
 	QFileInfo fi(filename);
 	if (!fi.exists())
 		return t;
+
 	bool Subset = false;
 	char buf[128];
-	QString glyName = "";
+	QString glyName;
 	ScFace::FontFormat format;
 	ScFace::FontType   type;
 	FT_Face         face = nullptr;
-	error = FT_New_Face(library, QFile::encodeName(filename), 0, &face);
+	bool error = FT_New_Face(library, QFile::encodeName(filename), 0, &face);
 	if (error || (face == nullptr))
 	{
 		if (face != nullptr)
@@ -650,7 +653,7 @@ bool SCFonts::addScalableFont(const QStr
 	static bool firstRun;
 	bool Subset = false;
 	char buf[128];
-	QString glyName = "";
+	QString glyName;
 	ScFace::FontFormat format;
 	ScFace::FontType   type;
 	FT_Face         face = nullptr;
@@ -1068,7 +1071,7 @@ void SCFonts::addRegistryFonts()
 	FT_Library library = nullptr;
 	FT_Init_FreeType( &library );
 
-	for (const auto key : keys)
+	for (const auto& key : keys)
 	{
 		const QSettings fontRegistry(key, QSettings::NativeFormat);
 		const QStringList allKeys = fontRegistry.allKeys();
@@ -1087,7 +1090,7 @@ void SCFonts::addRegistryFonts()
 			QString fontPath = fontInfo.absoluteFilePath();
 			QString pathName = fontInfo.absolutePath();
 
-			qApp->processEvents();
+			QApplication::processEvents();
 			
 			bool isSymlink = fontInfo.isSymLink();
 			if (isSymlink)
@@ -1133,7 +1136,7 @@ void SCFonts::addType1RegistryFonts()
 	FT_Library library = nullptr;
 	FT_Init_FreeType( &library );
 
-	for (const auto key : keys)
+	for (const auto& key : keys)
 	{
 		const QSettings fontRegistry(key, QSettings::NativeFormat);
 		const QStringList allKeys = fontRegistry.allKeys();
@@ -1165,7 +1168,7 @@ void SCFonts::addType1RegistryFonts()
 				QString fontPath = fontInfo.absoluteFilePath();
 				QString pathName = fontInfo.absolutePath();
 
-				qApp->processEvents();
+				QApplication::processEvents();
 			
 				bool isSymlink = fontInfo.isSymLink();
 				if (isSymlink)
@@ -1253,13 +1256,13 @@ void SCFonts::readFontCache(const QStrin
 	}
 }
 
-void SCFonts::writeFontCache()
+void SCFonts::writeFontCache() const
 {
 	QString prefsLocation = PrefsManager::instance().preferencesLocation();
 	writeFontCache(prefsLocation);
 }
 
-void SCFonts::writeFontCache(const QString& pf)
+void SCFonts::writeFontCache(const QString& pf) const
 {
 	QDomDocument docu("fontcacherc");
 	QString st="<CachedFonts></CachedFonts>";
diff -Naupr scribus-1.6.2/scribus/scfonts.h scribus16x/scribus/scfonts.h
--- scribus-1.6.2/scribus/scfonts.h	2024-06-15 16:22:33.000000000 +0200
+++ scribus16x/scribus/scfonts.h	2025-01-04 10:59:08.679327490 +0100
@@ -55,7 +55,7 @@ class SCRIBUS_API SCFonts : public QMap<
 		void setSubstitutions(const QMap<QString,QString>& substitutes, ScribusDoc* doc = nullptr);
 		void removeFont(const QString& name);
 		/// Write checked fonts file
-		void writeFontCache();
+		void writeFontCache() const;
 
 		/// maps family name to face variants
 		QMap<QString, QStringList> fontMap;
@@ -63,7 +63,7 @@ class SCRIBUS_API SCFonts : public QMap<
 
 	private:
 		void readFontCache(const QString& pf);
-		void writeFontCache(const QString& pf);
+		void writeFontCache(const QString& pf) const;
 		void addPath(QString p);
 		bool addScalableFont(const QString& filename, FT_Library &library, const QString& DocName);
 		void addRejectedFont(const QString& fontPath, const QString& message);
diff -Naupr scribus-1.6.2/scribus/scimagecachedir.h scribus16x/scribus/scimagecachedir.h
--- scribus-1.6.2/scribus/scimagecachedir.h	2024-06-15 16:22:35.000000000 +0200
+++ scribus16x/scribus/scimagecachedir.h	2025-01-04 10:59:08.898322920 +0100
@@ -40,7 +40,7 @@ class ScImageCacheDir : public QObject
 	Q_OBJECT
 
 public:
-	typedef unsigned int AccessCounter;
+	using AccessCounter = unsigned int;
 
 	ScImageCacheDir(const QString& dir, ScImageCacheDir* parent = nullptr, bool scanFiles = false, const QStringList & suffixList = QStringList());
 	~ScImageCacheDir();
@@ -64,8 +64,8 @@ signals:
 	void fileRemoved(ScImageCacheFile * file);
 
 private:
-	typedef QHash<QString, ScImageCacheDir *> DirMap;
-	typedef QHash<QString, ScImageCacheFile *> FileMap;
+	using DirMap = QHash<QString, ScImageCacheDir*>;
+	using FileMap = QHash<QString, ScImageCacheFile*>;
 
 	void scan();
 	bool addDir(ScImageCacheDir *dir);
diff -Naupr scribus-1.6.2/scribus/scimagecachemanager.h scribus16x/scribus/scimagecachemanager.h
--- scribus-1.6.2/scribus/scimagecachemanager.h	2024-06-15 16:22:36.000000000 +0200
+++ scribus16x/scribus/scimagecachemanager.h	2025-01-04 10:59:08.898322920 +0100
@@ -41,7 +41,7 @@ class SCRIBUS_API ScImageCacheManager :
 	Q_OBJECT
 
 public:
-	typedef ScImageCacheDir::AccessCounter AccessCounter;
+	using AccessCounter = ScImageCacheDir::AccessCounter;
 
 	/**
 	* @brief Get image cache manager instance
@@ -157,7 +157,7 @@ private:
 		int count() const { return m_fa.size(); }
 
 	private:
-		typedef QList<ScImageCacheFile *> FAL;
+		using FAL = QList<ScImageCacheFile *> ;
 		FAL m_fa;
 
 		static bool ageLessThan(const ScImageCacheFile *a, const ScImageCacheFile *b);
diff -Naupr scribus-1.6.2/scribus/scimagecacheproxy.h scribus16x/scribus/scimagecacheproxy.h
--- scribus-1.6.2/scribus/scimagecacheproxy.h	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/scribus/scimagecacheproxy.h	2025-01-04 10:59:08.899322899 +0100
@@ -137,7 +137,7 @@ public:
 
 private:
 	// Don't turn this into a QHash, element order is important
-	typedef QMap<QString, QString> MetaMap;
+	using MetaMap = QMap<QString, QString>;
 
 	const QString m_filename;
 	const bool m_isEnabled;
diff -Naupr scribus-1.6.2/scribus/scimagecachewriteaction.cpp scribus16x/scribus/scimagecachewriteaction.cpp
--- scribus-1.6.2/scribus/scimagecachewriteaction.cpp	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/scribus/scimagecachewriteaction.cpp	2025-01-04 10:59:08.780325382 +0100
@@ -117,9 +117,9 @@ bool ScImageCacheWriteAction::commit()
 		return false;
 	}
 	ScImageCacheManager & scm = ScImageCacheManager::instance();
-	foreach (QString file, m_files)
+	for (const QString& file : m_files)
 		scm.updateFile(file);
-	for (FileMap::iterator i = m_access.begin(); i != m_access.end(); i++)
+	for (auto i = m_access.begin(); i != m_access.end(); i++)
 	{
 		ScLockedFile *p = *i;
 		AccessCounter from, to;
diff -Naupr scribus-1.6.2/scribus/scimagecachewriteaction.h scribus16x/scribus/scimagecachewriteaction.h
--- scribus-1.6.2/scribus/scimagecachewriteaction.h	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/scribus/scimagecachewriteaction.h	2025-01-04 10:59:08.899322899 +0100
@@ -45,8 +45,8 @@ public:
 	bool commit();
 
 private:
-	typedef ScImageCacheDir::AccessCounter AccessCounter;
-	typedef QHash<QString, ScLockedFile *> FileMap;
+	using AccessCounter = ScImageCacheDir::AccessCounter;
+	using FileMap = QHash<QString, ScLockedFile *>;
 	QStringList m_files;
 	FileMap m_access;
 	bool m_locked;
diff -Naupr scribus-1.6.2/scribus/scpage.cpp scribus16x/scribus/scpage.cpp
--- scribus-1.6.2/scribus/scpage.cpp	2024-06-15 16:22:33.000000000 +0200
+++ scribus16x/scribus/scpage.cpp	2025-01-04 10:59:08.678327511 +0100
@@ -409,6 +409,8 @@ void ScPage::restorePageItemDeletion(ScI
 			oldItem->Parent->asGroupFrame()->groupItemList.insert(id, oldItem);
 		else
 			m_Doc->Items->insert(id, oldItem);
+		if (oldItem->isBookmark)
+			m_Doc->scMW()->AddBookMark(oldItem);
 		m_Doc->m_Selection->addItems(itemList);
 	}
 	else
diff -Naupr scribus-1.6.2/scribus/scpainter.cpp scribus16x/scribus/scpainter.cpp
--- scribus-1.6.2/scribus/scpainter.cpp	2024-06-15 16:22:35.000000000 +0200
+++ scribus16x/scribus/scpainter.cpp	2025-01-04 10:59:09.016320458 +0100
@@ -613,7 +613,7 @@ cairo_pattern_t * ScPainter::getMaskPatt
 			m_imageQ = m_maskPattern->pattern.copy();
 			if (m_maskMode == 6)
 				m_imageQ.invertPixels(QImage::InvertRgba);
-			m_imageMask = cairo_image_surface_create_for_data (m_imageQ.bits(), CAIRO_FORMAT_ARGB32, m_maskPattern->getPattern()->width(), m_maskPattern->getPattern()->height(), m_maskPattern->getPattern()->width() * 4);
+			m_imageMask = cairo_image_surface_create_for_data (m_imageQ.bits(), CAIRO_FORMAT_ARGB32, m_maskPattern->getPattern().width(), m_maskPattern->getPattern().height(), m_maskPattern->getPattern().width() * 4);
 		}
 		pat = cairo_pattern_create_for_surface(m_imageMask);
 		cairo_pattern_set_extend(pat, CAIRO_EXTEND_REPEAT);
@@ -624,7 +624,7 @@ cairo_pattern_t * ScPainter::getMaskPatt
 		qmatrix.rotate(m_maskPatternTrans.rotation);
 		qmatrix.shear(-m_maskPatternTrans.skewX, m_maskPatternTrans.skewY);
 		qmatrix.scale(m_maskPatternTrans.scaleX, m_maskPatternTrans.scaleY);
-		qmatrix.scale(m_maskPattern->width / static_cast<double>(m_maskPattern->getPattern()->width()), m_maskPattern->height / static_cast<double>(m_maskPattern->getPattern()->height()));
+		qmatrix.scale(m_maskPattern->width / static_cast<double>(m_maskPattern->getPattern().width()), m_maskPattern->height / static_cast<double>(m_maskPattern->getPattern().height()));
 		if (m_mask_patternMirrorX)
 			qmatrix.scale(-1, 1);
 		if (m_mask_patternMirrorY)
@@ -1077,7 +1077,7 @@ void ScPainter::fillPathHelper()
 	else if (m_fillMode == 3)
 	{
 		cairo_set_antialias(m_cr, CAIRO_ANTIALIAS_NONE);
-		cairo_surface_t *image2 = cairo_image_surface_create_for_data ((uchar*)m_pattern->getPattern()->bits(), CAIRO_FORMAT_ARGB32, m_pattern->getPattern()->width(), m_pattern->getPattern()->height(), m_pattern->getPattern()->width() * 4);
+		cairo_surface_t *image2 = cairo_image_surface_create_for_data ((uchar*)m_pattern->getPattern().bits(), CAIRO_FORMAT_ARGB32, m_pattern->getPattern().width(), m_pattern->getPattern().height(), m_pattern->getPattern().width() * 4);
 		cairo_pattern_t *m_pat = cairo_pattern_create_for_surface(image2);
 		cairo_pattern_set_extend(m_pat, CAIRO_EXTEND_REPEAT);
 		cairo_pattern_set_filter(m_pat, CAIRO_FILTER_GOOD);
@@ -1087,7 +1087,7 @@ void ScPainter::fillPathHelper()
 		qmatrix.rotate(m_patternTrans.rotation);
 		qmatrix.shear(-m_patternTrans.skewX, m_patternTrans.skewY);
 		qmatrix.scale(m_patternTrans.scaleX, m_patternTrans.scaleY);
-		qmatrix.scale(m_pattern->width / static_cast<double>(m_pattern->getPattern()->width()), m_pattern->height / static_cast<double>(m_pattern->getPattern()->height()));
+		qmatrix.scale(m_pattern->width / static_cast<double>(m_pattern->getPattern().width()), m_pattern->height / static_cast<double>(m_pattern->getPattern().height()));
 		if (m_patternMirrorX)
 			qmatrix.scale(-1, 1);
 		if (m_patternMirrorY)
@@ -1243,7 +1243,7 @@ void ScPainter::strokePathHelper()
 	{
 		cairo_push_group(m_cr);
 		cairo_set_antialias(m_cr, CAIRO_ANTIALIAS_NONE);
-		cairo_surface_t *image2 = cairo_image_surface_create_for_data ((uchar*)m_pattern->getPattern()->bits(), CAIRO_FORMAT_ARGB32, m_pattern->getPattern()->width(), m_pattern->getPattern()->height(), m_pattern->getPattern()->width() * 4);
+		cairo_surface_t *image2 = cairo_image_surface_create_for_data ((uchar*)m_pattern->getPattern().bits(), CAIRO_FORMAT_ARGB32, m_pattern->getPattern().width(), m_pattern->getPattern().height(), m_pattern->getPattern().width() * 4);
 		cairo_pattern_t *m_pat = cairo_pattern_create_for_surface(image2);
 		cairo_pattern_set_extend(m_pat, CAIRO_EXTEND_REPEAT);
 		cairo_pattern_set_filter(m_pat, CAIRO_FILTER_GOOD);
@@ -1254,7 +1254,7 @@ void ScPainter::strokePathHelper()
 		qmatrix.rotate(m_patternTrans.rotation);
 		qmatrix.shear(-m_patternTrans.skewX, m_patternTrans.skewY);
 		qmatrix.scale(m_patternTrans.scaleX, m_patternTrans.scaleY);
-		qmatrix.scale(m_pattern->width / static_cast<double>(m_pattern->getPattern()->width()), m_pattern->height / static_cast<double>(m_pattern->getPattern()->height()));
+		qmatrix.scale(m_pattern->width / static_cast<double>(m_pattern->getPattern().width()), m_pattern->height / static_cast<double>(m_pattern->getPattern().height()));
 		if (m_patternMirrorX)
 			qmatrix.scale(-1, 1);
 		if (m_patternMirrorY)
diff -Naupr scribus-1.6.2/scribus/scpainterex_cairo.cpp scribus16x/scribus/scpainterex_cairo.cpp
--- scribus-1.6.2/scribus/scpainterex_cairo.cpp	2024-06-15 16:22:34.000000000 +0200
+++ scribus16x/scribus/scpainterex_cairo.cpp	2025-01-04 10:59:09.016320458 +0100
@@ -608,7 +608,7 @@ cairo_pattern_t* ScPainterEx_Cairo::getM
 			m_imageQ = m_maskPattern->pattern.copy();
 			if (m_maskMode == 6)
 				m_imageQ.invertPixels(QImage::InvertRgba);
-			m_imageMask = cairo_image_surface_create_for_data(m_imageQ.bits(), CAIRO_FORMAT_ARGB32, m_maskPattern->getPattern()->width(), m_maskPattern->getPattern()->height(), m_maskPattern->getPattern()->width() * 4);
+			m_imageMask = cairo_image_surface_create_for_data(m_imageQ.bits(), CAIRO_FORMAT_ARGB32, m_maskPattern->getPattern().width(), m_maskPattern->getPattern().height(), m_maskPattern->getPattern().width() * 4);
 		}
 		pat = cairo_pattern_create_for_surface(m_imageMask);
 		cairo_pattern_set_extend(pat, CAIRO_EXTEND_REPEAT);
@@ -619,7 +619,7 @@ cairo_pattern_t* ScPainterEx_Cairo::getM
 		qmatrix.rotate(m_maskPatternTrans.rotation);
 		qmatrix.shear(-m_maskPatternTrans.skewX, m_maskPatternTrans.skewY);
 		qmatrix.scale(m_maskPatternTrans.scaleX, m_maskPatternTrans.scaleY);
-		qmatrix.scale(m_maskPattern->width / static_cast<double>(m_maskPattern->getPattern()->width()), m_maskPattern->height / static_cast<double>(m_maskPattern->getPattern()->height()));
+		qmatrix.scale(m_maskPattern->width / static_cast<double>(m_maskPattern->getPattern().width()), m_maskPattern->height / static_cast<double>(m_maskPattern->getPattern().height()));
 		if (m_maskPatternMirrorX)
 			qmatrix.scale(-1, 1);
 		if (m_maskPatternMirrorY)
diff -Naupr scribus-1.6.2/scribus/scpaths.h scribus16x/scribus/scpaths.h
--- scribus-1.6.2/scribus/scpaths.h	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/scribus/scpaths.h	2025-01-04 10:59:09.015320478 +0100
@@ -14,7 +14,7 @@ for which a new license (GPL+exception)
 class SCRIBUS_API ScPaths
 {
 public:
-	typedef enum {Hyph, Spell} DictType;
+	enum DictType { Hyph, Spell } ;
 
 	/**
 	 * @brief Get a reference to the ScPaths instance
diff -Naupr scribus-1.6.2/scribus/scpattern.cpp scribus16x/scribus/scpattern.cpp
--- scribus-1.6.2/scribus/scpattern.cpp	2024-06-15 16:22:36.000000000 +0200
+++ scribus16x/scribus/scpattern.cpp	2025-01-04 10:59:09.016320458 +0100
@@ -49,9 +49,14 @@ void ScPattern::setDoc(ScribusDoc *theDo
 	doc = theDoc;
 }
 
-QImage* ScPattern::getPattern()
+QImage& ScPattern::getPattern()
 {
-	return &pattern;
+	return pattern;
+}
+
+const QImage& ScPattern::getPattern() const
+{
+	return pattern;
 }
 
 void ScPattern::setPattern(const QString& filename)
diff -Naupr scribus-1.6.2/scribus/scpattern.h scribus16x/scribus/scpattern.h
--- scribus-1.6.2/scribus/scpattern.h	2024-06-15 16:22:36.000000000 +0200
+++ scribus16x/scribus/scpattern.h	2025-01-04 10:59:09.016320458 +0100
@@ -40,7 +40,9 @@ public:
 	ScPattern(ScribusDoc* theDoc);
 	~ScPattern();
 
-	QImage* getPattern();
+	QImage& getPattern();
+	const QImage& getPattern() const;
+
 	void setDoc(ScribusDoc *theDoc);
 	void setPattern(const QString& filename);
 	void createPreview();
diff -Naupr scribus-1.6.2/scribus/scprintengine_gdi.h scribus16x/scribus/scprintengine_gdi.h
--- scribus-1.6.2/scribus/scprintengine_gdi.h	2024-06-15 16:22:36.000000000 +0200
+++ scribus16x/scribus/scprintengine_gdi.h	2025-01-04 10:59:08.803324902 +0100
@@ -61,7 +61,7 @@ protected:
 
 	void resetData(void);
 
-	typedef bool (ScPrintEngine_GDI::*PrintPageFunc) (ScPage* page, const PrintOptions& options, HDC printerDC, cairo_t* context);
+	using PrintPageFunc = bool (ScPrintEngine_GDI::*)(ScPage *, const PrintOptions &, HDC, cairo_t *);
 
 	/*! \brief Print selected pages to a printer or a file
 	\param doc the document whose pages are to be printer
diff -Naupr scribus-1.6.2/scribus/scraction.h scribus16x/scribus/scraction.h
--- scribus-1.6.2/scribus/scraction.h	2024-06-15 16:22:36.000000000 +0200
+++ scribus16x/scribus/scraction.h	2025-01-04 10:59:09.015320478 +0100
@@ -37,7 +37,7 @@ class SCRIBUS_API ScrAction : public QAc
 	Q_OBJECT
 
 public:
-	typedef enum {Normal, DataInt, DataDouble, DataQString, RecentFile, DLL, Window, RecentScript, UnicodeChar, Layer, ActionDLL, RecentPaste, ActionDLLSE } ActionType;
+	enum ActionType { Normal, DataInt, DataDouble, DataQString, RecentFile, DLL, Window, RecentScript, UnicodeChar, Layer, ActionDLL, RecentPaste, ActionDLLSE };
 	
 	/*!
 		\author Craig Bradney
diff -Naupr scribus-1.6.2/scribus/scribus.cpp scribus16x/scribus/scribus.cpp
--- scribus-1.6.2/scribus/scribus.cpp	2024-06-15 16:22:33.000000000 +0200
+++ scribus16x/scribus/scribus.cpp	2025-01-04 10:59:08.678327511 +0100
@@ -1048,6 +1048,8 @@ void ScribusMainWindow::initMenuBar()
 	scrMenuMgr->addMenuItemString("typeEffectOutline", "TextFeatures");
 	scrMenuMgr->addMenuItemString("typeEffectShadow", "TextFeatures");
 
+	scrMenuMgr->addMenuItemString("itemAttributes", "Item");
+
 	//Insert menu
 	scrMenuMgr->createMenu("Insert", ActionManager::defaultMenuNameEntryTranslated("Insert"));
 	scrMenuMgr->addMenuItemString("insertFrame", "Insert");
diff -Naupr scribus-1.6.2/scribus/scribusapp.cpp scribus16x/scribus/scribusapp.cpp
--- scribus-1.6.2/scribus/scribusapp.cpp	2024-06-15 16:22:33.000000000 +0200
+++ scribus16x/scribus/scribusapp.cpp	2025-01-04 10:59:09.017320437 +0100
@@ -653,10 +653,10 @@ void ScribusQApp::showHeader()
 	const int descwidth = -(heading.length() - urlwidth - 1);
 	ts << heading << Qt::endl;
 	ts << separator << Qt::endl;
-	ts << QString("%1 %2").arg( tr("Homepage") + ":",      descwidth).arg("http://www.scribus.net" ) << Qt::endl;
-	ts << QString("%1 %2").arg( tr("Documentation") + ":", descwidth).arg("http://docs.scribus.net") << Qt::endl;
-	ts << QString("%1 %2").arg( tr("Wiki") + ":",          descwidth).arg("http://wiki.scribus.net") << Qt::endl;
-	ts << QString("%1 %2").arg( tr("Issues") + ":",        descwidth).arg("http://bugs.scribus.net") << Qt::endl;
+	ts << QString("%1 %2").arg( tr("Homepage") + ":",      descwidth).arg("https://www.scribus.net" ) << Qt::endl;
+	ts << QString("%1 %2").arg( tr("Documentation") + ":", descwidth).arg("https://docs.scribus.net") << Qt::endl;
+	ts << QString("%1 %2").arg( tr("Wiki") + ":",          descwidth).arg("https://wiki.scribus.net") << Qt::endl;
+	ts << QString("%1 %2").arg( tr("Issues") + ":",        descwidth).arg("https://bugs.scribus.net") << Qt::endl;
 	ts << Qt::endl;
 }
 
diff -Naupr scribus-1.6.2/scribus/scribuscore.cpp scribus16x/scribus/scribuscore.cpp
--- scribus-1.6.2/scribus/scribuscore.cpp	2024-06-15 16:22:33.000000000 +0200
+++ scribus16x/scribus/scribuscore.cpp	2025-01-04 10:59:08.781325361 +0100
@@ -29,6 +29,7 @@ for which a new license (GPL+exception)
 #include <QGlobalStatic>
 #include <QMessageBox>
 #include <QScreen>
+#include <QStyleFactory>
 
 #include "colormgmt/sccolormgmtenginefactory.h"
 #include "commonstrings.h"
@@ -171,6 +172,24 @@ int ScribusCore::initScribusCore(bool sh
 	m_prefsManager.initDefaultActionKeys();
 	setSplashStatus( tr("Reading Preferences") );
 	m_prefsManager.readPrefs();
+
+	// Configure GUI
+	const QString& prefsUiStyle = m_prefsManager.appPrefs.uiPrefs.style;
+	if (prefsUiStyle.length() > 0)
+	{
+		QStyle* qtStyle = nullptr;
+		QStringList availableStyles = QStyleFactory::keys();
+		if (availableStyles.contains(prefsUiStyle))
+			qtStyle = QStyleFactory::create(prefsUiStyle);
+		if (qtStyle)
+			QApplication::setStyle(qtStyle);
+		else
+			m_prefsManager.appPrefs.uiPrefs.style.clear();
+	}
+	QFont apf = QApplication::font();
+	apf.setPointSize(m_prefsManager.appPrefs.uiPrefs.applicationFontSize);
+	QApplication::setFont(apf);
+
 	LocaleManager::instance().setUserPreferredLocale(m_prefsManager.appPrefs.uiPrefs.userPreferredLocale);
 	m_prefsManager.appPrefs.uiPrefs.showSplashOnStartup = showSplash;
 	if (!m_iconManager.setActiveFromPrefs(m_prefsManager.appPrefs.uiPrefs.iconSet))
diff -Naupr scribus-1.6.2/scribus/scribusdoc.cpp scribus16x/scribus/scribusdoc.cpp
--- scribus-1.6.2/scribus/scribusdoc.cpp	2024-06-15 16:22:32.000000000 +0200
+++ scribus16x/scribus/scribusdoc.cpp	2025-01-04 10:59:08.677327531 +0100
@@ -181,12 +181,11 @@ public:
 		it->invalidateLayout();
 		if (doLayout)
 			it->layout();
-		double x, y, w, h;
 		QTransform t = it->getTransform();
-		w = it->visualWidth();
-		h = it->visualHeight();
-		x = -it->visualLineWidth() / 2.0;
-		y = -it->visualLineWidth() / 2.0;
+		double w = it->visualWidth();
+		double h = it->visualHeight();
+		double x = -it->visualLineWidth() / 2.0;
+		double y = -it->visualLineWidth() / 2.0;
 		QRectF upRect = t.mapRect(QRectF(x, y, w, h));
 		doc->regionsChanged()->update(upRect);
 		if (m_updateEnabled <= 0)
@@ -658,7 +657,7 @@ bool ScribusDoc::inASpecialEditMode() co
 			appMode == modeEditWeldPoint;
 }
 
-QList<PageItem*> ScribusDoc::getAllItems(QList<PageItem*> &items) const
+QList<PageItem*> ScribusDoc::getAllItems(const QList<PageItem*> &items) const
 {
 	QList<PageItem*> ret;
 	for (int em = 0; em < items.count(); ++em)
@@ -1030,7 +1029,7 @@ void ScribusDoc::getNamedResources(Resou
 	}
 	for (QHash<int, PageItem*>::const_iterator itf = FrameItems.begin(); itf != FrameItems.end(); ++itf)
 	{
-		PageItem *currItem = itf.value();
+		const PageItem *currItem = itf.value();
 		if (currItem)
 			currItem->getNamedResources(lists);
 	}
@@ -1043,8 +1042,7 @@ void ScribusDoc::getNamedResources(Resou
 	for (int i = 0; i < m_docCellStyles.count(); ++i)
 		m_docCellStyles[i].getNamedResources(lists);
 	
-	QHash<QString,ScPattern>::ConstIterator it;
-	for (it = docPatterns.begin(); it != docPatterns.end(); ++it)
+	for (auto it = docPatterns.begin(); it != docPatterns.end(); ++it)
 	{
 		ScPattern pa = *it;
 		for (int o = 0; o < pa.items.count(); o++)
@@ -1052,8 +1050,7 @@ void ScribusDoc::getNamedResources(Resou
 			pa.items.at(o)->getNamedResources(lists);
 		}
 	}
-	QHash<QString,VGradient>::ConstIterator itg;
-	for (itg = docGradients.begin(); itg != docGradients.end(); ++itg)
+	for (auto itg = docGradients.begin(); itg != docGradients.end(); ++itg)
 	{
 		QList<VColorStop*> cstops = itg.value().colorStops();
 		for (int cst = 0; cst < itg.value().stops(); ++cst)
@@ -1211,10 +1208,10 @@ void ScribusDoc::replaceStyles(const QMa
 void ScribusDoc::replaceNamedResources(ResourceCollection& newNames)
 {
 	// replace names in items
-	QList<PageItem*> * itemlist = & MasterItems;
+	const QList<PageItem*> * itemlist = & MasterItems;
 	while (itemlist != nullptr)
 	{
-		for (int i=0; i < itemlist->count(); ++i)
+		for (int i = 0; i < itemlist->count(); ++i)
 		{
 			PageItem * currItem = itemlist->at(i);
 			if (currItem)
@@ -1721,15 +1718,15 @@ void ScribusDoc::restore(UndoState* stat
 	else if (ss->contains("PAGE_SWAP"))
 		restoreSwapPage(ss, isUndo);
 	else if (ss->contains("LEVEL_DOWN"))
-		restoreLevelDown(ss,isUndo);
+		restoreLevelUpOrDown(ss, isUndo);
 	else if (ss->contains("LEVEL_UP"))
-		restoreLevelDown(ss,!isUndo);
+		restoreLevelUpOrDown(ss, !isUndo);
 	else if (ss->contains("LEVEL_BOTTOM"))
-		restoreLevelBottom(ss,isUndo);
+		restoreLevelTopOrBottom(ss, isUndo);
 	else if (ss->contains("LEVEL_TOP"))
-		restoreLevelBottom(ss,!isUndo);
+		restoreLevelTopOrBottom(ss, !isUndo);
 	else if (ss->contains("PAGE_CHANGEPROPS"))
-		restoreChangePageProperties(ss,isUndo);
+		restoreChangePageProperties(ss, isUndo);
 	else if (ss->contains("DELETE_FRAMETEXT"))
 	{
 		PageItem * nF = getItemFromName(ss->get("noteframeName"));
@@ -1746,13 +1743,13 @@ void ScribusDoc::restore(UndoState* stat
 	{
 		PageItem * nF = getItemFromName(ss->get("noteframeName"));
 		Q_ASSERT(nF != nullptr);
-		nF->asNoteFrame()->restoreInsertNoteText(ss,isUndo);
+		nF->asNoteFrame()->restoreInsertNoteText(ss, isUndo);
 	}
 	else if (ss->contains("INSERT_FRAMEPARA"))
 	{
 		PageItem * nF = getItemFromName(ss->get("noteframeName"));
 		Q_ASSERT(nF != nullptr);
-		nF->asNoteFrame()->restoreInsertNoteParagraph(ss,isUndo);
+		nF->asNoteFrame()->restoreInsertNoteParagraph(ss, isUndo);
 	}
 	else if (ss->contains("NSTYLE"))
 		restoreNoteStyle(ss, isUndo);
@@ -1775,32 +1772,42 @@ void ScribusDoc::restore(UndoState* stat
 	}
 }
 
-void ScribusDoc::restoreLevelDown(SimpleState* ss, bool isUndo)
+void ScribusDoc::restoreLevelUpOrDown(SimpleState* ss, bool isUndo)
 {
 	const auto *is = dynamic_cast<ScItemState<QList<QPointer<PageItem> > > *>(ss);
 	if (!is)
 		return;
-
 	QList<QPointer<PageItem> > listItem = is->getItem();
+
 	m_Selection->clear();
-	for (int i = 0; i<listItem.size();i++)
-		m_Selection->addItem(listItem.at(i));
+	for (const QPointer<PageItem>& pItem : listItem)
+	{
+		if (pItem.isNull())
+			continue;
+		m_Selection->addItem(pItem);
+	}
+
 	if (isUndo)
 		itemSelection_RaiseItem();
 	else
 		itemSelection_LowerItem();
 }
 
-void ScribusDoc::restoreLevelBottom(SimpleState* ss, bool isUndo)
+void ScribusDoc::restoreLevelTopOrBottom(SimpleState* ss, bool isUndo)
 {
 	const auto *is = dynamic_cast<ScItemState<QList<QPointer<PageItem> > > *>(ss);
 	if (!is)
 		return;
-
 	QList<QPointer<PageItem> > listItem = is->getItem();
+
 	m_Selection->clear();
-	for (int i = 0; i<listItem.size();i++)
-		m_Selection->addItem(listItem.at(i));
+	for (const QPointer<PageItem>& pItem : listItem)
+	{
+		if (pItem.isNull())
+			continue;
+		m_Selection->addItem(pItem);
+	}
+
 	if (isUndo)
 		bringItemSelectionToFront();
 	else
@@ -2553,7 +2560,7 @@ bool ScribusDoc::renameMasterPage(const
 	MasterPages.at(number)->setPageName(newPageName);
 	//Update any pages that were linking to our old name
 	ScPage* docPage = nullptr;
-	for (int i=0; i < DocPages.count(); ++i )
+	for (int i = 0; i < DocPages.count(); ++i)
 	{
 		docPage = DocPages[i];
 		if (docPage->masterPageName() == oldPageName)
@@ -2777,7 +2784,7 @@ int ScribusDoc::addAutomaticTextFrame(in
 {
 	if (!m_automaticTextFrames)
 		return -1;
-	ScPage* addToPage = DocPages.at(pageNumber);
+	const ScPage* addToPage = DocPages.at(pageNumber);
 	if ((!masterPageMode()) && (usesAutomaticTextFrames()))// && (!isLoading()))
 	{
 		int z = itemAdd(PageItem::TextFrame, PageItem::Unspecified,
@@ -3538,12 +3545,11 @@ bool ScribusDoc::renumberLayer(int layer
 
 void ScribusDoc::replaceLineStyleColors(const QMap<QString, QString>& colorMap)
 {
-	MultiLine::iterator its;
 	QMap<QString, QString>::const_iterator it;
 	for (auto itl = docLineStyles.begin(); itl != docLineStyles.end(); ++itl)
 	{
 		MultiLine& mline = itl.value();
-		for (its = mline.begin(); its != mline.end(); ++its)
+		for (auto its = mline.begin(); its != mline.end(); ++its)
 		{
 			struct SingleLine& sline = *its;
 			it = colorMap.find(sline.Color);
@@ -3625,13 +3631,12 @@ bool ScribusDoc::hasArrowStyle(const QSt
 bool ScribusDoc::lineStylesUseColor(const QString& colorName) const
 {
 	bool found = false;
-	MultiLine::const_iterator its, itsend;
 	auto itmend = docLineStyles.constEnd();
 	for (auto itm = docLineStyles.constBegin(); itm != itmend && !found; ++itm)
 	{
 		const MultiLine& ml = itm.value();
-		itsend = ml.constEnd();
-		for (its = ml.constBegin(); its != itsend; ++its)
+		auto itsend = ml.constEnd();
+		for (auto its = ml.constBegin(); its != itsend; ++its)
 		{
 			if (its->Color == colorName)
 			{
@@ -3678,13 +3683,12 @@ void ScribusDoc::setGradients(const QHas
 	docGradients = gradients;
 }
 
-bool ScribusDoc::addPattern(QString &name, ScPattern& pattern)
+bool ScribusDoc::addPattern(QString &name, const ScPattern& pattern)
 {
-	QString tmp;
 	if (docPatterns.contains(name))
-		name += "("+tmp.setNum(docPatterns.count())+")";
-//		name = tr("Copy_of_")+name;
+		name = getUniquePatternName(name);
 	docPatterns.insert(name, pattern);
+
 	QList<PageItem*> allItems = getAllItems(pattern.items);
 	for (int i = 0; i < allItems.count(); i++)
 	{
@@ -3715,7 +3719,7 @@ ScPattern* ScribusDoc::checkedPattern(co
 	ScPattern* pattern = &docPatterns[name];
 	if (pattern->width <= 0 || pattern->height <= 0)
 		return nullptr;
-	if (pattern->getPattern()->isNull())
+	if (pattern->getPattern().isNull())
 		return nullptr;
 	return pattern;
 }
@@ -3769,7 +3773,7 @@ QStringList ScribusDoc::getUsedPatterns(
 
 	for (PageItemIterator it(this, PageItemIterator::IterateInDocNoPatterns); *it; ++it)
 	{
-		PageItem* currItem = *it;
+		const PageItem* currItem = *it;
 		if ((!results.contains(currItem->pattern())) && ((currItem->GrType == Gradient_Pattern) || (currItem->itemType() == PageItem::Symbol)))
 			results.append(currItem->pattern());
 		if (!currItem->strokePattern().isEmpty())
@@ -3882,7 +3886,7 @@ QStringList ScribusDoc::getUsedPatternsH
 			allItems.append(pat.items.at(i));
 		for (int j = 0; j < allItems.count(); j++)
 		{
-			PageItem *currItem = allItems.at(j);
+			const PageItem *currItem = allItems.at(j);
 			if ((currItem->GrType == Gradient_Pattern) || (currItem->itemType() == PageItem::Symbol))
 			{
 				const QString& patName = currItem->pattern();
@@ -3955,7 +3959,7 @@ QStringList ScribusDoc::getUsedSymbols()
 
 	for (PageItemIterator it(this, PageItemIterator::IterateInDocDefaults); *it; ++it)
 	{
-		PageItem* currItem = *it;
+		const PageItem* currItem = *it;
 		if (currItem->isGroup())
 			continue;
 		if ((!results.contains(currItem->pattern())) && (currItem->itemType() == PageItem::Symbol) && (!currItem->pattern().isEmpty()))
@@ -4105,8 +4109,8 @@ QMap<QString,int> ScribusDoc::reorganise
 		}
 	}
 
-	QMap<QString,int>::Iterator itfo, itnext;
-	for (itfo = UsedFonts.begin(); itfo != UsedFonts.end(); itfo = itnext)
+	QMap<QString, int>::Iterator itnext;
+	for (auto itfo = UsedFonts.begin(); itfo != UsedFonts.end(); itfo = itnext)
 	{
 		itnext = itfo;
 		++itnext;
@@ -4139,7 +4143,7 @@ void ScribusDoc::getUsedFonts(QMap<QStri
 				allItems = it->getChildren() + allItems;
 				continue;
 			}
-			checkItemForFonts(it, Really, i);
+			checkItemForFonts(it, Really);
 		}
 	}
 
@@ -4152,7 +4156,7 @@ void ScribusDoc::getUsedFonts(QMap<QStri
 			allItems = ite->getChildren() + allItems;
 			continue;
 		}
-		checkItemForFonts(ite, Really, 3);
+		checkItemForFonts(ite, Really);
 	}
 
 	QStringList patterns = getUsedPatterns();
@@ -4168,7 +4172,7 @@ void ScribusDoc::getUsedFonts(QMap<QStri
 				allItems = it->getChildren() + allItems;
 				continue;
 			}
-			checkItemForFonts(it, Really, 3);
+			checkItemForFonts(it, Really);
 		}
 	}
 }
@@ -4222,7 +4226,7 @@ private:
 	QMap<QString, QMap<uint, QString> > & m_fonts;
 };
 
-void ScribusDoc::checkItemForFonts(PageItem *it, QMap<QString, QMap<uint, QString> > & usedFonts, uint lc)
+void ScribusDoc::checkItemForFonts(PageItem *it, QMap<QString, QMap<uint, QString> > & usedFonts)
 {
 	if (!it->isTextFrame() && !it->isPathText())
 		return;
@@ -4515,7 +4519,7 @@ bool ScribusDoc::useImageEffects() const
 		const auto& itemList = *(itemLists[i]);
 		for (it.begin(itemList); *it; ++it)
 		{
-			PageItem *currItem = *it;
+			const PageItem *currItem = *it;
 			if (!currItem->isImageFrame() || !currItem->imageIsAvailable)
 				continue;
 			if (currItem->effectsInUse.count() > 0)
@@ -4529,7 +4533,7 @@ bool ScribusDoc::useImageEffects() const
 		const ScPattern& pa = patIter.value();
 		for (it.begin(pa.items); *it; ++it)
 		{
-			PageItem *currItem = *it;
+			const PageItem *currItem = *it;
 			if (!currItem->isImageFrame() || !currItem->imageIsAvailable)
 				continue;
 			if (currItem->effectsInUse.count() > 0)
@@ -4551,7 +4555,7 @@ bool ScribusDoc::useImageColorEffects()
 		const auto& itemList = *(itemLists[i]);
 		for (it.begin(itemList); *it; ++it)
 		{
-			PageItem *currItem = *it;
+			const PageItem *currItem = *it;
 			if (!currItem->isImageFrame() || !currItem->imageIsAvailable)
 				continue;
 			if (currItem->effectsInUse.useColorEffect())
@@ -4565,7 +4569,7 @@ bool ScribusDoc::useImageColorEffects()
 		const ScPattern& pa = patIter.value();
 		for (it.begin(pa.items); *it; ++it)
 		{
-			PageItem *currItem = *it;
+			const PageItem *currItem = *it;
 			if (!currItem->isImageFrame() || !currItem->imageIsAvailable)
 				continue;
 			if (currItem->effectsInUse.useColorEffect())
@@ -4612,7 +4616,7 @@ bool ScribusDoc::applyMasterPage(const Q
 	ScPage* Ap = DocPages.at(pageNumber);
 	Ap->setMasterPageName(pageName);
 	const int MpNr = MasterNames[pageName];
-	ScPage* Mp = MasterPages.at(MpNr);
+	const ScPage* Mp = MasterPages.at(MpNr);
 	PageItem *currItem;
 	Ap->FromMaster.clear();
 	for (int itn = 0; itn < MasterItems.count(); ++itn)
@@ -4825,7 +4829,7 @@ bool ScribusDoc::changePageProperties(do
 	return true;
 }
 
-void ScribusDoc::recalculateColorsList(QList<PageItem*> *itemList)
+void ScribusDoc::recalculateColorsList(const QList<PageItem*> *itemList)
 {
 	QList<PageItem*> allItems;
 	for (int c = 0; c < itemList->count(); ++c)
@@ -4923,8 +4927,7 @@ void ScribusDoc::recalculateColors()
 	m_undoManager->setUndoEnabled(false);
 
 	//Adjust Items of the 3 types to the colors
-	QHash<QString, VGradient>::Iterator itGrad;
-	for (itGrad = docGradients.begin(); itGrad != docGradients.end(); ++itGrad)
+	for (auto itGrad = docGradients.begin(); itGrad != docGradients.end(); ++itGrad)
 	{
 		QList<VColorStop*> cstops = itGrad.value().colorStops();
 		for (int cst = 0; cst < itGrad.value().stops(); ++cst)
@@ -5107,7 +5110,7 @@ bool ScribusDoc::copyPageToMasterPage(in
 			if (Layers.count() != 0 && pageMaster != nullptr)
 			{
 				int currActiveLayer = activeLayer();
-				for (ScLayers::iterator it = Layers.begin(); it != Layers.end(); ++it)
+				for (auto it = Layers.begin(); it != Layers.end(); ++it)
 				{
 					setActiveLayer(it->ID);
 					for (int ite = 0; ite < masterItemsOldCount; ++ite)
@@ -5121,7 +5124,7 @@ bool ScribusDoc::copyPageToMasterPage(in
 						ScriXmlDoc ss;
 						setMasterPageMode(true);
 						setCurrentPage(pageMaster); // Needed for writeElem to write proper page relative coordinates
-						QString dataS = ss.writeElem(this, &tempSelection);
+						QString dataS = ScriXmlDoc::writeElem(this, &tempSelection);
 						setCurrentPage(targetPage);
 						ss.readElemToLayer(dataS, this, targetPage->xOffset(), targetPage->yOffset(), false, true, it->ID);
 						setMasterPageMode(false);
@@ -5150,7 +5153,7 @@ bool ScribusDoc::copyPageToMasterPage(in
 			{
 				ScriXmlDoc ss;
 				setCurrentPage(sourcePage); // Needed for writeElem to write proper page relative coordinates
-				QString dataS = ss.writeElem(this, &tempSelection);
+				QString dataS = ScriXmlDoc::writeElem(this, &tempSelection);
 				setMasterPageMode(true);
 				setCurrentPage(targetPage);
 				ss.readElemToLayer(dataS, this, targetPage->xOffset(), targetPage->yOffset(), false, true, it->ID);
@@ -5423,8 +5426,8 @@ int ScribusDoc::itemAddUserFrame(InsertA
 					loadPict(iafData.source, currItem, false, true);
 					if (iafData.sizeType == 3) //Frame is size of imported image
 					{
-						currItem->setWidth(static_cast<double>(currItem->OrigW * 72.0 / currItem->pixm.imgInfo.xres));
-						currItem->setHeight(static_cast<double>(currItem->OrigH * 72.0 / currItem->pixm.imgInfo.yres));
+						currItem->setWidth((currItem->OrigW * 72.0) / currItem->pixm.imgInfo.xres);
+						currItem->setHeight((currItem->OrigH * 72.0) / currItem->pixm.imgInfo.yres);
 						currItem->OldB2 = currItem->width();
 						currItem->OldH2 = currItem->height();
 						currItem->updateClip();
@@ -5606,7 +5609,9 @@ PageItem* ScribusDoc::getItemFromName(co
 void ScribusDoc::rebuildItemLists()
 {
 	// #5826 Rebuild items list in case layer order as been changed
-	QList<PageItem*> newDocItems, newMasterItems;
+	QList<PageItem*> newDocItems;
+	QList<PageItem*> newMasterItems;
+
 	Layers.sort();
 	int layerCount = this->layerCount();
 	for (int la = 0; la < layerCount; ++la)
@@ -5688,9 +5693,9 @@ bool ScribusDoc::loadPict(const QString&
 }
 
 
-void ScribusDoc::canvasMinMax(FPoint& minPoint, FPoint& maxPoint)
+void ScribusDoc::canvasMinMax(FPoint& minPoint, FPoint& maxPoint) const
 {
-	PageItem *currItem;
+	const PageItem *currItem;
 	double minx =  std::numeric_limits<double>::max();
 	double miny =  std::numeric_limits<double>::max();
 	double maxx = -std::numeric_limits<double>::max();
@@ -5731,12 +5736,11 @@ void ScribusDoc::canvasMinMax(FPoint& mi
 	}
 	else
 	{
-		ScPage* page;
 		MarginStruct pageBleeds;
 		int docPageCount = Pages->count();
 		for (int i = 0; i < docPageCount; ++i)
 		{
-			page = Pages->at(i);
+			const ScPage* page = Pages->at(i);
 			getBleeds(page, pageBleeds);
 			minx = qMin(minx, page->xOffset() - pageBleeds.left());
 			miny = qMin(miny, page->yOffset() - pageBleeds.top());
@@ -5750,13 +5754,13 @@ void ScribusDoc::canvasMinMax(FPoint& mi
 	maxPoint.setY(maxy);
 }
 
-QRectF ScribusDoc::canvasOptimalRect()
+QRectF ScribusDoc::canvasOptimalRect() const
 {
 	double x, y, width, height;
 	QRectF canvasRect;
 	MarginStruct pageBleeds;
-	PageItem *currItem;
-	ScPage* page;
+	const PageItem *currItem;
+	const ScPage* page;
 
 	int pageCount = Pages->count();
 	for (int i = 0; i < pageCount; ++i)
@@ -5785,7 +5789,7 @@ QRectF ScribusDoc::canvasOptimalRect()
 }
 
 
-int ScribusDoc::OnPage(double x2, double  y2)
+int ScribusDoc::OnPage(double x2, double  y2) const
 {
 	int retw = -1;
 	if (masterPageMode())
@@ -5821,7 +5825,7 @@ int ScribusDoc::OnPage(double x2, double
 }
 
 
-int ScribusDoc::OnPage(PageItem *currItem)
+int ScribusDoc::OnPage(PageItem *currItem) const
 {
 	int retw = -1;
 
@@ -5900,7 +5904,6 @@ void ScribusDoc::GroupOnPage(PageItem* c
 void  ScribusDoc::fixItemPageOwner()
 {
 	int pageNr;
-	ScPage* page;
 	PageItem* currItem;
 	MarginStruct pageBleeds;
 
@@ -5917,7 +5920,7 @@ void  ScribusDoc::fixItemPageOwner()
 		// specified page effectively contain the item
 		if (pageNr >= 0 && pageNr < Pages->count())
 		{
-			page = Pages->at(pageNr);
+			const ScPage* page = Pages->at(pageNr);
 			getBleeds(page, pageBleeds);
 			double x1 = page->xOffset() - pageBleeds.left();
 			double y1 = page->yOffset() - pageBleeds.top();
@@ -6016,9 +6019,9 @@ void ScribusDoc::fixNotesStyles()
 
 struct oldPageVar
 {
-	uint newPg;
-	double oldXO;
-	double oldYO;
+	uint newPg { 0 };
+	double oldXO { 0.0 };
+	double oldYO { 0.0 };
 };
 
 
@@ -6030,8 +6033,8 @@ void ScribusDoc::reformPages(bool moveOb
 	struct oldPageVar oldPg;
 	int counter = pageSets()[m_docPrefsData.docSetupPrefs.pagePositioning].FirstPage;
 	int rowcounter = 0;
-	double maxYPos = 0.0;
 	double maxXPos = 0.0;
+	double maxYPos = 0.0;
 	double currentXPos = m_docPrefsData.displayPrefs.scratch.left();
 	double currentYPos = m_docPrefsData.displayPrefs.scratch.top();
 	double lastYPos = Pages->at(0)->initialHeight();
@@ -6454,7 +6457,7 @@ PageItem* ScribusDoc::convertItemTo(Page
 	return newItem;
 }
 
-int ScribusDoc::currentPageNumber()
+int ScribusDoc::currentPageNumber() const
 {
 	return m_currentPage->pageNr();
 }
@@ -6477,9 +6480,9 @@ bool ScribusDoc::itemNameExists(const QS
 	// Process groups
 	while (!groups.empty())
 	{
-		PageItem* item = groups.back();
+		const PageItem* backItem = groups.back();
 		groups.pop_back();
-		for (PageItem* item: item->groupItemList)
+		for (PageItem* item: backItem->groupItemList)
 		{
 			if (item->itemName() == checkItemName)
 				return true;
@@ -6885,7 +6888,7 @@ QString ScribusDoc::getSectionNameForPag
 }
 
 
-const QString ScribusDoc::getSectionPageNumberForPageIndex(uint pageIndex) const
+QString ScribusDoc::getSectionPageNumberForPageIndex(uint pageIndex) const
 {
 	QString retVal;
 	int key = getSectionKeyForPageIndex(pageIndex);
@@ -6903,7 +6906,7 @@ const QString ScribusDoc::getSectionPage
 	return retVal;
 }
 
-const QChar ScribusDoc::getSectionPageNumberFillCharForPageIndex(uint pageIndex) const
+QChar ScribusDoc::getSectionPageNumberFillCharForPageIndex(uint pageIndex) const
 {
 	QChar retVal;
 	int key = getSectionKeyForPageIndex(pageIndex);
@@ -6943,7 +6946,8 @@ void ScribusDoc::updateSectionPageNumber
 
 void ScribusDoc::addPageToSection(uint otherPageIndex, uint location, uint count)
 {
-	uint fromIndex, toIndex;
+	uint fromIndex;
+	uint toIndex;
 	uint searchedIndex = (otherPageIndex > 0) ? (otherPageIndex - 1) : 0;
 	if ((location == 0) && (searchedIndex > 0))
 		--searchedIndex;
@@ -7101,8 +7105,7 @@ void ScribusDoc::copyPage(int pageNumber
 				}
 				if (tempSelection.count() != 0)
 				{
-					ScriXmlDoc ss;
-					QString dataS = ss.writeElem(this, &tempSelection);
+					QString dataS = ScriXmlDoc::writeElem(this, &tempSelection);
 					itemBuffer.append(dataS);
 				}
 				else
@@ -7170,7 +7173,6 @@ void ScribusDoc::copyPage(int pageNumber
 		if (itemBuffer.count() > 0)
 		{
 			int lcount = 0;
-			ScLayers::iterator it;
 			if (Layers.count() != 0)
 			{
 				int currActiveLayer = activeLayer();
@@ -7180,7 +7182,7 @@ void ScribusDoc::copyPage(int pageNumber
 				this->SnapGrid   = false;
 				this->SnapGuides = false;
 				this->SnapElement = false;
-				for (it = Layers.begin(); it != Layers.end(); ++it)
+				for (auto it = Layers.begin(); it != Layers.end(); ++it)
 				{
 					if ((lcount < itemBuffer.count()) && !itemBuffer[lcount].isEmpty())
 					{
@@ -7314,7 +7316,7 @@ void ScribusDoc::RecalcPictures(Profiles
 	}
 }
 
-void ScribusDoc::RecalcPictures(QList<PageItem*>* items, ProfilesL *Pr, ProfilesL *PrCMYK, QProgressBar *dia)
+void ScribusDoc::RecalcPictures(const QList<PageItem*>* items, ProfilesL *Pr, ProfilesL *PrCMYK, QProgressBar *dia)
 {
 	if (items->isEmpty())
 		return;
@@ -7325,7 +7327,7 @@ void ScribusDoc::RecalcPictures(QList<Pa
 		counter = dia->value();
 	PageItem* it;
 	int docItemCount = items->count();
-	for (int i=0; i < docItemCount; ++i)
+	for (int i = 0; i < docItemCount; ++i)
 	{
 		it = items->at(i);
 		if (it->isGroup())
@@ -7372,8 +7374,8 @@ void ScribusDoc::insertColor(const QStri
 
 struct objOrdHelper
 {
-	int objNrSel;
-	PageItem* parent;
+	int objNrSel { 0 };
+	PageItem* parent { nullptr };
 };
 
 void ScribusDoc::sendItemSelectionToBack()
@@ -7391,7 +7393,7 @@ void ScribusDoc::sendItemSelectionToBack
 	}
 	if (docSelectionCount > 1)
 	{
-		PageItem *firstItem = m_Selection->itemAt(0);
+		const PageItem *firstItem = m_Selection->itemAt(0);
 		for (int a = 1; a < docSelectionCount; ++a)
 		{
 			if (m_Selection->itemAt(a)->Parent != firstItem->Parent)
@@ -7458,7 +7460,7 @@ void ScribusDoc::bringItemSelectionToFro
 	}
 	if (docSelectionCount > 1)
 	{
-		PageItem *firstItem = m_Selection->itemAt(0);
+		const PageItem *firstItem = m_Selection->itemAt(0);
 		for (int a = 1; a < docSelectionCount; ++a)
 		{
 			if (m_Selection->itemAt(a)->Parent != firstItem->Parent)
@@ -7525,7 +7527,7 @@ void ScribusDoc::itemSelection_LowerItem
 	}
 	if (docSelectionCount > 1)
 	{
-		PageItem *firstItem = m_Selection->itemAt(0);
+		const PageItem *firstItem = m_Selection->itemAt(0);
 		for (int a = 1; a < docSelectionCount; ++a)
 		{
 			if (m_Selection->itemAt(a)->Parent != firstItem->Parent)
@@ -7570,9 +7572,9 @@ void ScribusDoc::itemSelection_LowerItem
 	}
 	d = itemList->indexOf(b2);
 	QList<int> Oindex = ObjOrder.values();
-	for (int c = static_cast<int>(Oindex.count()-1); c > -1; c--)
+	for (int c = Oindex.count() - 1; c > -1; c--)
 	{
-		itemList->insert(d+1, m_Selection->itemAt(Oindex[c]));
+		itemList->insert(d + 1, m_Selection->itemAt(Oindex[c]));
 	}
 	m_Selection->clear();
 	*m_Selection = tempSelection;
@@ -7597,7 +7599,7 @@ void ScribusDoc::itemSelection_RaiseItem
 	}
 	if (docSelectionCount > 1)
 	{
-		PageItem *firstItem = m_Selection->itemAt(0);
+		const PageItem *firstItem = m_Selection->itemAt(0);
 		for (int a = 1; a < docSelectionCount; ++a)
 		{
 			if (m_Selection->itemAt(a)->Parent != firstItem->Parent)
@@ -7641,7 +7643,7 @@ void ScribusDoc::itemSelection_RaiseItem
 		itemList->takeAt(d);
 	}
 	QList<int> Oindex = ObjOrder.values();
-	for (int i = 0; i <static_cast<int>(Oindex.count()); ++i)
+	for (int i = 0; i < Oindex.count(); ++i)
 	{
 		int d = itemList->indexOf(b2);
 		if (d == -1)
@@ -7821,7 +7823,7 @@ void ScribusDoc::itemSelection_SetFont(c
 	{
 		if (!AddFont(font))
 		{
-			PageItem *currItem = itemSelection->itemAt(0);
+			const PageItem *currItem = itemSelection->itemAt(0);
 			newFont = currItem->currentCharStyle().font().scName();
 		}
 	}
@@ -8551,30 +8553,31 @@ void ScribusDoc::itemSelection_InsertTab
 	if (!table)
 		return;
 
-	QScopedPointer<InsertTableRowsDialog> dialog(new InsertTableRowsDialog(appMode, m_ScMW));
-	if (dialog->exec() == QDialog::Accepted)
-	{
-		QScopedValueRollback<bool> dontResizeRb(dontResize, true);
-		/*
-		 * In table edit mode we insert either before or after the active
-		 * cell, otherwise we insert at beginning or end of table.
-		 */
-		int index = 0;
-		const TableCell cell = table->activeCell();
-		if (dialog->position() == InsertTableRowsDialog::Before)
-			index = appMode == modeEditTable ? cell.row() : 0;
-		else
-			index = appMode == modeEditTable ? cell.row() + cell.rowSpan() : table->rows();
-
-		// Insert the rows.
-		table->insertRows(index, dialog->numberOfRows());
-		table->clearSelection();
-		table->adjustTable();
-		table->update();
+	using InsertTableRowsDialogDeleter = QScopedPointerObjectDeleteLater<InsertTableRowsDialog>;
+	QScopedPointer<InsertTableRowsDialog, InsertTableRowsDialogDeleter> dialog(new InsertTableRowsDialog(appMode, m_ScMW));
+	if (dialog->exec() != QDialog::Accepted)
+		return;
 
-		m_ScMW->updateTableMenuActions();
-		changed();
-	}
+	QScopedValueRollback<bool> dontResizeRb(dontResize, true);
+	/*
+	 * In table edit mode we insert either before or after the active
+	 * cell, otherwise we insert at beginning or end of table.
+	 */
+	int index = 0;
+	const TableCell cell = table->activeCell();
+	if (dialog->position() == InsertTableRowsDialog::Before)
+		index = appMode == modeEditTable ? cell.row() : 0;
+	else
+		index = appMode == modeEditTable ? cell.row() + cell.rowSpan() : table->rows();
+
+	// Insert the rows.
+	table->insertRows(index, dialog->numberOfRows());
+	table->clearSelection();
+	table->adjustTable();
+	table->update();
+
+	m_ScMW->updateTableMenuActions();
+	changed();
 }
 
 void ScribusDoc::itemSelection_InsertTableColumns()
@@ -8587,32 +8590,31 @@ void ScribusDoc::itemSelection_InsertTab
 	if (!table)
 		return;
 
-	QPointer<InsertTableColumnsDialog> dialog = new InsertTableColumnsDialog(appMode, m_ScMW);
-	if (dialog->exec() == QDialog::Accepted)
-	{
-		QScopedValueRollback<bool> dontResizeRb(dontResize, true);
-		/*
-		 * In table edit mode we insert either before or after the active
-		 * cell, otherwise we insert at beginning or end of table.
-		 */
-		int index = 0;
-		const TableCell cell = table->activeCell();
-		if (dialog->position() == InsertTableColumnsDialog::Before)
-			index = appMode == modeEditTable ? cell.column() : 0;
-		else
-			index = appMode == modeEditTable ? cell.column() + cell.columnSpan() : table->columns();
-
-		// Insert the columns.
-		table->insertColumns(index, dialog->numberOfColumns());
-		table->clearSelection();
-		table->adjustTable();
-		table->update();
+	using InsertTableColumnsDialogDeleter = QScopedPointerObjectDeleteLater<InsertTableColumnsDialog>;
+	QScopedPointer<InsertTableColumnsDialog, InsertTableColumnsDialogDeleter> dialog(new InsertTableColumnsDialog(appMode, m_ScMW));
+	if (dialog->exec() != QDialog::Accepted)
+		return;
 
-		m_ScMW->updateTableMenuActions();
-		changed();
-	}
+	QScopedValueRollback<bool> dontResizeRb(dontResize, true);
+	/*
+	 * In table edit mode we insert either before or after the active
+	 * cell, otherwise we insert at beginning or end of table.
+	 */
+	int index = 0;
+	const TableCell cell = table->activeCell();
+	if (dialog->position() == InsertTableColumnsDialog::Before)
+		index = appMode == modeEditTable ? cell.column() : 0;
+	else
+		index = appMode == modeEditTable ? cell.column() + cell.columnSpan() : table->columns();
+
+	// Insert the columns.
+	table->insertColumns(index, dialog->numberOfColumns());
+	table->clearSelection();
+	table->adjustTable();
+	table->update();
 
-	delete dialog;
+	m_ScMW->updateTableMenuActions();
+	changed();
 }
 
 void ScribusDoc::itemSelection_DeleteTableRows()
@@ -8776,8 +8778,9 @@ void ScribusDoc::itemSelection_SetTableR
 	if (!table)
 		return;
 
-	QPointer<TableRowHeightsDialog> dialog = new TableRowHeightsDialog(this, m_ScMW);
-	if (dialog->exec() == QDialog::Rejected)
+	using TableRowHeightsDialogDeleter = QScopedPointerObjectDeleteLater<TableRowHeightsDialog>;
+	QScopedPointer<TableRowHeightsDialog, TableRowHeightsDialogDeleter> dialog(new TableRowHeightsDialog(this, m_ScMW));
+	if (dialog->exec() != QDialog::Accepted)
 		return;
 
 	const qreal rowHeight = dialog->rowHeight();
@@ -8811,7 +8814,6 @@ void ScribusDoc::itemSelection_SetTableR
 		for (int row = 0; row < table->rows(); ++row)
 			table->resizeRow(row, rowHeight / unitRatio());
 	}
-	delete dialog;
 	table->adjustTable();
 	table->update();
 	if (activeTransaction)
@@ -8830,8 +8832,9 @@ void ScribusDoc::itemSelection_SetTableC
 	if (!table)
 		return;
 
-	QPointer<TableColumnWidthsDialog> dialog = new TableColumnWidthsDialog(this, m_ScMW);
-	if (dialog->exec() == QDialog::Rejected)
+	using TableColumnWidthsDialogDeleter = QScopedPointerObjectDeleteLater<TableColumnWidthsDialog>;
+	QScopedPointer<TableColumnWidthsDialog, TableColumnWidthsDialogDeleter> dialog(new TableColumnWidthsDialog(this, m_ScMW));
+	if (dialog->exec() != QDialog::Accepted)
 		return;
 
 	const qreal columnWidth = dialog->columnWidth();
@@ -8867,8 +8870,6 @@ void ScribusDoc::itemSelection_SetTableC
 			table->resizeColumn(column, columnWidth / unitRatio());
 	}
 
-	delete dialog;
-
 	table->adjustTable();
 	table->update();
 	if (activeTransaction)
@@ -9319,7 +9320,7 @@ void ScribusDoc::itemSelection_ApplyPara
 	UndoTransaction activeTransaction;
 	if (UndoManager::undoEnabled())
 	{
-		PageItem* currItem = itemSelection->itemAt(0);
+		const PageItem* currItem = itemSelection->itemAt(0);
 		QString  targetName = (selectedItemCount > 1) ? Um::SelectionGroup : currItem->getUName();
 		QPixmap* targetPixmap = (selectedItemCount > 1) ? Um::IGroup : currItem->getUPixmap();
 		activeTransaction = m_undoManager->beginTransaction(targetName, targetPixmap, Um::ApplyTextStyle, newStyle.displayName(), Um::IFont);
@@ -9409,7 +9410,7 @@ void ScribusDoc::itemSelection_ApplyChar
 	UndoTransaction activeTransaction;
 	if (UndoManager::undoEnabled())
 	{
-		PageItem* currItem = itemSelection->itemAt(0);
+		const PageItem* currItem = itemSelection->itemAt(0);
 		QString  targetName = (selectedItemCount > 1) ? Um::SelectionGroup : currItem->getUName();
 		QPixmap* targetPixmap = (selectedItemCount > 1) ? Um::IGroup : currItem->getUPixmap();
 		activeTransaction = m_undoManager->beginTransaction(targetName, targetPixmap, Um::ApplyTextStyle, newStyle.asString(), Um::IFont);
@@ -10091,19 +10092,19 @@ void ScribusDoc::recalcPicturesRes(int r
 
 	for (itemIt.begin(DocItems); *itemIt; ++itemIt)
 	{
-		PageItem *currItem = *itemIt;
+		const PageItem *currItem = *itemIt;
 		if (currItem->imageIsAvailable)
 			imageCount++;
 	}
 	for (itemIt.begin(MasterItems); *itemIt; ++itemIt)
 	{
-		PageItem *currItem = *itemIt;
+		const PageItem *currItem = *itemIt;
 		if (currItem->imageIsAvailable)
 			imageCount++;
 	}
 	for (itemIt.begin(frameItemList); *itemIt; ++itemIt)
 	{
-		PageItem *currItem = *itemIt;
+		const PageItem *currItem = *itemIt;
 		if (currItem->imageIsAvailable)
 			imageCount++;
 	}
@@ -10113,7 +10114,7 @@ void ScribusDoc::recalcPicturesRes(int r
 		const ScPattern& pa = patIt.value();
 		for (itemIt.begin(pa.items); *itemIt; ++itemIt)
 		{
-			PageItem *currItem = *itemIt;
+			const PageItem *currItem = *itemIt;
 			if (currItem->imageIsAvailable)
 				imageCount++;
 		}
@@ -10383,7 +10384,7 @@ void ScribusDoc::updatePic()
 		}
 		else if ((currItem->isImageFrame()) || (currItem->isOSGFrame()))
 		{
-			if (currItem->imageIsAvailable)
+			if (!currItem->Pfile.isEmpty())
 			{
 				int fho = currItem->imageFlippedH();
 				int fvo = currItem->imageFlippedV();
@@ -10591,7 +10592,7 @@ void ScribusDoc::itemSelection_Transform
 	if (nrOfCopies == 0)
 	{
 		double gx, gy, gh, gw;
-		PageItem *currItem = m_Selection->itemAt(0);
+		const PageItem *currItem = m_Selection->itemAt(0);
 		if (m_Selection->count() == 1)
 		{
 			gx = currItem->xPos();
@@ -11135,10 +11136,10 @@ void ScribusDoc::allItems_ChangePreviewR
 	changed();
 }
 
-void ScribusDoc::item_setFrameShape(PageItem* item, int frameType, int count, double* points)
+void ScribusDoc::item_setFrameShape(PageItem* item, int frameType, int count, const double* points)
 {
 	if ((item->itemType() == PageItem::PolyLine) || (item->itemType() == PageItem::PathText))
-			return;
+		return;
 	UndoTransaction activeTransaction;
 	if (UndoManager::undoEnabled())
 		activeTransaction = m_undoManager->beginTransaction(Um::Selection, Um::IImageFrame, Um::ChangeShapeType, QString(), Um::IBorder);
@@ -11162,7 +11163,7 @@ void ScribusDoc::item_setFrameShape(Page
 		for (int i = 0; i < count/2; ++i)
 		{
 			double x = item->width()  * points[ix] / 100.0;
-			double y = item->height() * points[ix+1] / 100.0;
+			double y = item->height() * points[ix + 1] / 100.0;
 			newShape.addPoint(x, y);
 			ix += 2;
 		}
@@ -11783,6 +11784,35 @@ void ScribusDoc::itemSelection_SetMaskGr
 	changed();
 }
 
+void ScribusDoc::itemSelection_SetFillRule(bool evenOdd, Selection* customSelection)
+{
+	Selection* itemSelection = (customSelection != nullptr) ? customSelection : m_Selection;
+	assert(itemSelection != nullptr);
+	int selectedItemCount = itemSelection->count();
+	if (selectedItemCount == 0)
+		return;
+
+	m_updateManager.setUpdatesDisabled();
+
+	UndoTransaction activeTransaction;
+	if (UndoManager::undoEnabled())
+		activeTransaction = m_undoManager->beginTransaction();
+
+	for (int i = 0; i < selectedItemCount; ++i)
+	{
+		PageItem* currItem = itemSelection->itemAt(i);
+		if (currItem->isPathText() || currItem->isTextFrame() || currItem->isImageFrame())
+			continue;
+		currItem->setFillEvenOdd(evenOdd);
+		currItem->update();
+	}
+
+	if (activeTransaction)
+		activeTransaction.commit(Um::Selection, Um::IGroup, Um::SetFillRule, "", Um::IGroup);
+
+	m_updateManager.setUpdatesEnabled();
+	changed();
+}
 
 void ScribusDoc::itemSelection_SetOverprint(bool overprint, Selection* customSelection)
 {
@@ -12101,7 +12131,7 @@ bool ScribusDoc::startAlign(uint minObje
 	}
 	
 	QString targetTooltip;
-	if (m_Selection->count() <= (int) Um::ItemsInvolvedLimit)
+	if (m_Selection->count() <= Um::ItemsInvolvedLimit)
 	{
 		targetTooltip = Um::ItemsInvolved + "\n";
 		for (int i = 0; i < m_Selection->count(); ++i)
@@ -12206,7 +12236,8 @@ void ScribusDoc::itemSelection_AlignLeft
 	if (!startAlign())
 		return;
 	int alignObjectsCount = AObjects.count();
-	int loopStart = 0, loopEnd = alignObjectsCount - 1;
+	int loopStart = 0;
+	int loopEnd = alignObjectsCount - 1;
 	double newX = std::numeric_limits<double>::max();
 	switch (currAlignTo)
 	{
@@ -12215,7 +12246,7 @@ void ScribusDoc::itemSelection_AlignLeft
 			loopStart = 1;
 			break;
 		case alignLast:
-			newX = AObjects[alignObjectsCount-1].x1;
+			newX = AObjects[alignObjectsCount - 1].x1;
 			loopEnd = alignObjectsCount - 2;
 			break;
 		case alignPage:
@@ -12244,16 +12275,17 @@ void ScribusDoc::itemSelection_AlignLeft
 	if (!startAlign())
 		return;
 	int alignObjectsCount = AObjects.count();
-	int loopStart = 0, loopEnd = alignObjectsCount - 1;
+	int loopStart = 0;
+	int loopEnd = alignObjectsCount - 1;
 	double newX = std::numeric_limits<double>::max();
-	switch ( currAlignTo ) 
+	switch (currAlignTo)
 	{
 		case alignFirst:
 			newX = AObjects[0].x1;
 			loopStart = 1;
 			break;
 		case alignLast:
-			newX = AObjects[alignObjectsCount-1].x1;
+			newX = AObjects[alignObjectsCount - 1].x1;
 			loopEnd = alignObjectsCount - 2;
 			break;
 		case alignPage:
@@ -12339,7 +12371,7 @@ void ScribusDoc::itemSelection_AlignRigh
 	int loopStart = 0;
 	int loopEnd = alignObjectsCount - 1;
 	double newX = -std::numeric_limits<double>::max();
-	switch ( currAlignTo ) 
+	switch (currAlignTo)
 	{
 		case alignFirst:
 			newX = AObjects[0].x2;
@@ -12380,7 +12412,7 @@ void ScribusDoc::itemSelection_AlignRigh
 	int loopStart = 0;
 	int loopEnd = alignObjectsCount - 1;
 	double newX = -std::numeric_limits<double>::max();
-	switch ( currAlignTo ) 
+	switch (currAlignTo)
 	{
 		case alignFirst:
 			newX = AObjects[0].x2;
@@ -12421,7 +12453,7 @@ void ScribusDoc::itemSelection_AlignTopO
 	int loopStart = 0;
 	int loopEnd = alignObjectsCount - 1;
 	double newY = std::numeric_limits<double>::max();
-	switch ( currAlignTo ) 
+	switch (currAlignTo)
 	{
 		case alignFirst:
 			newY = AObjects[0].y1;
@@ -12460,7 +12492,7 @@ void ScribusDoc::itemSelection_AlignTopI
 	int loopStart = 0;
 	int loopEnd = alignObjectsCount - 1;
 	double newY = std::numeric_limits<double>::max();
-	switch ( currAlignTo ) 
+	switch (currAlignTo)
 	{
 		case alignFirst:
 			newY = AObjects[0].y1;
@@ -12499,10 +12531,10 @@ void ScribusDoc::itemSelection_AlignCent
 	int loopStart = 0;
 	int loopEnd = alignObjectsCount - 1;
 	double newY = 0.0;
-	switch ( currAlignTo ) 
+	switch (currAlignTo)
 	{
 		case alignFirst:
-			newY = AObjects[0].y1 + (AObjects[0].height)/2;
+			newY = AObjects[0].y1 + (AObjects[0].height) / 2;
 			loopStart = 1;
 			break;
 		case alignLast:
@@ -12514,7 +12546,7 @@ void ScribusDoc::itemSelection_AlignCent
 			break;
 		case alignPage:
 			newY = m_currentPage->yOffset();
-			newY += m_currentPage->height()/2;
+			newY += m_currentPage->height() / 2;
 			break;
 		case alignMargins:
 			newY = m_currentPage->yOffset();
@@ -12553,7 +12585,7 @@ void ScribusDoc::itemSelection_AlignBott
 	int loopStart = 0;
 	int loopEnd = alignObjectsCount - 1;
 	double newY = -std::numeric_limits<double>::max();
-	switch ( currAlignTo ) 
+	switch (currAlignTo)
 	{
 		case alignFirst:
 			newY = AObjects[0].y2;
@@ -12594,7 +12626,7 @@ void ScribusDoc::itemSelection_AlignBott
 	int loopStart = 0;
 	int loopEnd = alignObjectsCount - 1;
 	double newY = -std::numeric_limits<double>::max();
-	switch ( currAlignTo )
+	switch (currAlignTo)
 	{
 		case alignFirst:
 			newY = AObjects[0].y2;
@@ -12632,14 +12664,14 @@ void ScribusDoc::itemSelection_Distribut
 	if (!startAlign(2))
 		return;
 	int alignObjectsCount = AObjects.count();
-	QMap<double,uint> Xsorted;
+	QMap<double, uint> xSorted;
 	for (int i = 0; i < alignObjectsCount; ++i)
 	{
-		if (!Xsorted.contains(AObjects[i].x1))
-			Xsorted.insert(AObjects[i].x1, i);
+		if (!xSorted.contains(AObjects[i].x1))
+			xSorted.insert(AObjects[i].x1, i);
 	}
-	QMap<double,uint>::Iterator it = Xsorted.begin();
-	QMap<double,uint>::Iterator itend = Xsorted.end();
+	QMap<double, uint>::Iterator it = xSorted.begin();
+	QMap<double, uint>::Iterator itend = xSorted.end();
 	double minX = it.key();
 	double maxX = it.key();
 	while ( it != itend)
@@ -12653,7 +12685,7 @@ void ScribusDoc::itemSelection_Distribut
 		
 	double separation = (maxX - minX) / static_cast<double>(alignObjectsCount - 1);
 	int i = 0;
-	for (QMap<double,uint>::Iterator it = Xsorted.begin(); it != Xsorted.end(); ++it)
+	for (auto it = xSorted.begin(); it != xSorted.end(); ++it)
 	{
 		double diff = minX + i * separation - AObjects[it.value()].x1;
 		if (!AObjects[it.value()].Object->locked())
@@ -12669,14 +12701,14 @@ void ScribusDoc::itemSelection_Distribut
 	if (!startAlign(2))
 		return;
 	int alignObjectsCount = AObjects.count();
-	QMap<double,uint> Xsorted;
+	QMap<double, uint> xSorted;
 	for (int i = 0; i < alignObjectsCount; ++i)
 	{
-		if (!Xsorted.contains(AObjects[i].x1 + (AObjects[i].width) / 2))
-			Xsorted.insert(AObjects[i].x1 + (AObjects[i].width) / 2, i);
+		if (!xSorted.contains(AObjects[i].x1 + (AObjects[i].width) / 2))
+			xSorted.insert(AObjects[i].x1 + (AObjects[i].width) / 2, i);
 	}
-	QMap<double,uint>::Iterator it = Xsorted.begin();
-	QMap<double,uint>::Iterator itend = Xsorted.end();
+	QMap<double, uint>::Iterator it = xSorted.begin();
+	QMap<double, uint>::Iterator itend = xSorted.end();
 	double minX = it.key();
 	double maxX = it.key();
 	while ( it != itend)
@@ -12690,7 +12722,7 @@ void ScribusDoc::itemSelection_Distribut
 		
 	double separation = (maxX - minX) / static_cast<double>(alignObjectsCount - 1);
 	int i = 0;
-	for (QMap<double,uint>::Iterator it = Xsorted.begin(); it != Xsorted.end(); ++it)
+	for (auto it = xSorted.begin(); it != xSorted.end(); ++it)
 	{
 		double diff = minX + i * separation - AObjects[it.value()].x1 - (AObjects[it.value()].width) / 2;
 		if (!AObjects[it.value()].Object->locked())
@@ -12706,14 +12738,14 @@ void ScribusDoc::itemSelection_Distribut
 	if (!startAlign(2))
 		return;
 	int alignObjectsCount = AObjects.count();
-	QMap<double,uint> Xsorted;
+	QMap<double, uint> xSorted;
 	for (int i = 0; i < alignObjectsCount; ++i)
 	{
-		if (!Xsorted.contains(AObjects[i].x2))
-			Xsorted.insert(AObjects[i].x2, i);
+		if (!xSorted.contains(AObjects[i].x2))
+			xSorted.insert(AObjects[i].x2, i);
 	}
-	QMap<double,uint>::Iterator it = Xsorted.begin();
-	QMap<double,uint>::Iterator itend = Xsorted.end();
+	QMap<double, uint>::Iterator it = xSorted.begin();
+	QMap<double, uint>::Iterator itend = xSorted.end();
 	double minX = it.key();
 	double maxX = it.key();
 	while ( it != itend)
@@ -12725,9 +12757,9 @@ void ScribusDoc::itemSelection_Distribut
 		++it;
 	}
 	
-	double separation=(maxX-minX)/static_cast<double>(alignObjectsCount-1);
-	int i=0;
-	for (QMap<double,uint>::Iterator it = Xsorted.begin(); it != Xsorted.end(); ++it)
+	double separation = (maxX - minX) / static_cast<double>(alignObjectsCount - 1);
+	int i = 0;
+	for (auto it = xSorted.begin(); it != xSorted.end(); ++it)
 	{
 		double diff = minX + i * separation - AObjects[it.value()].x2;
 		if (!AObjects[it.value()].Object->locked())
@@ -12743,7 +12775,8 @@ void ScribusDoc::itemSelection_Distribut
 	if (!startAlign(2))
 		return;
 	int alignObjectsCount = AObjects.count();
-	QMap<double, int> x1Sorted, x2Sorted;
+	QMap<double, int> x1Sorted;
+	QMap<double, int> x2Sorted;
 	for (int i = 0; i < alignObjectsCount; ++i)
 	{
 		if (!x1Sorted.contains(AObjects[i].x1))
@@ -12824,14 +12857,14 @@ void ScribusDoc::itemSelection_Distribut
 	if (!startAlign(2))
 		return;
 	int alignObjectsCount = AObjects.count();
-	QMap<double,uint> Ysorted;
+	QMap<double, uint> ySorted;
 	for (int i = 0; i < alignObjectsCount; ++i)
 	{
-		if (!Ysorted.contains(AObjects[i].y2))
-			Ysorted.insert(AObjects[i].y2, i);
+		if (!ySorted.contains(AObjects[i].y2))
+			ySorted.insert(AObjects[i].y2, i);
 	}
-	QMap<double,uint>::Iterator it = Ysorted.begin();
-	QMap<double,uint>::Iterator itend = Ysorted.end();
+	QMap<double, uint>::Iterator it = ySorted.begin();
+	QMap<double, uint>::Iterator itend = ySorted.end();
 	double minY = it.key();
 	double maxY = it.key();
 	while ( it != itend)
@@ -12845,7 +12878,7 @@ void ScribusDoc::itemSelection_Distribut
 		
 	double separation = (maxY - minY) / static_cast<double>(alignObjectsCount - 1);
 	int i = 0;
-	for (QMap<double,uint>::Iterator it = Ysorted.begin(); it != Ysorted.end(); ++it)
+	for (auto it = ySorted.begin(); it != ySorted.end(); ++it)
 	{
 		double diff = minY + i * separation - AObjects[it.value()].y2;
 		if (!AObjects[it.value()].Object->locked())
@@ -12861,14 +12894,14 @@ void ScribusDoc::itemSelection_Distribut
 	if (!startAlign(2))
 		return;
 	int alignObjectsCount = AObjects.count();
-	QMap<double,uint> Ysorted;
+	QMap<double, uint> ySorted;
 	for (int i = 0; i < alignObjectsCount; ++i)
 	{
-		if (!Ysorted.contains(AObjects[i].y1 + (AObjects[i].height) / 2))
-			Ysorted.insert(AObjects[i].y1 + (AObjects[i].height) / 2, i);
+		if (!ySorted.contains(AObjects[i].y1 + (AObjects[i].height) / 2))
+			ySorted.insert(AObjects[i].y1 + (AObjects[i].height) / 2, i);
 	}
-	QMap<double,uint>::Iterator it = Ysorted.begin();
-	QMap<double,uint>::Iterator itend = Ysorted.end();
+	QMap<double, uint>::Iterator it = ySorted.begin();
+	QMap<double, uint>::Iterator itend = ySorted.end();
 	double minY = it.key();
 	double maxY = it.key();
 	while ( it != itend)
@@ -12882,7 +12915,7 @@ void ScribusDoc::itemSelection_Distribut
 		
 	double separation = (maxY - minY) / static_cast<double>(alignObjectsCount - 1);
 	int i = 0;
-	for (QMap<double,uint>::Iterator it = Ysorted.begin(); it != Ysorted.end(); ++it)
+	for (auto it = ySorted.begin(); it != ySorted.end(); ++it)
 	{
 		double diff = minY + i * separation - AObjects[it.value()].y1 - AObjects[it.value()].height / 2;
 		if (!AObjects[it.value()].Object->locked())
@@ -12898,14 +12931,14 @@ void ScribusDoc::itemSelection_Distribut
 	if (!startAlign(2))
 		return;
 	int alignObjectsCount = AObjects.count();
-	QMap<double,uint> Ysorted;
+	QMap<double, uint> ySorted;
 	for (int i = 0; i < alignObjectsCount; ++i)
 	{
-		if (!Ysorted.contains(AObjects[i].y1))
-			Ysorted.insert(AObjects[i].y1, i);
+		if (!ySorted.contains(AObjects[i].y1))
+			ySorted.insert(AObjects[i].y1, i);
 	}
-	QMap<double,uint>::Iterator it = Ysorted.begin();
-	QMap<double,uint>::Iterator itend = Ysorted.end();
+	QMap<double, uint>::Iterator it = ySorted.begin();
+	QMap<double, uint>::Iterator itend = ySorted.end();
 	double minY = it.key();
 	double maxY = it.key();
 	while ( it != itend)
@@ -12919,7 +12952,7 @@ void ScribusDoc::itemSelection_Distribut
 		
 	double separation = (maxY - minY) / static_cast<double>(alignObjectsCount - 1);
 	int i = 0;
-	for (QMap<double,uint>::Iterator it = Ysorted.begin(); it != Ysorted.end(); ++it)
+	for (auto it = ySorted.begin(); it != ySorted.end(); ++it)
 	{
 		double diff = minY + i * separation - AObjects[it.value()].y1;
 		if (!AObjects[it.value()].Object->locked())
@@ -13126,14 +13159,14 @@ void ScribusDoc::itemSelection_SwapLeft(
 	QList<int> circleList;
 	int circleListCounter = 0;
 	//X
-	QMap<double,uint> Xsorted;
+	QMap<double, uint> xSorted;
 	for (int i = 0; i < alignObjectsCount; ++i)
 	{
-		if (!Xsorted.contains(AObjects[i].x1))
-			Xsorted.insert(AObjects[i].x1, i);
+		if (!xSorted.contains(AObjects[i].x1))
+			xSorted.insert(AObjects[i].x1, i);
 	}
-	QMap<double,uint>::Iterator itX = Xsorted.begin();
-	QMap<double,uint>::Iterator itXend = Xsorted.end();
+	QMap<double, uint>::Iterator itX = xSorted.begin();
+	QMap<double, uint>::Iterator itXend = xSorted.end();
 	double minX = itX.key();
 	double maxX = itX.key();
 	while (itX != itXend)
@@ -13145,14 +13178,14 @@ void ScribusDoc::itemSelection_SwapLeft(
 		++itX;
 	}
 	//Y
-	QMap<double,uint> Ysorted;
+	QMap<double, uint> ySorted;
 	for (int i = 0; i < alignObjectsCount; ++i)
 	{
-		if (!Ysorted.contains(AObjects[i].y1))
-			Ysorted.insert(AObjects[i].y1, i);
+		if (!ySorted.contains(AObjects[i].y1))
+			ySorted.insert(AObjects[i].y1, i);
 	}
-	QMap<double,uint>::Iterator itY = Ysorted.begin();
-	QMap<double,uint>::Iterator itYend = Ysorted.end();
+	QMap<double, uint>::Iterator itY = ySorted.begin();
+	QMap<double, uint>::Iterator itYend = ySorted.end();
 	double minY = itY.key();
 	double maxY = itY.key();
 	while (itY != itYend)
@@ -13164,7 +13197,7 @@ void ScribusDoc::itemSelection_SwapLeft(
 		++itY;
 	}
 
-	itX = Xsorted.begin(); //first item is left most
+	itX = xSorted.begin(); //first item is left most
 	int itemIndex = itX.value(); //get our first item's index in the AObjects array
 //	bool found = false;
 //	double itXX = itX.key();
@@ -13175,10 +13208,10 @@ void ScribusDoc::itemSelection_SwapLeft(
 	++circleListCounter;
 	// find the next X item with the minimum Y
 
-	QMap<double,uint>::Iterator itX2_1 = Xsorted.begin();
-	QMap<double,uint>::Iterator itLast = Xsorted.begin();
+	QMap<double, uint>::Iterator itX2_1 = xSorted.begin();
+	QMap<double, uint>::Iterator itLast = xSorted.begin();
 	double xBeginYValue = AObjects[itX2_1.value()].y1;
-	while (itX2_1 != Xsorted.end())
+	while (itX2_1 != xSorted.end())
 	{
 		if (AObjects[itX2_1.value()].y1 < xBeginYValue)
 		{
@@ -13190,10 +13223,10 @@ void ScribusDoc::itemSelection_SwapLeft(
 	}
 
 
-	if (circleListCounter != static_cast<int>(alignObjectsCount)) //need to reverse back now
+	if (circleListCounter != alignObjectsCount) //need to reverse back now
 	{
-		QMap<double,uint>::Iterator itX2_2 = itLast;
-		while (itX2_2 != Xsorted.begin())
+		QMap<double, uint>::Iterator itX2_2 = itLast;
+		while (itX2_2 != xSorted.begin())
 		{
 			if (AObjects[itX2_2.value()].y1 >= xBeginYValue)
 			{
@@ -13235,14 +13268,14 @@ void ScribusDoc::itemSelection_SwapRight
 	QList<int> circleList;
 	int circleListCounter = 0;
 	//X
-	QMap<double,uint> Xsorted;
+	QMap<double, uint> xSorted;
 	for (int i = 0; i < alignObjectsCount; ++i)
 	{
-		if (!Xsorted.contains(AObjects[i].x1))
-			Xsorted.insert(AObjects[i].x1, i);
+		if (!xSorted.contains(AObjects[i].x1))
+			xSorted.insert(AObjects[i].x1, i);
 	}
-	QMap<double,uint>::Iterator itX = Xsorted.begin();
-	QMap<double,uint>::Iterator itXend = Xsorted.end();
+	QMap<double, uint>::Iterator itX = xSorted.begin();
+	QMap<double, uint>::Iterator itXend = xSorted.end();
 	double minX = itX.key();
 	double maxX = itX.key();
 	while (itX != itXend)
@@ -13254,14 +13287,14 @@ void ScribusDoc::itemSelection_SwapRight
 		++itX;
 	}
 	//Y
-	QMap<double,uint> Ysorted;
+	QMap<double, uint> ySorted;
 	for (int i = 0; i < alignObjectsCount; ++i)
 	{
-		if (!Ysorted.contains(AObjects[i].y1))
-			Ysorted.insert(AObjects[i].y1, i);
+		if (!ySorted.contains(AObjects[i].y1))
+			ySorted.insert(AObjects[i].y1, i);
 	}
-	QMap<double,uint>::Iterator itY = Ysorted.begin();
-	QMap<double,uint>::Iterator itYend = Ysorted.end();
+	QMap<double, uint>::Iterator itY = ySorted.begin();
+	QMap<double, uint>::Iterator itYend = ySorted.end();
 	double minY = itY.key();
 	double maxY = itY.key();
 	while (itY != itYend)
@@ -13273,7 +13306,7 @@ void ScribusDoc::itemSelection_SwapRight
 		++itY;
 	}
 
-	itX = Xsorted.begin(); //first item is left most
+	itX = xSorted.begin(); //first item is left most
 	int itemIndex = itX.value(); //get our first item's index in the AObjects array
 //	bool found = false;
 //	double itXX = itX.key();
@@ -13284,10 +13317,10 @@ void ScribusDoc::itemSelection_SwapRight
 	++circleListCounter;
 	// find the next X item with the minimum Y
 
-	QMap<double,uint>::Iterator itX2_1 = Xsorted.begin();
-	QMap<double,uint>::Iterator itLast = Xsorted.begin();
+	QMap<double, uint>::Iterator itX2_1 = xSorted.begin();
+	QMap<double, uint>::Iterator itLast = xSorted.begin();
 	double xBeginYValue = AObjects[itX2_1.value()].y1;
-	while (itX2_1 != Xsorted.end())
+	while (itX2_1 != xSorted.end())
 	{
 		if (AObjects[itX2_1.value()].y1 < xBeginYValue)
 		{
@@ -13299,10 +13332,10 @@ void ScribusDoc::itemSelection_SwapRight
 	}
 
 
-	if (circleListCounter != static_cast<int>(alignObjectsCount)) //need to reverse back now
+	if (circleListCounter != alignObjectsCount) //need to reverse back now
 	{
-		QMap<double,uint>::Iterator itX2_2 = itLast;
-		while (itX2_2 != Xsorted.begin())
+		QMap<double, uint>::Iterator itX2_2 = itLast;
+		while (itX2_2 != xSorted.begin())
 		{
 			if (AObjects[itX2_2.value()].y1 >= xBeginYValue)
 			{
@@ -13423,7 +13456,7 @@ void ScribusDoc::invalidateLayer(int lay
 	// for now hope that frameitems get invalidated by their parents layout() method.
 }
 
-void ScribusDoc::invalidateRegion(QRectF region)
+void ScribusDoc::invalidateRegion(const QRectF& region)
 {
 	QList<PageItem*> allItems;
 	for (int i = 0; i < DocItems.count(); ++i)
@@ -13531,8 +13564,10 @@ QRectF ScribusDoc::ApplyGridF(const QRec
 	bool   onPage = false;
 	double dX = m_docPrefsData.guidesPrefs.minorGridSpacing;
 	double dY = m_docPrefsData.guidesPrefs.minorGridSpacing;
-	double newX = in.x(), newY = in.y();
-	double pageX, pageY;
+	double newX = in.x();
+	double newY = in.y();
+	double pageX;
+	double pageY;
 
 	FPoint fp1(in.x(), in.y());
 	FPoint fp2(in.x(), in.y() + in.height());
@@ -13667,7 +13702,7 @@ void ScribusDoc::itemSelection_MultipleD
 			activeTransaction = m_undoManager->beginTransaction(Um::SelectionGroup, Um::IGroup, Um::MultipleDuplicate, "", Um::IMultipleDuplicate);
 		else
 		{
-			PageItem* item = itemSelection->itemAt(0);
+			const PageItem* item = itemSelection->itemAt(0);
 			activeTransaction = m_undoManager->beginTransaction(item->getUName(), item->getUPixmap(), Um::MultipleDuplicate, "", Um::IMultipleDuplicate);
 		}
 	}
@@ -13803,8 +13838,9 @@ void ScribusDoc::multipleDuplicateByPage
 
 	if (!m_Selection->itemsAreOnSamePage())
 	{
-		int firstPage = Pages->count(), lastPage = 0;
-		for (auto item: selection.items())
+		int firstPage = Pages->count();
+		int lastPage = 0;
+		for (auto item : selection.items())
 		{
 			if ((item->OwnPage >= 0) && (item->OwnPage < firstPage))
 				firstPage = item->OwnPage;
@@ -13901,7 +13937,7 @@ void ScribusDoc::multipleDuplicateByPage
 }
 
 
-void ScribusDoc::itemSelection_ApplyImageEffects(ScImageEffectList& newEffectList, Selection* customSelection)
+void ScribusDoc::itemSelection_ApplyImageEffects(const ScImageEffectList& newEffectList, Selection* customSelection)
 {
 	Selection* itemSelection = (customSelection != nullptr) ? customSelection : m_Selection;
 	assert(itemSelection != nullptr);
@@ -14012,7 +14048,7 @@ void ScribusDoc::itemSelection_ApplyArro
 	if (startArrowSc != -1 && endArrowSc != -1)
 		undoText = Um::StartAndEndArrow;
 	else
-		undoText=(startArrowSc!=-1) ? Um::StartArrow : Um::EndArrow;
+		undoText = (startArrowSc != -1) ? Um::StartArrow : Um::EndArrow;
 	if (activeTransaction)
 	{
 		activeTransaction.commit(Um::Selection,
@@ -14098,11 +14134,11 @@ void ScribusDoc::createNewDocPages(int p
 }
 
 
-void ScribusDoc::getClosestGuides(double xin, double yin, double *xout, double *yout, ScPage* refPage)
+void ScribusDoc::getClosestGuides(double xin, double yin, double *xout, double *yout, const ScPage* refPage)
 {
 	int gxM = -1;
 	int gyM = -1;
-	ScPage* page = (refPage == nullptr) ? currentPage() : refPage;
+	const ScPage* page = (refPage == nullptr) ? currentPage() : refPage;
 	QMap<double, uint> tmpGuidesSel;
 	Guides tmpGuides = page->guides.horizontals(GuideManagerCore::Standard);
 	Guides::iterator it;
@@ -14176,7 +14212,7 @@ void ScribusDoc::getClosestElementBorder
 	*yout = yin;
 
 	QList<PageItem*> items = getAllItems(*Items);
-	PageItem *parentI = nullptr;
+	const PageItem *parentI = nullptr;
 	if (m_Selection->count() > 0)
 		parentI = m_Selection->itemAt(0)->Parent;
 
@@ -14238,9 +14274,9 @@ void ScribusDoc::getClosestElementBorder
 	}
 }
 
-void ScribusDoc::getClosestPageBoundaries(double xin, double yin, double &xout, double &yout, ScPage* refPage)
+void ScribusDoc::getClosestPageBoundaries(double xin, double yin, double &xout, double &yout, const ScPage* refPage)
 {
-	ScPage* page = (refPage == nullptr) ? currentPage() : refPage;
+	const ScPage* page = (refPage == nullptr) ? currentPage() : refPage;
 
 	MarginStruct bleedValues;
 	getBleeds(page, m_docPrefsData.docSetupPrefs.bleeds, bleedValues);
@@ -14297,7 +14333,8 @@ void ScribusDoc::SnapToGuides(PageItem *
 	if (pg == -1)
 		return;
 
-	double xout, yout;
+	double xout;
+	double yout;
 
 	getClosestGuides(0, currItem->yPos(), &xout, &yout);
 	if (currItem->yPos() != yout)
@@ -14347,7 +14384,7 @@ bool ScribusDoc::ApplyGuides(double *x,
 	int pg = OnPage(*x, *y);
 	if (pg == -1)
 		return ret;
-	ScPage* page = Pages->at(pg);
+	const ScPage* page = Pages->at(pg);
 
 	//	if ((SnapGuides) && (m_SnapCounter > 1))
 	if ((SnapGuides && !elementSnap) || (SnapElement && elementSnap))
@@ -14414,7 +14451,6 @@ void ScribusDoc::rotateItem(double angle
 	if (currItem->locked())
 		return;
 	QRectF oldR = currItem->getBoundingRect();
-//	if ((Doc->RotMode != 0) && (m_MouseButtonPressed))
 	if (m_rotMode != 0)
 	{
 		QTransform ma;
@@ -14506,7 +14542,7 @@ bool ScribusDoc::sizeItem(double newW, d
 		QString transacDesc = QString(Um::ResizeFromTo).arg(owString, ohString, nwString, nhString);
 		activeTransaction = m_undoManager->beginTransaction(currItem->getUName(), currItem->getUPixmap(), Um::Resize, transacDesc, Um::IResize);
 	}
-	if ((m_rotMode != 0) && (fromMP) && (!isLoading()) && (appMode == modeNormal))
+	if ((m_rotMode != 0) && fromMP && (!isLoading()) && (appMode == modeNormal))
 	{
 		QTransform ma;
 		ma.rotate(currItem->rotation());
@@ -14900,17 +14936,16 @@ void ScribusDoc::scaleGroup(double scx,
 		double dscw = 1.0;
 		if (item->isArc())
 		{
-			PageItem_Arc* arcItem = item->asArc();
+			const PageItem_Arc* arcItem = item->asArc();
 			if (arcItem->height() != 0.0)
 				dsch = arcItem->arcHeight / arcItem->height();
 			if (arcItem->width() != 0.0)
 				dscw = arcItem->arcWidth / arcItem->width();
 		}
 		item->Sizing = false;
-		double oldRot, oldLocalX, oldLocalY;
-		oldRot = item->rotation();
-		oldLocalX = item->imageXOffset();
-		oldLocalY = item->imageYOffset();
+		double oldRot = item->rotation();
+		double oldLocalX = item->imageXOffset();
+		double oldLocalY = item->imageYOffset();
 		FPointArray gr;
 		gr.addPoint(item->GrStartX, item->GrStartY);
 		gr.addPoint(item->GrEndX, item->GrEndY);
@@ -15126,7 +15161,7 @@ PageItem* ScribusDoc::groupObjectsSelect
 	double maxy = -std::numeric_limits<double>::max();
 	for (int i = 0; i < selectedItemCount; ++i)
 	{
-		PageItem* currItem = itemSelection->itemAt(i);
+		const PageItem* currItem = itemSelection->itemAt(i);
 		double x1, x2, y1, y2;
 		currItem->getVisualBoundingRect(&x1, &y1, &x2, &y2);
 		minx = qMin(minx, x1);
@@ -15336,7 +15371,7 @@ PageItem * ScribusDoc::itemSelection_Gro
 	double maxy = -std::numeric_limits<double>::max();
 	for (int i = 0; i < selectedItemCount; ++i)
 	{
-		PageItem* currItem = selectedItems.at(i);
+		const PageItem* currItem = selectedItems.at(i);
 		double x1, x2, y1, y2;
 		currItem->getVisualBoundingRect(&x1, &y1, &x2, &y2);
 		minx = qMin(minx, x1);
@@ -15967,7 +16002,7 @@ void ScribusDoc::itemSelection_convertIt
 	QStringList results;
 	for (int i = 0; i < allItems.count(); i++)
 	{
-		PageItem *item = allItems.at(i);
+		const PageItem *item = allItems.at(i);
 		if ((!results.contains(item->pattern())) && ((item->GrType == Gradient_Pattern) || (item->itemType() == PageItem::Symbol)))
 			results.append(item->pattern());
 		if (!item->strokePattern().isEmpty())
@@ -16327,7 +16362,7 @@ void ScribusDoc::itemSelection_SetCompre
 	}
 }
 
-QHash<PageItem*, QString> ScribusDoc::getDocItemNames(PageItem::ItemType itemType)
+QHash<PageItem*, QString> ScribusDoc::getDocItemNames(PageItem::ItemType itemType) const
 {
 	QHash<PageItem*, QString> namesMap;
 	QList<PageItem*> allItems;
@@ -16376,7 +16411,7 @@ bool ScribusDoc::textCanvasPosition(Page
 	if (!item->isTextFrame() && !item->isPathText() && !item->isNoteFrame())
 		return false;
 
-	PageItem *charFrame = item->frameOfChar(textPos);
+	const PageItem *charFrame = item->frameOfChar(textPos);
 	if (!charFrame)
 		return false;
 
@@ -16508,9 +16543,8 @@ void ScribusDoc::setNewPrefs(const Appli
 	QStringList uf(UsedFonts.keys());
 	QMap<QString,int>::Iterator it3;
 	UsedFonts.clear();
-	QStringList::Iterator it3a;
 	QStringList::Iterator it3aend = uf.end();
-	for (it3a = uf.begin(); it3a != it3aend; ++it3a)
+	for (auto it3a = uf.begin(); it3a != it3aend; ++it3a)
 		AddFont(*it3a);
 
 	int itemCount = Items->count();
@@ -16706,7 +16740,7 @@ void ScribusDoc::checkItemForFrames(Page
 	it->invalid = true;
 }
 
-bool ScribusDoc::hasPreflightErrors()
+bool ScribusDoc::hasPreflightErrors() const
 {
 	return (
 			(pageErrors.count() != 0) ||
@@ -16722,7 +16756,7 @@ void ScribusDoc::itemResizeToMargin(Page
 	if (item->rotation() != 0)
 		return;
 	Canvas::FrameHandle fh = (Canvas::FrameHandle) direction;
-	ScPage *currPage = Pages->at(item->OwnPage);
+	const ScPage *currPage = Pages->at(item->OwnPage);
 	QTransform transform;
 	transform.translate(item->xPos(), item->yPos());
 	double inX = transform.dx() - m_currentPage->xOffset();
@@ -16813,7 +16847,7 @@ void ScribusDoc::setupNumerations()
 	NumStruct * numS = nullptr;
 	for (int i = 0; i < m_docParagraphStyles.count(); ++i)
 	{
-		ParagraphStyle &style = m_docParagraphStyles[i];
+		const ParagraphStyle &style = m_docParagraphStyles[i];
 		if (!style.hasNum())
 			continue;
 
@@ -17159,12 +17193,12 @@ void ScribusDoc::updateNumbers(bool upda
 	flag_Renumber = false;
 }
 
-QStringList ScribusDoc::marksLabelsList(MarkType type)
+QStringList ScribusDoc::marksLabelsList(MarkType type) const
 {
 	QStringList nameList;
 	for (int i = 0; i < m_docMarksList.count(); ++i)
 	{
-		Mark* m = m_docMarksList.at(i);
+		const Mark* m = m_docMarksList.at(i);
 		if (m == nullptr)
 			continue;
 		if ((m != nullptr) && m->isType(type))
@@ -17183,7 +17217,7 @@ Mark* ScribusDoc::getMark(const QString&
 	return nullptr;
 }
 
-Mark *ScribusDoc::newMark(Mark* mrk)
+Mark *ScribusDoc::newMark(const Mark* mrk)
 {
 	Mark* newMark = new Mark();
 	if (mrk != nullptr)
@@ -17358,7 +17392,7 @@ bool ScribusDoc::eraseMark(Mark *mrk, bo
 	return found;
 }
 
-void ScribusDoc::setUndoDelMark(Mark *mrk)
+void ScribusDoc::setUndoDelMark(const Mark *mrk)
 {
 	//used by MarksManager
 	if (UndoManager::undoEnabled())
@@ -17375,10 +17409,8 @@ void ScribusDoc::setUndoDelMark(Mark *mr
 			ims->set("at", findMarkCPos(mrk, master));
 			if (mrk->isType(MARK2MarkType))
 			{
-				QString dName = mrk->getDestMarkName();
-				MarkType dType = mrk->getDestMarkType();
-				ims->set("dName", dName);
-				ims->set("dType", (int) dType);
+				ims->set("dName", mrk->getDestMarkName());
+				ims->set("dType", (int) mrk->getDestMarkType());
 			}
 			if (mrk->isType(MARK2ItemType))
 				ims->insertItem("itemPtr", mrk->getItemPtr());
@@ -17411,7 +17443,7 @@ void ScribusDoc::setUndoDelMark(Mark *mr
 	}
 }
 
-bool ScribusDoc::invalidateVariableTextFrames(Mark* mrk, bool forceUpdate)
+bool ScribusDoc::invalidateVariableTextFrames(const Mark* mrk, bool forceUpdate)
 {
 	if (!mrk->isType(MARKVariableTextType))
 		return false;
@@ -17479,8 +17511,8 @@ bool ScribusDoc::updateMarks(bool update
 			}
 			else if (mrk->isUnique())
 			{
-				PageItem* mItem = findFirstMarkItem(mrk);
-				mrk->OwnPage =(mItem != nullptr) ? mItem->OwnPage : -1;
+				const PageItem* mItem = findFirstMarkItem(mrk);
+				mrk->OwnPage = (mItem != nullptr) ? mItem->OwnPage : -1;
 				mrk->setItemName((mItem != nullptr) ? mItem->itemName() : QString(""));
 			}
 		}
@@ -17537,7 +17569,7 @@ bool ScribusDoc::updateMarks(bool update
 			Mark* destMark = getMark(l, t);
 			if (destMark != nullptr)
 			{
-				PageItem* dItem = findFirstMarkItem(destMark);
+				const PageItem* dItem = findFirstMarkItem(destMark);
 				if (dItem != nullptr)
 				{
 					destMark->OwnPage = dItem->OwnPage;
@@ -17654,7 +17686,7 @@ void ScribusDoc::deleteNotesStyle(const
 	delete noteStyle;
 }
 
-void ScribusDoc::undoSetNotesStyle(SimpleState* ss, NotesStyle *noteStyle)
+void ScribusDoc::undoSetNotesStyle(SimpleState* ss, const NotesStyle *noteStyle)
 {
 	ss->set("name", noteStyle->name());
 	ss->set("start", noteStyle->start());
@@ -17774,7 +17806,7 @@ void ScribusDoc::updateItemNotesNums(Pag
 		if (note->noteMark() != nullptr)
 		{
 			note->noteMark()->setString(numStr);
-			label = label.replace("NoteMark","NoteFrameMark");
+			label.replace("NoteMark", "NoteFrameMark");
 			note->noteMark()->label = label;
 		}
 		++index;
@@ -17933,36 +17965,35 @@ bool ScribusDoc::updateEndNotesNums()
 	return docWasChanged;
 }
 
-void ScribusDoc::updateNotesFramesStyles(NotesStyle *nStyle)
+void ScribusDoc::updateNotesFramesStyles(const NotesStyle *nStyle)
 {
-	for (int i=0; i<Items->count(); ++i)
+	for (int i = 0; i < Items->count(); ++i)
 	{
 		PageItem* item = Items->at(i);
-		if (item->isNoteFrame() && (item->asNoteFrame()->notesStyle() == nStyle) && !item->asNoteFrame()->deleteIt)
+		if (!item->isNoteFrame() || (item->asNoteFrame()->notesStyle() != nStyle) || item->asNoteFrame()->deleteIt)
+			continue;
+
+		ParagraphStyle newStyle;
+		if (nStyle->notesParStyle().isEmpty() || (nStyle->notesParStyle() == tr("No Style")))
 		{
-			ParagraphStyle newStyle;
-			if (nStyle->notesParStyle().isEmpty() || (nStyle->notesParStyle() == tr("No Style")))
+			if (nStyle->isEndNotes())
 			{
-				if (nStyle->isEndNotes())
-					//set default doc style
-					newStyle.setParent(paragraphStyles()[0].name());
-				else
-				{
-					if (item->asNoteFrame()->masterFrame() != nullptr)
-					{
-						//set back style from master frame
-						newStyle.setParent(item->asNoteFrame()->masterFrame()->itemText.defaultStyle().parent());
-						newStyle.applyStyle(item->asNoteFrame()->masterFrame()->currentStyle());
-					}
-					else
-						newStyle.setParent(item->itemText.defaultStyle().parent());
-				}
+				//set default doc style
+				newStyle.setParent(paragraphStyles()[0].name());
+			}
+			else if (item->asNoteFrame()->masterFrame() != nullptr)
+			{
+				//set back style from master frame
+				newStyle.setParent(item->asNoteFrame()->masterFrame()->itemText.defaultStyle().parent());
+				newStyle.applyStyle(item->asNoteFrame()->masterFrame()->currentStyle());
 			}
 			else
-				newStyle.setParent(nStyle->notesParStyle());
-			item->itemText.setDefaultStyle(newStyle);
-			item->asTextFrame()->invalidateLayout(true);
+				newStyle.setParent(item->itemText.defaultStyle().parent());
 		}
+		else
+			newStyle.setParent(nStyle->notesParStyle());
+		item->itemText.setDefaultStyle(newStyle);
+		item->asTextFrame()->invalidateLayout(true);
 	}
 }
 
@@ -17977,7 +18008,7 @@ void ScribusDoc::updateItemNotesFramesSt
 		auto noteFrameList = item->asTextFrame()->notesFramesList();
 		for (PageItem_NoteFrame* noteFrame :  qAsConst(noteFrameList))
 		{
-			NotesStyle* nSet = noteFrame->notesStyle();
+			const NotesStyle* nSet = noteFrame->notesStyle();
 			if (nSet->isEndNotes())
 				continue;
 			if (nSet->notesParStyle().isEmpty() || (nSet->notesParStyle() == tr("No Style")))
@@ -17991,7 +18022,7 @@ void ScribusDoc::updateItemNotesFramesSt
 	}
 }
 
-QList<PageItem_NoteFrame *> ScribusDoc::listNotesFrames(NotesStyle *noteStyle)
+QList<PageItem_NoteFrame *> ScribusDoc::listNotesFrames(const NotesStyle *noteStyle)
 {
 	QList<PageItem_NoteFrame *> list;
 	for (PageItem* item : qAsConst(DocItems))
@@ -18002,9 +18033,9 @@ QList<PageItem_NoteFrame *> ScribusDoc::
 	return list;
 }
 
-const ScPage *ScribusDoc::page4EndNotes(NotesStyle *noteStyle, PageItem* item)
+const ScPage *ScribusDoc::page4EndNotes(const NotesStyle *noteStyle, PageItem* item)
 {
-	ScPage* scP = nullptr;
+	const ScPage* scP = nullptr;
 	if (noteStyle->range() == NSRdocument)
 		scP = DocPages.last();
 	else if (item != nullptr)
@@ -18083,7 +18114,7 @@ bool ScribusDoc::notesFramesUpdate()
 	return docWasChanged;
 }
 
-void ScribusDoc::updateNotesFramesSettings(NotesStyle *noteStyle)
+void ScribusDoc::updateNotesFramesSettings(const NotesStyle *noteStyle)
 {
 	QList<PageItem_NoteFrame*> noteFramesList = listNotesFrames(noteStyle);
 	for (PageItem_NoteFrame* nF : qAsConst(noteFramesList))
@@ -18108,14 +18139,14 @@ void ScribusDoc::updateNotesFramesSettin
 	}
 }
 
-void ScribusDoc::updateEndnotesFrames(NotesStyle* nStyle, bool invalidate)
+void ScribusDoc::updateEndnotesFrames(const NotesStyle* nStyle, bool invalidate)
 {
 	if (m_docEndNotesFramesMap.isEmpty())
 		return;
 	if (nStyle == nullptr)
 	{
 		int nsCount = m_docNotesStylesList.count();
-		for (int i=0; i < nsCount; ++i)
+		for (int i = 0; i < nsCount; ++i)
 			updateEndnotesFrames(m_docNotesStylesList.at(i));
 	}
 	else if (nStyle->isEndNotes())
@@ -18128,7 +18159,7 @@ void ScribusDoc::updateEndnotesFrames(No
 }
 
 //for sorting purpose
-bool ascendingSort(TextNote* nt1, TextNote* nt2) { return nt1->num() < nt2->num(); }
+bool ascendingSort(const TextNote* nt1, const TextNote* nt2) { return nt1->num() < nt2->num(); }
 
 void ScribusDoc::updateEndNotesFrameContent(PageItem_NoteFrame *nF, bool invalidate)
 {
@@ -18156,7 +18187,7 @@ void ScribusDoc::updateEndNotesFrameCont
 	}
 	else
 	{
-		NotesStyle* currNS = nF->notesStyle();
+		const NotesStyle* currNS = nF->notesStyle();
 		if (currNS->isAutoNotesHeight() || currNS->isAutoNotesWidth())
 			nF->invalidateLayout(false);
 		std::sort(nList.begin(), nList.end(), ascendingSort);
@@ -18167,7 +18198,7 @@ void ScribusDoc::updateEndNotesFrameCont
 		nF->invalid = true;
 		nF->layout();
 		//layout all endnotes frames with same range
-		for (NotesStyle* noteStyle : qAsConst(m_docNotesStylesList))
+		for (const NotesStyle* noteStyle : qAsConst(m_docNotesStylesList))
 		{
 			if ((noteStyle != currNS) && (noteStyle->isEndNotes() && noteStyle->range() == currNS->range()))
 			{
@@ -18298,7 +18329,7 @@ bool ScribusDoc::validateNSet(const Note
 {
 	//check if chosen numbering type is available with chosen range, prefix and suffix
 	QString errStr;
-	for (NotesStyle* NS2 : qAsConst(m_docNotesStylesList))
+	for (const NotesStyle* NS2 : qAsConst(m_docNotesStylesList))
 	{
 		if (newName.isEmpty())
 			//hack for validate nset while its name will change
@@ -18320,14 +18351,14 @@ bool ScribusDoc::validateNSet(const Note
 	return true;
 }
 
-void ScribusDoc::invalidateNoteFrames(NotesStyle *nStyle)
+void ScribusDoc::invalidateNoteFrames(const NotesStyle *nStyle)
 {
 	auto noteFrameList = listNotesFrames(nStyle);
 	for (PageItem_NoteFrame* noteFrame : qAsConst(noteFrameList))
 		noteFrame->invalid = true;
 }
 
-void ScribusDoc::invalidateMasterFrames(NotesStyle *nStyle)
+void ScribusDoc::invalidateMasterFrames(const NotesStyle *nStyle)
 {
 	QList<PageItem*> toInvalidate;
 	for (TextNote* note : qAsConst(m_docNotesList))
@@ -18339,7 +18370,7 @@ void ScribusDoc::invalidateMasterFrames(
 		toInvalidate.takeFirst()->invalid = true;
 }
 
-PageItem_NoteFrame *ScribusDoc::endNoteFrame(NotesStyle *nStyle, PageItem_TextFrame *master)
+PageItem_NoteFrame *ScribusDoc::endNoteFrame(const NotesStyle *nStyle, PageItem_TextFrame *master)
 {
 	if (nStyle->range() == NSRdocument)
 		return endNoteFrame(nStyle);
@@ -18348,7 +18379,7 @@ PageItem_NoteFrame *ScribusDoc::endNoteF
 	return nullptr;
 }
 
-PageItem_NoteFrame* ScribusDoc::endNoteFrame(NotesStyle *nStyle, void* item)
+PageItem_NoteFrame* ScribusDoc::endNoteFrame(const NotesStyle *nStyle, void* item)
 {
 	if (m_docEndNotesFramesMap.isEmpty())
 		return nullptr;
diff -Naupr scribus-1.6.2/scribus/scribusdoc.h scribus16x/scribus/scribusdoc.h
--- scribus-1.6.2/scribus/scribusdoc.h	2024-06-15 16:22:32.000000000 +0200
+++ scribus16x/scribus/scribusdoc.h	2025-01-04 10:59:08.677327531 +0100
@@ -100,7 +100,7 @@ public:
 	void init();
 	bool inAnEditMode() const;
 	bool inASpecialEditMode() const;
-	QList<PageItem*> getAllItems(QList<PageItem*> &items) const;
+	QList<PageItem*> getAllItems(const QList<PageItem*> &items) const;
 	QList<PageItem*> *parentGroup(PageItem* item, QList<PageItem*> *list);
 	void setup(int, int, int, int, int, const QString&, const QString&);
 	void setLoading(bool);
@@ -131,7 +131,7 @@ public:
 	
 	void invalidateAll();
 	void invalidateLayer(int layerID);
-	void invalidateRegion(QRectF region);
+	void invalidateRegion(const QRectF& region);
 
 	MarginStruct* scratch() { return &m_docPrefsData.displayPrefs.scratch; }
 	MarginStruct* bleeds() { return &m_docPrefsData.docSetupPrefs.bleeds; }
@@ -227,7 +227,7 @@ public:
 	void setDocumentInfo(DocumentInformation di) { m_docPrefsData.docInfo = di; }
 	DocumentSectionMap& sections() { return m_docPrefsData.docSectionMap; }
 	void setSections(DocumentSectionMap dsm) { m_docPrefsData.docSectionMap = std::move(dsm); }
-	const QMap<QString, int> & usedFonts() { return UsedFonts; }
+	const QMap<QString, int> & usedFonts() const { return UsedFonts; }
 
 	const ApplicationPrefs& prefsData() { return m_docPrefsData; }
 	void setNewPrefs(const ApplicationPrefs& prefsData, const ApplicationPrefs& oldPrefsData, bool resizePages, bool resizeMasterPages, bool resizePageMargins, bool resizeMasterPageMargins);
@@ -689,8 +689,8 @@ public:
 	/*!
 	 * @brief Returns a qmap of the fonts and  their glyphs used within the document
 	 */
-	void getUsedFonts(QMap<QString,QMap<uint, QString> > &Really);
-	void checkItemForFonts(PageItem *it, QMap<QString, QMap<uint, QString> > & Really, uint lc);
+	void getUsedFonts(QMap<QString, QMap<uint, QString> > &Really);
+	void checkItemForFonts(PageItem *it, QMap<QString, QMap<uint, QString> > &Really);
 
 	/*!
 	 * @brief Replace line style colors
@@ -716,7 +716,7 @@ public:
 	/*!
 	* @brief Set the patterns for a document
 	*/
-	bool addPattern(QString &name, ScPattern& pattern);
+	bool addPattern(QString &name, const ScPattern& pattern);
 	void removePattern(const QString& name);
 	void setPatterns(const QHash<QString, ScPattern> &patterns);
 	/*!
@@ -787,8 +787,8 @@ public:
 	/**
 	 * @brief Undo function for level
 	 */
-	void restoreLevelDown(SimpleState* ss, bool isUndo);
-	void restoreLevelBottom(SimpleState* ss, bool isUndo);
+	void restoreLevelUpOrDown(SimpleState* ss, bool isUndo);
+	void restoreLevelTopOrBottom(SimpleState* ss, bool isUndo);
 	void restoreGuideLock(SimpleState* ss, bool isUndo);
 
 	/**
@@ -809,7 +809,7 @@ public:
 	/**
 	 * @brief Recalculate the colors after CMS settings change. Update the items in the doc accordingly.
 	 */
-	void recalculateColorsList(QList<PageItem *> *itemList);
+	void recalculateColorsList(const QList<PageItem *> *itemList);
 	static void recalculateColorItem(PageItem *item);
 	void recalculateColors();
 	/**
@@ -911,20 +911,20 @@ public:
 	 * @param PrCMYK cmyk profile
 	 * @param dia optional progress widget
 	 */
-	void RecalcPictures(QList<PageItem*>* items, ProfilesL *Pr, ProfilesL *PrCMYK, QProgressBar *dia = nullptr);
+	void RecalcPictures(const QList<PageItem*>* items, ProfilesL *Pr, ProfilesL *PrCMYK, QProgressBar *dia = nullptr);
 
 	/**
 	 * @brief Find the minX,MinY and maxX,maxY for the canvas required for the doc
 	 */
-	void canvasMinMax(FPoint&, FPoint&);
+	void canvasMinMax(FPoint&, FPoint&) const;
 
 	/**
 	 * @brief Find the optimal area for canvas
 	 */
-	QRectF canvasOptimalRect();
+	QRectF canvasOptimalRect() const;
 	
-	int  OnPage(double x2, double  y2);
-	int  OnPage(PageItem *currItem);
+	int  OnPage(double x2, double  y2) const;
+	int  OnPage(PageItem *currItem) const;
 	void GroupOnPage(PageItem *currItem);
 
 	void reformPages(bool moveObjects = true);
@@ -959,7 +959,7 @@ public:
 	/**
 	 * @brief The page number of the current page
 	 */
-	int currentPageNumber();
+	int currentPageNumber() const;
 	
 	/**
 	 * @brief Return true iff the passed name is not used by any existing PageItem
@@ -1009,12 +1009,12 @@ public:
 	 * @brief Gets the page number to be printed based on the section it is in.
 	 * Returns QString() on failure to find the pageIndex
 	 */
-	const QString getSectionPageNumberForPageIndex(uint) const;
+	QString getSectionPageNumberForPageIndex(uint) const;
 	/**
 	 * @brief Gets the page number fill character to be printed based on the section it is in.
 	 * Returns QString() on failure to find the pageIndex
 	 */
-	const QChar getSectionPageNumberFillCharForPageIndex(uint) const;
+	QChar getSectionPageNumberFillCharForPageIndex(uint) const;
 	/**
 	 * @brief Gets the page number fill character to be printed based on the section it is in.
 	 * Returns QString() on failure to find the pageIndex
@@ -1062,8 +1062,8 @@ public:
 	void removePageFromAnnotLinks(int pageIndex);
 
 	//! @brief Some internal align tools
-	typedef enum {alignFirst, alignLast, alignPage, alignMargins, alignGuide, alignSelection } AlignTo;
-	typedef enum {alignByMoving, alignByResizing } AlignMethod;
+	enum AlignTo { alignFirst, alignLast, alignPage, alignMargins, alignGuide, alignSelection };
+	enum AlignMethod { alignByMoving, alignByResizing };
 	void buildAlignItemList(Selection* customSelection = nullptr);
 	bool startAlign(uint minObjects = 1);
 	void endAlign();
@@ -1238,11 +1238,11 @@ public:
 	};
 
 	//! \brief Get the closest guide to the given point
-	void getClosestGuides(double xin, double yin, double *xout, double *yout, ScPage* refPage = nullptr);
+	void getClosestGuides(double xin, double yin, double *xout, double *yout, const ScPage* refPage = nullptr);
 	//! \brief Get the closest border of another element to the given point
 	void getClosestElementBorder(double xin, double yin, double *xout, double *yout, SelectionSkipBehavior behavior = IncludeSelection);
 	//! \brief Get the closest page margin or bleed
-	void getClosestPageBoundaries(double xin, double yin, double &xout, double &yout, ScPage* refPage);
+	void getClosestPageBoundaries(double xin, double yin, double &xout, double &yout, const ScPage* refPage);
 	//! \brief Snap an item to the guides
 	void SnapToGuides(PageItem *currItem);
 	bool ApplyGuides(double *x, double *y, bool elementSnap = false);
@@ -1259,7 +1259,7 @@ public:
 	void rotateGroup(double angle, const FPoint& RCenter, Selection* customSelection = nullptr);
 	void scaleGroup(double scx, double scy, bool scaleText = true, Selection* customSelection = nullptr, bool scaleLine = false);
 	//! \brief Get a list of frames of certain type
-	QHash<PageItem*, QString> getDocItemNames(PageItem::ItemType itemType);
+	QHash<PageItem*, QString> getDocItemNames(PageItem::ItemType itemType) const;
 	//! \brief Returns a serializer for this document
 	Serializer *serializer();
 	//! \brief Returns a text serializer for this document, used to paste text chunks
@@ -1281,8 +1281,8 @@ public:
 	int addToInlineFrames(PageItem *item);
 	void removeInlineFrame(int fIndex);
 	void checkItemForFrames(PageItem *it, int fIndex);
-	bool hasPreflightErrors();
-	QFileDevice::Permissions filePermissions() { return m_docFilePermissions; }
+	bool hasPreflightErrors() const;
+	QFileDevice::Permissions filePermissions() const { return m_docFilePermissions; }
 	void saveFilePermissions(QFileDevice::Permissions p) { m_docFilePermissions = p; }
 
 protected:
@@ -1520,7 +1520,7 @@ public slots:
 	void allItems_ChangePreviewResolution(int id);
 
 	//FIXME : change to process a selection
-	void item_setFrameShape(PageItem* item, int frameType, int count, double* points); 
+	void item_setFrameShape(PageItem* item, int frameType, int count, const double* points);
 
 	void itemSelection_ClearItem(Selection* customSelection = nullptr, bool useWarning = false);
 	void itemSelection_TruncateItem(Selection* customSelection = nullptr);
@@ -1539,10 +1539,11 @@ public slots:
 	void itemSelection_SetFillGradient(const VGradient& newGradient, Selection* customSelection = nullptr);
 	void itemSelection_SetFillGradientExtend(VGradient::VGradientRepeatMethod repeatMethod, Selection* customSelection = nullptr);
 	void itemSelection_SetFillGradientName(const QString& gradientName, Selection* customSelection = nullptr);
+	void itemSelection_SetFillRule(bool evenOdd, Selection* customSelection = nullptr);
 	void itemSelection_SetMaskGradient(const VGradient& newGradient, Selection* customSelection = nullptr);
 	void itemSelection_SetMaskGradientName(const QString& gradientName, Selection* customSelection = nullptr);
 	void itemSelection_SetOverprint(bool overprint, Selection* customSelection = nullptr);
-	void itemSelection_ApplyImageEffects(ScImageEffectList& newEffectList, Selection* customSelection = nullptr);
+	void itemSelection_ApplyImageEffects(const ScImageEffectList& newEffectList, Selection* customSelection = nullptr);
 	void itemSelection_FlipH(Selection* customSelection = nullptr);
 	void itemSelection_FlipV(Selection* customSelection = nullptr);
 	void itemSelection_Rotate(double angle, Selection* customSelection = nullptr);
@@ -1769,7 +1770,7 @@ public:
 	bool usesMarksAndNotes() const { return m_docUsesMarksAndNotes; }
 	void setUsesMarksAndNotes(bool b) { m_docUsesMarksAndNotes = b; }
 	//return page where endnotesframe should be located depending of notes style range and location of master mark
-	const ScPage* page4EndNotes(NotesStyle* NS, PageItem* item);
+	const ScPage* page4EndNotes(const NotesStyle* NS, PageItem* item);
 	const QList<Mark*>& marksList() { return m_docMarksList; }
 	const QList<TextNote*>& notesList() { return m_docNotesList; }
 	QList<NotesStyle*> m_docNotesStylesList;
@@ -1777,10 +1778,10 @@ public:
 	QList<NotesStyle*> ns2Update; //list of notes styles to update
 
 	//returns list of notesframes for given Notes Style
-	QList<PageItem_NoteFrame*> listNotesFrames(NotesStyle* NS);
+	QList<PageItem_NoteFrame*> listNotesFrames(const NotesStyle* NS);
 
 	//flags used for indicating needs of updates
-	bool notesChanged() { return m_flag_notesChanged; }
+	bool notesChanged() const { return m_flag_notesChanged; }
 	void setNotesChanged(bool on) { m_flag_notesChanged = on; }
 	bool flag_restartMarksRenumbering {false};
 	bool flag_updateMarksLabels {false};
@@ -1788,11 +1789,11 @@ public:
 	bool flag_layoutNotesFrames {true};
 
 	//returns list of marks labels for given mark type
-	QStringList marksLabelsList(MarkType type);
+	QStringList marksLabelsList(MarkType type) const;
 
 	//return mark with given label and given type
 	Mark* getMark(const QString& label, MarkType type); //returns mark with label and type (labels are unique only for same type marks)
-	Mark* newMark(Mark* mrk = nullptr);
+	Mark* newMark(const Mark* mrk = nullptr);
 	TextNote* newNote(NotesStyle* NS);
 	
 	bool isMarkUsed(const Mark* mrk, bool visible = false) const;
@@ -1800,18 +1801,18 @@ public:
 	void setCursor2MarkPos(const Mark* mark);
 	//return false if mark was not found
 	bool eraseMark(Mark* mrk, bool fromText = false, PageItem* item = nullptr, bool force = false); //force is used only for deleting non-unique marks by MarksManager
-	void setUndoDelMark(Mark* mrk);
+	void setUndoDelMark(const Mark* mrk);
 	//invalidate all text frames where given mark will found
 	//useful spacially for variable text marks after changing its text definition
 	//if forceUpdate then found master frames are relayouted
-	bool invalidateVariableTextFrames(Mark* mrk, bool forceUpdate = false); //returns if any text was changed
+	bool invalidateVariableTextFrames(const Mark* mrk, bool forceUpdate = false); //returns if any text was changed
 
 	//for foot/endnotes
 	NotesStyle* newNotesStyle(const NotesStyle& NS);
 	void renameNotesStyle(NotesStyle* NS, const QString& newName);
 	//delete whole notes style with its notesframes and notes
 	void deleteNotesStyle(const QString& nsName);
-	void undoSetNotesStyle(SimpleState* ss, NotesStyle* ns);
+	void undoSetNotesStyle(SimpleState* ss, const NotesStyle* ns);
 	NotesStyle* getNotesStyle(const QString& nsName);
 	//delete note, if fromText than marks for given note will be removed
 	void deleteNote(TextNote* note);
@@ -1824,21 +1825,21 @@ public:
 	//return true if doc needs update after changing numbers of notes
 	bool updateNotesNums(NotesStyle* nStyle);
 	//set new text styles for notes marks
-	void updateNotesFramesStyles(NotesStyle* nStyle);
+	void updateNotesFramesStyles(const NotesStyle* nStyle);
 	//check conflicts between notes styles
 	bool validateNSet(const NotesStyle& NS, QString newName = "");
 	//update layout remove empty notesframes
 	bool notesFramesUpdate();
 	//update notesframes after changing automatic features of notes style
-	void updateNotesFramesSettings(NotesStyle* NS);
+	void updateNotesFramesSettings(const NotesStyle* NS);
 
 	//search for endnotesframe for given notes style and item holding master mark
-	PageItem_NoteFrame* endNoteFrame(NotesStyle* nStyle, PageItem_TextFrame* master);
+	PageItem_NoteFrame* endNoteFrame(const NotesStyle* nStyle, PageItem_TextFrame* master);
 	//
 	void setEndNoteFrame(PageItem_NoteFrame* nF, void* ptr)   { rangeItem rI={ptr}; m_docEndNotesFramesMap.insert(nF,rI); }
 	void setEndNoteFrame(PageItem_NoteFrame* nF, int section)   { rangeItem rI; rI.sectionIndex = section; m_docEndNotesFramesMap.insert(nF, rI); }
 	//update all endnotesframes content for given notes style
-	void updateEndnotesFrames(NotesStyle* nStyle = nullptr, bool invalidate = false);
+	void updateEndnotesFrames(const NotesStyle* nStyle = nullptr, bool invalidate = false);
 	//update endnotesframe content
 	void updateEndNotesFrameContent(PageItem_NoteFrame* nF, bool invalidate = false);
 	//insert noteframe into list of changed
@@ -1862,7 +1863,7 @@ private:
 	PageItem* findFirstMarkItem(const Mark* mrk) const { PageItem* tmp = nullptr; return findMarkItem(mrk, tmp); }
 
 	//search for endnotesframe for given notes style and item holding master mark or section number
-	PageItem_NoteFrame* endNoteFrame(NotesStyle* nStyle, void* item = nullptr);
+	PageItem_NoteFrame* endNoteFrame(const NotesStyle* nStyle, void* item = nullptr);
 	//clear list of notes for given notesframe
 	void clearNotesInFrameList(PageItem_NoteFrame* nF) { m_docNotesInFrameMap.insert(nF, QList<TextNote*>()); }
 	//renumber notes with given notes style for given frame starting from number num
@@ -1872,8 +1873,8 @@ private:
 	
 	//not used?
 	bool updateEndNotesNums(); //return true if doc needs update
-	void invalidateNoteFrames(NotesStyle* nStyle);
-	void invalidateMasterFrames(NotesStyle* nStyle);
+	void invalidateNoteFrames(const NotesStyle* nStyle);
+	void invalidateMasterFrames(const NotesStyle* nStyle);
 
 public slots:
 	//update strings (page numbers) for marks
diff -Naupr scribus-1.6.2/scribus/scribusstructs.h scribus16x/scribus/scribusstructs.h
--- scribus-1.6.2/scribus/scribusstructs.h	2024-06-15 16:22:33.000000000 +0200
+++ scribus16x/scribus/scribusstructs.h	2025-01-04 10:59:08.781325361 +0100
@@ -324,15 +324,15 @@ using errorCodes = QMap<PreflightError,
 
 struct AlignObjs
 {
-	int ObjNr;
-	int Group;
-	double x1;
-	double y1;
-	double x2;
-	double y2;
-	double width;
-	double height;
-	PageItem* Object;
+	int ObjNr { 0 };
+	int Group { 0 };
+	double x1 { 0.0 };
+	double y1 { 0.0 };
+	double x2 { 0.0 };
+	double y2 { 0.0 };
+	double width { 0.0 };
+	double height { 0.0 };
+	PageItem* Object { nullptr };
 };
 
 /*! \brief Human readable orientations */
diff -Naupr scribus-1.6.2/scribus/selection.h scribus16x/scribus/selection.h
--- scribus-1.6.2/scribus/selection.h	2024-06-15 16:22:33.000000000 +0200
+++ scribus16x/scribus/selection.h	2025-01-04 10:59:08.899322899 +0100
@@ -29,7 +29,7 @@ for which a new license (GPL+exception)
 #include "pageitem.h"
 #include "scribusapi.h"
 
-typedef QList< QPointer<PageItem> > SelectionList;
+using SelectionList = QList< QPointer<PageItem> >;
 
 class SCRIBUS_API Selection : public QObject
 {
diff -Naupr scribus-1.6.2/scribus/styleitem.h scribus16x/scribus/styleitem.h
--- scribus-1.6.2/scribus/styleitem.h	2024-06-15 16:22:36.000000000 +0200
+++ scribus16x/scribus/styleitem.h	2025-01-04 10:59:08.899322899 +0100
@@ -19,11 +19,11 @@ class QTabWidget;
 
 /** RemoveItem.first will be the style to remove and RemoveItem.second
  *  will be the one used in place of the deleted style */
-typedef QPair<QString, QString> RemoveItem;
+using RemoveItem = QPair<QString, QString>;
 
 /** StyleName.first is the name of the style and StyleName.second is the
  *  name of the parent style or QString() if there's no parent for this style */
-typedef QPair<QString, QString> StyleName;
+using StyleName = QPair<QString, QString>;
 
 /**
  * @brief Represents a style type that can be added to the Style Manager
diff -Naupr scribus-1.6.2/scribus/styles/linestyle.cpp scribus16x/scribus/styles/linestyle.cpp
--- scribus-1.6.2/scribus/styles/linestyle.cpp	2024-06-15 16:22:33.000000000 +0200
+++ scribus16x/scribus/styles/linestyle.cpp	2025-01-04 10:59:08.899322899 +0100
@@ -184,7 +184,7 @@ bool LineStyle::inheritsAll() const
 }
 */
 
-typedef QList<LineStyle> Sublist;
+using Sublist = QList<LineStyle>;
 
 static QString toXMLString(const Sublist & )
 {
diff -Naupr scribus-1.6.2/scribus/styles/paragraphstyle.cpp scribus16x/scribus/styles/paragraphstyle.cpp
--- scribus-1.6.2/scribus/styles/paragraphstyle.cpp	2024-06-15 16:22:33.000000000 +0200
+++ scribus16x/scribus/styles/paragraphstyle.cpp	2025-01-04 10:59:08.899322899 +0100
@@ -350,7 +350,7 @@ ParagraphStyle::LineSpacingMode parse<Pa
 }
 
 
-typedef QList<ParagraphStyle::TabRecord> Tablist;
+using Tablist = QList<ParagraphStyle::TabRecord>;
 
 template<>
 Tablist parse<Tablist>(const Xml_string& str)
@@ -365,7 +365,7 @@ const Xml_string ParagraphStyle::saxxDef
 
 void ParagraphStyle::desaxeRules(const Xml_string& prefixPattern, Digester& ruleset, const Xml_string& elemtag)
 {
-	typedef ParagraphStyle::TabRecord TabRecord;
+	using TabRecord = ParagraphStyle::TabRecord;
 		
 	Xml_string stylePrefix(Digester::concat(prefixPattern, elemtag));
 	ruleset.addRule(stylePrefix, Factory<ParagraphStyle>());
diff -Naupr scribus-1.6.2/scribus/text/boxes.cpp scribus16x/scribus/text/boxes.cpp
--- scribus-1.6.2/scribus/text/boxes.cpp	2024-06-15 16:22:33.000000000 +0200
+++ scribus16x/scribus/text/boxes.cpp	2025-01-04 10:59:08.680327469 +0100
@@ -578,9 +578,9 @@ void GlyphBox::drawSelection(ScreenPaint
 			qreal firstX = positionToPoint(selectionFirst, item->itemText).x1();
 			qreal lastX = positionToPoint(selectionLast + 1, item->itemText).x1();
 			if (m_glyphRun.hasFlag(ScLayout_RightToLeft))
-				rect = QRectF(lastX, y(), firstX - lastX, height());
+				rect = QRectF(lastX, -ascent(), firstX - lastX, height());
 			else
-				rect = QRectF(firstX, y(), lastX - firstX, height());
+				rect = QRectF(firstX, -ascent(), lastX - firstX, height());
 			p->drawRect(rect);
 		}
 	}
diff -Naupr scribus-1.6.2/scribus/text/index.h scribus16x/scribus/text/index.h
--- scribus-1.6.2/scribus/text/index.h	2024-06-15 16:22:33.000000000 +0200
+++ scribus16x/scribus/text/index.h	2025-01-04 10:59:08.680327469 +0100
@@ -15,7 +15,7 @@
 #include <vector>
 #include <QList>
 
-typedef unsigned int uint;
+using uint = unsigned int;
 
 /**
  * Holds track of an ordered set of integers, e.g. positions of inline frames within a text.
diff -Naupr scribus-1.6.2/scribus/translationdummy.cpp scribus16x/scribus/translationdummy.cpp
--- scribus-1.6.2/scribus/translationdummy.cpp	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/scribus/translationdummy.cpp	2025-01-04 10:59:09.017320437 +0100
@@ -4,10 +4,6 @@ to the COPYING file provided with the pr
 a copyright and/or license notice that predates the release of Scribus 1.3.2
 for which a new license (GPL+exception) is in place.
 */
-QMessageBox::QMessageBox()
-{
-tr("<h3>About Qt</h3><p>This program uses Qt version %1.</p><p>Qt is a C++ toolkit for multiplatform GUI &amp; application development.</p><p>Qt provides single-source portability across MS&nbsp;Windows, Mac&nbsp;OS&nbsp;X, Linux, and all major commercial Unix variants.<br>Qt is also available for embedded devices.</p><p>Qt is a Trolltech product. See <tt>http://www.trolltech.com/qt/</tt> for more information.</p>");
-}
 
 QFileDialog::QFileDialog()
 {
diff -Naupr scribus-1.6.2/scribus/ui/about.cpp scribus16x/scribus/ui/about.cpp
--- scribus-1.6.2/scribus/ui/about.cpp	2024-06-15 16:22:23.000000000 +0200
+++ scribus16x/scribus/ui/about.cpp	2025-01-04 10:59:08.311335169 +0100
@@ -638,8 +638,8 @@ QString About::parseLinksFile(const QStr
 
 QString About::generateBuildInfo()
 {
-	QString BUILD_DAY = "15";
-	QString BUILD_MONTH = CommonStrings::june;
+	QString BUILD_DAY = "8";
+	QString BUILD_MONTH = CommonStrings::december;
 	QString BUILD_YEAR = "2024";
 	QString BUILD_TIME;
 	QString BUILD_TZ;
diff -Naupr scribus-1.6.2/scribus/ui/about.h scribus16x/scribus/ui/about.h
--- scribus-1.6.2/scribus/ui/about.h	2024-06-15 16:22:24.000000000 +0200
+++ scribus16x/scribus/ui/about.h	2025-01-04 10:59:08.314335107 +0100
@@ -27,11 +27,11 @@ class SCRIBUS_API About : public QDialog
 
 public:
 
-	typedef enum
+	enum AboutMode
 	{
 		Default = 0,
 		CheckUpdates = 1
-	} AboutMode;
+	};
 
 	About( QWidget* parent, AboutMode mode = About::Default );
 	~About() {}
diff -Naupr scribus-1.6.2/scribus/ui/colorcombo.cpp scribus16x/scribus/ui/colorcombo.cpp
--- scribus-1.6.2/scribus/ui/colorcombo.cpp	2024-06-15 16:22:24.000000000 +0200
+++ scribus16x/scribus/ui/colorcombo.cpp	2025-01-04 10:59:08.314335107 +0100
@@ -15,14 +15,7 @@ for which a new license (GPL+exception)
 #include "commonstrings.h"
 // #include "qdebug.h"
 
-ColorCombo::ColorCombo(QWidget* parent) : QComboBox(parent)
-{
-	setEditable(false);
-	ColorListBox* lb = new ColorListBox(this);
-	setModel( lb->model() );
-	setItemDelegate( lb->itemDelegate() );
-	setView( lb );
-}
+ColorCombo::ColorCombo(QWidget* parent) : ColorCombo(false, parent) {}
 
 ColorCombo::ColorCombo(ColorCombo::PixmapType type, QWidget* parent) : QComboBox(parent)
 {
@@ -36,6 +29,7 @@ ColorCombo::ColorCombo(ColorCombo::Pixma
 	setModel( lb->model() );
 	setItemDelegate( lb->itemDelegate() );
 	setView( lb );
+	view()->setSizePolicy(QSizePolicy::MinimumExpanding, QSizePolicy::Minimum);
 }
 
 ColorCombo::ColorCombo(bool rw, QWidget* parent) : QComboBox(parent)
@@ -45,6 +39,7 @@ ColorCombo::ColorCombo(bool rw, QWidget*
 	setModel( lb->model() );
 	setItemDelegate( lb->itemDelegate() );
 	setView( lb );
+	view()->setSizePolicy(QSizePolicy::MinimumExpanding, QSizePolicy::Minimum);
 }
 
 
diff -Naupr scribus-1.6.2/scribus/ui/colorlistbox.cpp scribus16x/scribus/ui/colorlistbox.cpp
--- scribus-1.6.2/scribus/ui/colorlistbox.cpp	2024-06-15 16:22:24.000000000 +0200
+++ scribus16x/scribus/ui/colorlistbox.cpp	2025-01-04 10:59:08.314335107 +0100
@@ -175,23 +175,7 @@ void ColorFancyItemDelegate::iconSetChan
 int ColorListBox::initialized;
 int ColorListBox::sortRule;
 
-ColorListBox::ColorListBox(QWidget * parent)
-	: QListView(parent)
-{
-	if (initialized != 12345)
-		sortRule = 0;
-	initialized = 12345;
-	QListView::setModel(new ColorListModel(this));
-	setPixmapType(ColorListBox::widePixmap);
-
-	connect(this, SIGNAL(clicked(QModelIndex)),       this, SLOT(emitItemClicked(QModelIndex)));
-	connect(this, SIGNAL(doubleClicked(QModelIndex)), this, SLOT(emitItemDoubleClicked(QModelIndex)));
-	connect(this->selectionModel(), SIGNAL(currentChanged(QModelIndex, QModelIndex)),
-            this, SLOT(emitCurrentChanged(QModelIndex, QModelIndex)));
-	connect(this->selectionModel(), SIGNAL(selectionChanged(QItemSelection,QItemSelection)),
-            this, SIGNAL(itemSelectionChanged()));
-	connect(this, SIGNAL(contextMenuRequested()), this, SLOT(slotRightClick()));
-}
+ColorListBox::ColorListBox(QWidget * parent) : ColorListBox(ColorListBox::widePixmap, parent) {}
 
 ColorListBox::ColorListBox(ColorListBox::PixmapType type, QWidget * parent)
 	: QListView(parent)
diff -Naupr scribus-1.6.2/scribus/ui/colorpalette.cpp scribus16x/scribus/ui/colorpalette.cpp
--- scribus-1.6.2/scribus/ui/colorpalette.cpp	2024-06-15 16:22:23.000000000 +0200
+++ scribus16x/scribus/ui/colorpalette.cpp	2025-01-04 10:59:08.314335107 +0100
@@ -836,10 +836,10 @@ void ColorPalette::updatePatternList()
 	{
 		ScPattern sp = patternList->value(patK[a]);
 		QPixmap pm;
-		if (sp.getPattern()->width() >= sp.getPattern()->height())
-			pm = QPixmap::fromImage(sp.getPattern()->scaledToWidth(48, Qt::SmoothTransformation));
+		if (sp.getPattern().width() >= sp.getPattern().height())
+			pm = QPixmap::fromImage(sp.getPattern().scaledToWidth(48, Qt::SmoothTransformation));
 		else
-			pm = QPixmap::fromImage(sp.getPattern()->scaledToHeight(48, Qt::SmoothTransformation));
+			pm = QPixmap::fromImage(sp.getPattern().scaledToHeight(48, Qt::SmoothTransformation));
 		QPixmap pm2(48, 48);
 		pm2.fill(palette().color(QPalette::Base));
 		QPainter p;
diff -Naupr scribus-1.6.2/scribus/ui/colorsandfills.cpp scribus16x/scribus/ui/colorsandfills.cpp
--- scribus-1.6.2/scribus/ui/colorsandfills.cpp	2024-06-15 16:22:23.000000000 +0200
+++ scribus16x/scribus/ui/colorsandfills.cpp	2025-01-04 10:59:08.314335107 +0100
@@ -199,10 +199,10 @@ QTreeWidgetItem* ColorsAndFillsDialog::u
 	{
 		ScPattern sp = dialogPatterns.value(patK[i]);
 		QPixmap pm;
-		if (sp.getPattern()->width() >= sp.getPattern()->height())
-			pm = QPixmap::fromImage(sp.getPattern()->scaledToWidth(48, Qt::SmoothTransformation));
+		if (sp.getPattern().width() >= sp.getPattern().height())
+			pm = QPixmap::fromImage(sp.getPattern().scaledToWidth(48, Qt::SmoothTransformation));
 		else
-			pm = QPixmap::fromImage(sp.getPattern()->scaledToHeight(48, Qt::SmoothTransformation));
+			pm = QPixmap::fromImage(sp.getPattern().scaledToHeight(48, Qt::SmoothTransformation));
 		QPixmap pm2(48, 48);
 		pm2.fill(palette().color(QPalette::Base));
 		QPainter p;
diff -Naupr scribus-1.6.2/scribus/ui/gradientaddedit.cpp scribus16x/scribus/ui/gradientaddedit.cpp
--- scribus-1.6.2/scribus/ui/gradientaddedit.cpp	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/ui/gradientaddedit.cpp	2025-01-04 10:59:08.312335148 +0100
@@ -42,12 +42,12 @@ gradientEditDialog::gradientEditDialog(Q
 	connect(buttonBox, SIGNAL(accepted()), this, SLOT(quitDialog()));
 }
 
-QString gradientEditDialog::name()
+QString gradientEditDialog::name() const
 {
 	return gradientName->text();
 }
 
-VGradient gradientEditDialog::gradient()
+const VGradient& gradientEditDialog::gradient() const
 {
 	return editor->gradient();
 }
@@ -61,7 +61,7 @@ void gradientEditDialog::quitDialog()
 		gradientName->selectAll();
 		return;
 	}
-	if ((m_name != gradientName->text()) || (isNew))
+	if ((m_name != gradientName->text()) || isNew)
 	{
 		if (m_gradients->contains(gradientName->text()))
 		{
diff -Naupr scribus-1.6.2/scribus/ui/gradientaddedit.h scribus16x/scribus/ui/gradientaddedit.h
--- scribus-1.6.2/scribus/ui/gradientaddedit.h	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/ui/gradientaddedit.h	2025-01-04 10:59:08.312335148 +0100
@@ -40,15 +40,18 @@ class SCRIBUS_API gradientEditDialog : p
 	public:
 		gradientEditDialog(QWidget* parent, const QString& name, const VGradient& gradient, ColorList doco, ScribusDoc *doc, QHash<QString, VGradient> *gradients, bool newFlag);
 		~gradientEditDialog() {};
-		QString name();
-		VGradient gradient();
+
+		QString name() const;
+		const VGradient& gradient() const;
+
 	private slots:
 		void quitDialog();
+
 	protected:
-		ScribusDoc* m_doc;
-		bool isNew;
+		ScribusDoc* m_doc { nullptr };
+		bool isNew { false };
 		QString m_name;
-		QHash<QString, VGradient> *m_gradients;
+		QHash<QString, VGradient> *m_gradients { nullptr };
 };
 
 #endif
diff -Naupr scribus-1.6.2/scribus/ui/gradienteditor.cpp scribus16x/scribus/ui/gradienteditor.cpp
--- scribus-1.6.2/scribus/ui/gradienteditor.cpp	2024-06-15 16:22:24.000000000 +0200
+++ scribus16x/scribus/ui/gradienteditor.cpp	2025-01-04 10:59:08.311335169 +0100
@@ -54,7 +54,7 @@ void GradientEditor::setGradient(const V
 	Preview->updateDisplay();
 }
 
-const VGradient& GradientEditor::gradient()
+const VGradient& GradientEditor::gradient() const
 {
 	return Preview->gradient();
 }
@@ -179,8 +179,8 @@ bool GradientEditor::event(QEvent * even
 {
 	if (event->type() == QEvent::ToolTip) 
 	{
-		QHelpEvent *helpEvent = static_cast<QHelpEvent *>(event);
-		QToolTip::showText(helpEvent->globalPos(), tr( "Add, change or remove color stops here" ), Preview, QRect(10,43, Preview->width()-20, 13));
+		const auto *helpEvent = static_cast<QHelpEvent *>(event);
+		QToolTip::showText(helpEvent->globalPos(), tr("Add, change or remove color stops here"), Preview, QRect(10, 43, Preview->width() - 20, 13));
 	}
 	return QWidget::event(event);
 }
diff -Naupr scribus-1.6.2/scribus/ui/gradienteditor.h scribus16x/scribus/ui/gradienteditor.h
--- scribus-1.6.2/scribus/ui/gradienteditor.h	2024-06-15 16:22:24.000000000 +0200
+++ scribus16x/scribus/ui/gradienteditor.h	2025-01-04 10:59:08.312335148 +0100
@@ -47,7 +47,7 @@ public:
 	~GradientEditor() {};
 
 	void setGradient(const VGradient& grad);
-	const VGradient &gradient();
+	const VGradient& gradient() const;
 	void setColors(ColorList &colorList);
 	QColor setColor(const QString& colorName, int shad);
 	void setGradientEditable(bool val);
diff -Naupr scribus-1.6.2/scribus/ui/gradientpreview.cpp scribus16x/scribus/ui/gradientpreview.cpp
--- scribus-1.6.2/scribus/ui/gradientpreview.cpp	2024-06-15 16:22:24.000000000 +0200
+++ scribus16x/scribus/ui/gradientpreview.cpp	2025-01-04 10:59:08.312335148 +0100
@@ -114,19 +114,19 @@ void GradientPreview::paintEvent(QPaintE
 
 void GradientPreview::keyPressEvent(QKeyEvent *e)
 {
-	if (isEditable)
+	if (!isEditable)
+		return;
+
+	if(e->key() == Qt::Key_Delete || e->key() == Qt::Key_Backspace)
 	{
-		if(e->key() == Qt::Key_Delete || e->key() == Qt::Key_Backspace)
+		if ((ActStop > 0) && (ActStop != StopM.count() - 1))
 		{
-			if ((ActStop > 0) && (ActStop != static_cast<int>(StopM.count()-1)))
-			{
-				onlyselect = false;
-				fill_gradient.removeStop(ActStop);
-				ActStop = 0;
-				repaint();
-				QList<VColorStop*> cstops = fill_gradient.colorStops();
-				emit selectedStop(cstops.at(ActStop));
-			}
+			onlyselect = false;
+			fill_gradient.removeStop(ActStop);
+			ActStop = 0;
+			repaint();
+			QList<VColorStop*> cstops = fill_gradient.colorStops();
+			emit selectedStop(cstops.at(ActStop));
 		}
 	}
 }
@@ -135,14 +135,14 @@ void GradientPreview::mousePressEvent(QM
 {
 	QRect fpo;
 	Mpressed = true;
-	qApp->setOverrideCursor(QCursor(Qt::ArrowCursor));
+	QApplication::setOverrideCursor(QCursor(Qt::ArrowCursor));
 	ActStop = -1;
 	if (isEditable)
 	{
 		QList<VColorStop*> cstops = fill_gradient.colorStops();
-		for (int yg = 0; yg < static_cast<int>(StopM.count()); ++yg)
+		for (int yg = 0; yg < StopM.count(); ++yg)
 		{
-			fpo = QRect(static_cast<int>(StopM[yg]) - 4, 43, 8, 13);
+			fpo = QRect(StopM[yg] - 4, 43, 8, 13);
 			if (fpo.contains(m->pos()))
 			{
 				ActStop = yg;
@@ -157,14 +157,14 @@ void GradientPreview::mousePressEvent(QM
 
 void GradientPreview::mouseReleaseEvent(QMouseEvent *m)
 {
-	qApp->restoreOverrideCursor();
-	QRect insideRect = QRect(10, 43, width() - 20, 13);
+	QApplication::restoreOverrideCursor();
+	QRect insideRect(10, 43, width() - 20, 13);
 	if (isEditable)
 	{
 		QRect fpo;
 		if (m->button() == Qt::LeftButton)
 		{
-			if ((Mpressed) && (ActStop > 0) && (ActStop != static_cast<int>(StopM.count()-1)) && (outside || !insideRect.contains(m->pos())))
+			if (Mpressed && (ActStop > 0) && (ActStop != StopM.count() - 1) && (outside || !insideRect.contains(m->pos())))
 			{
 				onlyselect = false;
 				fill_gradient.removeStop(ActStop);
@@ -184,9 +184,9 @@ void GradientPreview::mouseReleaseEvent(
 				repaint();
 				onlyselect = false;
 				cstops = fill_gradient.colorStops();
-				for (int yg = 0; yg < static_cast<int>(StopM.count()); ++yg)
+				for (int yg = 0; yg < StopM.count(); ++yg)
 				{
-					fpo = QRect(static_cast<int>(StopM[yg]) - 4, 43, 8, 13);
+					fpo = QRect(StopM[yg] - 4, 43, 8, 13);
 					if (fpo.contains(m->pos()))
 					{
 						ActStop = yg;
@@ -202,9 +202,9 @@ void GradientPreview::mouseReleaseEvent(
 			Mpressed = false;
 //			QList<VColorStop*> cstops = fill_gradient.colorStops();
 			int stop = -1;
-			for (int yg = 0; yg < static_cast<int>(StopM.count()); ++yg)
+			for (int yg = 0; yg < StopM.count(); ++yg)
 			{
-				fpo = QRect(static_cast<int>(StopM[yg]) - 4, 43, 8, 13);
+				fpo = QRect(StopM[yg] - 4, 43, 8, 13);
 				if (fpo.contains(m->pos()))
 				{
 					stop = yg;
@@ -233,17 +233,17 @@ void GradientPreview::mouseReleaseEvent(
 
 void GradientPreview::mouseMoveEvent(QMouseEvent *m)
 {
-	QRect insideRect = QRect(10, 43, width() - 20, 13);
+	QRect insideRect(10, 43, width() - 20, 13);
 	if (isEditable)
 	{
 		QRect fpo;
-		qApp->changeOverrideCursor(QCursor(Qt::ArrowCursor));
+		QApplication::changeOverrideCursor(QCursor(Qt::ArrowCursor));
 		if ((!Mpressed) && (m->y() < height()) && (m->y() > 43) && (m->x() > 9) && (m->x() < width()-9))
 		{
 			setCursor(IconManager::instance().loadCursor("AddPoint.png", 1, 1));
-			for (int yg = 0; yg < static_cast<int>(StopM.count()); ++yg)
+			for (int yg = 0; yg < StopM.count(); ++yg)
 			{
-				fpo = QRect(static_cast<int>(StopM[yg]) - 4, 43, 8, 13);
+				fpo = QRect(StopM[yg] - 4, 43, 8, 13);
 				if (fpo.contains(m->pos()))
 				{
 					setCursor(QCursor(Qt::SizeHorCursor));
@@ -253,18 +253,18 @@ void GradientPreview::mouseMoveEvent(QMo
 		}
 		if (m->buttons() & Qt::LeftButton)
 		{
-			if ((Mpressed) && (m->y() < height()) && (m->y() > 43) && (m->x() > 9) && (m->x() < width() - 9) && (ActStop != -1))
+			if (Mpressed && (m->y() < height()) && (m->y() > 43) && (m->x() > 9) && (m->x() < width() - 9) && (ActStop != -1))
 			{
-				qApp->changeOverrideCursor(QCursor(Qt::SizeHorCursor));
+				QApplication::changeOverrideCursor(QCursor(Qt::SizeHorCursor));
 				double newStop = static_cast<double>((m->x() - 10)) / (static_cast<double>(width()) - 20);
 				if (ActStop > 1)
 				{
-					if (StopM[ActStop-1]+2 >= m->x())
+					if (StopM[ActStop - 1] + 2 >= m->x())
 						return;
 				}
-				if (ActStop < static_cast<int>(StopM.count()-2))
+				if (ActStop < StopM.count() - 2)
 				{
-					if (StopM[ActStop+1]-2 < m->x())
+					if (StopM[ActStop + 1] - 2 < m->x())
 						return;
 				}
 				StopM[ActStop] = m->x();
@@ -274,8 +274,8 @@ void GradientPreview::mouseMoveEvent(QMo
 				onlyselect = false;
 				repaint();
 			}
-			if ((Mpressed) && (outside || !insideRect.contains(m->pos())) && (ActStop > 0) && (ActStop != static_cast<int>(StopM.count()-1)))
-				qApp->changeOverrideCursor(IconManager::instance().loadCursor("DelPoint.png", 1, 1));
+			if (Mpressed && (outside || !insideRect.contains(m->pos())) && (ActStop > 0) && (ActStop != StopM.count() - 1))
+				QApplication::changeOverrideCursor(IconManager::instance().loadCursor("DelPoint.png", 1, 1));
 		}
 	}
 }
@@ -286,10 +286,10 @@ void GradientPreview::leaveEvent(QEvent*
 	{
 		if (Mpressed)
 		{
-			if ((ActStop > 0) && (ActStop != static_cast<int>(StopM.count()-1)))
-				qApp->changeOverrideCursor(IconManager::instance().loadCursor("DelPoint.png", 1, 1));
+			if ((ActStop > 0) && (ActStop != StopM.count() - 1))
+				QApplication::changeOverrideCursor(IconManager::instance().loadCursor("DelPoint.png", 1, 1));
 			else
-				qApp->changeOverrideCursor(QCursor(Qt::ArrowCursor));
+				QApplication::changeOverrideCursor(QCursor(Qt::ArrowCursor));
 		}
 		outside = true;
 	}
@@ -311,9 +311,9 @@ void GradientPreview::addStop()
 	repaint();
 	onlyselect = false;
 	cstops = fill_gradient.colorStops();
-	for (int yg = 0; yg < static_cast<int>(StopM.count()); ++yg)
+	for (int yg = 0; yg < StopM.count(); ++yg)
 	{
-		QRect fpo = QRect(static_cast<int>(StopM[yg]) - 4, 43, 8, 13);
+		QRect fpo(StopM[yg] - 4, 43, 8, 13);
 		if (fpo.contains(mPos))
 		{
 			ActStop = yg;
@@ -326,7 +326,7 @@ void GradientPreview::addStop()
 
 void GradientPreview::removeStop()
 {
-	if ((contextStop > 0) && (contextStop != static_cast<int>(StopM.count()-1)))
+	if ((contextStop > 0) && (contextStop != StopM.count() - 1))
 	{
 		onlyselect = false;
 		fill_gradient.removeStop(contextStop);
@@ -383,8 +383,8 @@ void GradientPreview::setGradient(const
 		int diffStops = 0;
 		for (int i = 0; i < fill_gradient.colorStops().count(); ++i)
 		{
-			VColorStop* stop1 = gradient.colorStops().at(i);
-			VColorStop* stop2 = fill_gradient.colorStops().at(i);
+			const VColorStop* stop1 = gradient.colorStops().at(i);
+			const VColorStop* stop2 = fill_gradient.colorStops().at(i);
 			if ((stop1->color != stop2->color) || (stop1->midPoint != stop2->midPoint) ||
 				(stop1->name  != stop2->name)  || (stop1->opacity != stop2->opacity)   ||
 				(stop1->rampPoint != stop2->rampPoint) || (stop1->shade != stop2->shade))
diff -Naupr scribus-1.6.2/scribus/ui/gradientpreview.h scribus16x/scribus/ui/gradientpreview.h
--- scribus-1.6.2/scribus/ui/gradientpreview.h	2024-06-15 16:22:24.000000000 +0200
+++ scribus16x/scribus/ui/gradientpreview.h	2025-01-04 10:59:08.312335148 +0100
@@ -52,7 +52,7 @@ public:
 	void setGradient(const VGradient& gradient);
 	void setGradientEditable(bool val);
 
-	const VGradient& gradient() { return fill_gradient; }
+	const VGradient& gradient() const { return fill_gradient; }
 	
 	QList<int> StopM;
 	bool Mpressed { false };
diff -Naupr scribus-1.6.2/scribus/ui/gradientvectordialog.cpp scribus16x/scribus/ui/gradientvectordialog.cpp
--- scribus-1.6.2/scribus/ui/gradientvectordialog.cpp	2024-06-15 16:22:23.000000000 +0200
+++ scribus16x/scribus/ui/gradientvectordialog.cpp	2025-01-04 10:59:08.312335148 +0100
@@ -27,15 +27,15 @@ for which a new license (GPL+exception)
 
 GradientVectorDialog::GradientVectorDialog(QWidget* parent) : ScrPaletteBase(parent, "GradientVectorPalette", false, Qt::WindowFlags())
 {
-	m_unitRatio = 1.0;
-
 	setupUi(this);
+
 	gSk->setNewUnit(6);
 	gSk->setValues(-89, 89, 2, 0);
 	gSk_2->setNewUnit(6);
 	gSk->setValues(-89, 89, 2, 0);
 	gSc->setSuffix(" %");
 	gSc->setValue( 100 );
+
 	connect(gX1,   SIGNAL(valueChanged(double)), this, SLOT(changeSpecialL()));
 	connect(gX2,   SIGNAL(valueChanged(double)), this, SLOT(changeSpecialL()));
 	connect(gY1,   SIGNAL(valueChanged(double)), this, SLOT(changeSpecialL()));
@@ -81,7 +81,8 @@ GradientVectorDialog::GradientVectorDial
 	connect(resetPControlPoint, SIGNAL(clicked()), this, SIGNAL(reset1Control()));
 	connect(resetAllPControlPoints, SIGNAL(clicked()), this, SIGNAL(resetAllControl()));
 	connect(snapToGrid, SIGNAL(clicked()), this, SLOT(handleSnapToGridBox()));
-	QSize iconSize = QSize(22, 22);
+
+	QSize iconSize(22, 22);
 	IconManager& im = IconManager::instance();
 	editPoints->setIcon(im.loadIcon("MoveNode.png"));
 	editPoints->setIconSize(iconSize);
@@ -99,6 +100,7 @@ GradientVectorDialog::GradientVectorDial
 	resetPControlPoint->setIconSize(iconSize);
 	resetAllPControlPoints->setIcon(im.loadIcon("ResetNode.png"));
 	resetAllPControlPoints->setIconSize(iconSize);
+
 	languageChange();
 	selectLinear();
 }
diff -Naupr scribus-1.6.2/scribus/ui/gradientvectordialog.h scribus16x/scribus/ui/gradientvectordialog.h
--- scribus-1.6.2/scribus/ui/gradientvectordialog.h	2024-06-15 16:22:24.000000000 +0200
+++ scribus16x/scribus/ui/gradientvectordialog.h	2025-01-04 10:59:08.312335148 +0100
@@ -71,7 +71,7 @@ public slots:
 	void unitChange(int unitIndex);
 
 protected:
-	double m_unitRatio;
+	double m_unitRatio { 1.0 };
 
 	void changeEvent(QEvent *e) override;
 
diff -Naupr scribus-1.6.2/scribus/ui/guidemanager.cpp scribus16x/scribus/ui/guidemanager.cpp
--- scribus-1.6.2/scribus/ui/guidemanager.cpp	2024-06-15 16:22:23.000000000 +0200
+++ scribus16x/scribus/ui/guidemanager.cpp	2025-01-04 10:59:08.310335190 +0100
@@ -120,7 +120,7 @@ void GuideManager::setDoc(ScribusDoc* do
 	if (m_Doc)
 	{
 		int oldUnitIndex = docUnitIndex;
-		if (oldUnitIndex != docUnitIndex)
+		if (oldUnitIndex != m_Doc->unitIndex())
 			unitChange();
 	}
 
@@ -168,7 +168,7 @@ void GuideManager::setupGui()
 	bool enable = currentPage->guides.horizontalAutoGap() > 0.0;
 	horizontalAutoGapCheck->setChecked(enable);
 	horizontalAutoGapSpin->setEnabled(enable);
-	horizontalAutoGapSpin->setValue(pts2value(currentPage->guides.horizontalAutoGap(), docUnitIndex));
+	horizontalAutoGapSpin->setValue(currentPage->guides.horizontalAutoGap(), SC_PT);
 	horizontalAutoCountSpin->setValue(currentPage->guides.horizontalAutoCount());
 	if (horizontalAutoCountSpin->value()==0)
 	{
@@ -183,7 +183,7 @@ void GuideManager::setupGui()
 	enable = currentPage->guides.verticalAutoGap() > 0.0;
 	verticalAutoGapCheck->setChecked(enable);
 	verticalAutoGapSpin->setEnabled(enable);
-	verticalAutoGapSpin->setValue(pts2value(currentPage->guides.verticalAutoGap(), docUnitIndex));
+	verticalAutoGapSpin->setValue(currentPage->guides.verticalAutoGap(), SC_PT);
 	verticalAutoCountSpin->setValue(currentPage->guides.verticalAutoCount());
 	if (verticalAutoCountSpin->value()==0)
 	{
@@ -213,14 +213,9 @@ void GuideManager::storePageValues(ScPag
 	if (!page || !m_Doc)
 		return;
 
-	// Handle case where page to store values from does not belong
-	// to current doc, eg. when switching between documents
-	const ScribusDoc* doc = page->doc();
-	int unitIndex   = doc->unitIndex();
-
 	double gapValue = 0.0;
 	if (horizontalAutoGapCheck->isChecked())
-		gapValue = value2pts(horizontalAutoGapSpin->value(), unitIndex);
+		gapValue = horizontalAutoGapSpin->getValue(SC_PT);
 	page->guides.setHorizontalAutoGap(gapValue);
 	page->guides.setHorizontalAutoCount(static_cast<int>(horizontalAutoCountSpin->value()));
 	page->guides.setHorizontalAutoRefer(horizontalRefer());
@@ -228,7 +223,7 @@ void GuideManager::storePageValues(ScPag
 
 	gapValue = 0.0;
 	if (verticalAutoGapCheck->isChecked())
-		gapValue = value2pts(verticalAutoGapSpin->value(), unitIndex);
+		gapValue = verticalAutoGapSpin->getValue(SC_PT);
 	page->guides.setVerticalAutoGap(gapValue);
 	page->guides.setVerticalAutoCount(static_cast<int>(verticalAutoCountSpin->value()));
 	page->guides.setVerticalAutoRefer(verticalRefer());
@@ -381,7 +376,7 @@ void GuideManager::horizontalAutoCountSp
 
 void GuideManager::horizontalAutoGapSpin_valueChanged(double)
 {
-	currentPage->guides.setHorizontalAutoGap(value2pts(horizontalAutoGapSpin->value(), docUnitIndex));
+	currentPage->guides.setHorizontalAutoGap(horizontalAutoGapSpin->getValue(SC_PT));
 	drawGuides();
 	m_Doc->changed();
 }
@@ -390,7 +385,7 @@ void GuideManager::horizontalAutoGapChec
 {
 	horizontalAutoGapSpin->setEnabled(horizontalAutoGapCheck->isChecked());
 	if (horizontalAutoGapCheck->isChecked())
-		currentPage->guides.setHorizontalAutoGap(value2pts(horizontalAutoGapSpin->value(), docUnitIndex));
+		currentPage->guides.setHorizontalAutoGap(horizontalAutoGapSpin->getValue(SC_PT));
 	else
 		currentPage->guides.setHorizontalAutoGap(0.0);
 	drawGuides();
@@ -412,7 +407,7 @@ void GuideManager::verticalAutoCountSpin
 
 void GuideManager::verticalAutoGapSpin_valueChanged(double)
 {
-	currentPage->guides.setVerticalAutoGap(value2pts(verticalAutoGapSpin->value(), docUnitIndex));
+	currentPage->guides.setVerticalAutoGap(verticalAutoGapSpin->getValue(SC_PT));
 	drawGuides();
 	m_Doc->changed();
 }
@@ -421,7 +416,7 @@ void GuideManager::verticalAutoGapCheck_
 {
 	verticalAutoGapSpin->setEnabled(verticalAutoGapCheck->isChecked());
 	if (verticalAutoGapCheck->isChecked())
-		currentPage->guides.setVerticalAutoGap(value2pts(verticalAutoGapSpin->value(), docUnitIndex));
+		currentPage->guides.setVerticalAutoGap(verticalAutoGapSpin->getValue(SC_PT));
 	else
 		currentPage->guides.setVerticalAutoGap(0.0);
 	drawGuides();
@@ -550,21 +545,16 @@ Guides GuideManager::getAutoVerticals(co
 {
 	GuideManagerCore guides;
 
-	// Handle case where page to store values from does not belong
-	// to current doc, eg. when switching between documents
-	const ScribusDoc* doc = page->doc();
-	int unitIndex = doc->unitIndex();
-
 	double gapValue = 0.0;
 	if (horizontalAutoGapCheck->isChecked())
-		gapValue = value2pts(horizontalAutoGapSpin->value(), unitIndex);
+		gapValue = horizontalAutoGapSpin->getValue(SC_PT);
 	guides.setHorizontalAutoGap(gapValue);
 	guides.setHorizontalAutoCount(static_cast<int>(horizontalAutoCountSpin->value()));
 	guides.setHorizontalAutoRefer(horizontalRefer());
 
 	gapValue = 0.0;
 	if (verticalAutoGapCheck->isChecked())
-		gapValue = value2pts(verticalAutoGapSpin->value(), unitIndex);
+		gapValue = verticalAutoGapSpin->getValue(SC_PT);
 	guides.setVerticalAutoGap(gapValue);
 	guides.setVerticalAutoCount(static_cast<int>(verticalAutoCountSpin->value()));
 	guides.setVerticalAutoRefer(verticalRefer());
@@ -576,21 +566,16 @@ Guides GuideManager::getAutoHorizontals(
 {
 	GuideManagerCore guides;
 
-	// Handle case where page to store values from does not belong
-	// to current doc, eg. when switching between documents
-	const ScribusDoc* doc = page->doc();
-	int unitIndex = doc->unitIndex();
-
 	double gapValue = 0.0;
 	if (horizontalAutoGapCheck->isChecked())
-		gapValue = value2pts(horizontalAutoGapSpin->value(), unitIndex);
+		gapValue = horizontalAutoGapSpin->getValue(SC_PT);
 	guides.setHorizontalAutoGap(gapValue);
 	guides.setHorizontalAutoCount(static_cast<int>(horizontalAutoCountSpin->value()));
 	guides.setHorizontalAutoRefer(horizontalRefer());
 
 	gapValue = 0.0;
 	if (verticalAutoGapCheck->isChecked())
-		gapValue = value2pts(verticalAutoGapSpin->value(), unitIndex);
+		gapValue = verticalAutoGapSpin->getValue(SC_PT);
 	guides.setVerticalAutoGap(gapValue);
 	guides.setVerticalAutoCount(static_cast<int>(verticalAutoCountSpin->value()));
 	guides.setVerticalAutoRefer(verticalRefer());
diff -Naupr scribus-1.6.2/scribus/ui/helpbrowser.cpp scribus16x/scribus/ui/helpbrowser.cpp
--- scribus-1.6.2/scribus/ui/helpbrowser.cpp	2024-06-15 16:22:23.000000000 +0200
+++ scribus16x/scribus/ui/helpbrowser.cpp	2025-01-04 10:59:08.316335065 +0100
@@ -762,7 +762,7 @@ QString HelpBrowser::historyFile() const
 
 void HelpBrowser::displayNoHelp()
 {
-	QString noHelpMsg = tr("<h2><p>Sorry, no manual is installed!</p><p>Please see:</p><ul><li>http://docs.scribus.net for updated documentation</li><li>http://www.scribus.net for downloads</li></ul></h2>",
+	QString noHelpMsg = tr("<h2><p>Sorry, no manual is installed!</p><p>Please see:</p><ul><li>https://docs.scribus.net for updated documentation</li><li>http://www.scribus.net for downloads</li></ul></h2>",
 						   "HTML message for no documentation available to show");
 
 	textBrowser->setHtml(noHelpMsg);
diff -Naupr scribus-1.6.2/scribus/ui/newdocdialog.h scribus16x/scribus/ui/newdocdialog.h
--- scribus-1.6.2/scribus/ui/newdocdialog.h	2024-06-15 16:22:24.000000000 +0200
+++ scribus16x/scribus/ui/newdocdialog.h	2025-01-04 10:59:08.311335169 +0100
@@ -9,34 +9,33 @@ for which a new license (GPL+exception)
 
 #include <QDialog>
 #include <QDialogButtonBox>
-#include <QDropEvent>
 #include <QDragEnterEvent>
 #include <QDragLeaveEvent>
 #include <QDragMoveEvent>
+#include <QDropEvent>
 #include <QListWidget>
 
 class QCheckBox;
 class QComboBox;
-class QGridLayout;
-class QHBoxLayout;
-class QVBoxLayout;
+class QFileDialog;
 class QFrame;
+class QGridLayout;
 class QGroupBox;
+class QHBoxLayout;
 class QLabel;
 class QListWidgetItem;
 class QPushButton;
 class QSpinBox;
+class QVBoxLayout;
 
 #include "scribusapi.h"
 #include "scribusstructs.h"
-
 #include "ui/customfdialog.h"
 #include "ui/nftwidget.h"
 
-class PrefsManager;
 class MarginWidget;
+class PrefsManager;
 class ScrSpinBox;
-class QFileDialog;
 
 class SCRIBUS_API PageLayoutsWidget : public QListWidget
 {
@@ -45,8 +44,10 @@ class SCRIBUS_API PageLayoutsWidget : pu
 public:
 	PageLayoutsWidget(QWidget* parent);
 	~PageLayoutsWidget() = default;
+
 	void arrangeIcons();
 	QSize minimumSizeHint() const override;
+
 	int maxX {0};
 	int maxY {0};
 };
diff -Naupr scribus-1.6.2/scribus/ui/nftwidget.cpp scribus16x/scribus/ui/nftwidget.cpp
--- scribus-1.6.2/scribus/ui/nftwidget.cpp	2024-06-15 16:22:23.000000000 +0200
+++ scribus16x/scribus/ui/nftwidget.cpp	2025-01-04 10:59:08.316335065 +0100
@@ -171,7 +171,7 @@ void nftwidget::setupAbout()
 	text += tr("Downloading Templates");
 	text += "</b><br>";
 	text += tr("Document templates can be found at "
-	           "http://www.scribus.net/ in the Downloads section.");
+	           "https://www.scribus.net/ in the Downloads section.");
 	text += "<br><br>";
 	text += "<b>";
 	text +=  tr("Installing Templates");
diff -Naupr scribus-1.6.2/scribus/ui/nftwidget.h scribus16x/scribus/ui/nftwidget.h
--- scribus-1.6.2/scribus/ui/nftwidget.h	2024-06-15 16:22:25.000000000 +0200
+++ scribus16x/scribus/ui/nftwidget.h	2025-01-04 10:59:08.313335127 +0100
@@ -19,9 +19,7 @@ for which a new license (GPL+exception)
 
 class QAction;
 
-
-typedef std::pair<nfttemplate*, QListWidgetItem*> ListItem;
-
+using ListItem = std::pair<nfttemplate*, QListWidgetItem*>;
 
 class nftwidget: public QWidget, public Ui::nftwidget
 {
diff -Naupr scribus-1.6.2/scribus/ui/nodeeditpalette.cpp scribus16x/scribus/ui/nodeeditpalette.cpp
--- scribus-1.6.2/scribus/ui/nodeeditpalette.cpp	2024-06-15 16:22:23.000000000 +0200
+++ scribus16x/scribus/ui/nodeeditpalette.cpp	2025-01-04 10:59:08.310335190 +0100
@@ -21,9 +21,9 @@ for which a new license (GPL+exception)
 
 NodePalette::NodePalette( QWidget* parent) : ScrPaletteBase(parent, "nodePalette", false, Qt::WindowFlags())
 {
-	QSize iconSize = QSize(22, 22);
-	QSize buttonSize = QSize(24, 24);
-	QSize maxButtonSize = QSize(16777215, buttonSize.height());
+	QSize iconSize(22, 22);
+	QSize buttonSize(24, 24);
+	QSize maxButtonSize(16777215, buttonSize.height());
 	QSizePolicy::Policy buttonSizePolicy = static_cast<QSizePolicy::Policy>(QSizePolicy::GrowFlag | QSizePolicy::ExpandFlag);
 
 	m_doc = nullptr;
@@ -508,14 +508,14 @@ void NodePalette::doReduce()
 {
 	if (m_doc == nullptr)
 		return;
-	m_view->TransformPoly(8, 1, value2pts(scaleDistance->value(),m_doc->unitIndex()));
+	m_view->TransformPoly(8, 1, scaleDistance->getValue(SC_PT));
 }
 
 void NodePalette::doEnlarge()
 {
 	if (m_doc == nullptr)
 		return;
-	m_view->TransformPoly(9, 1, value2pts(scaleDistance->value(),m_doc->unitIndex()));
+	m_view->TransformPoly(9, 1, scaleDistance->getValue(SC_PT));
 }
 
 void NodePalette::ShearR()
diff -Naupr scribus-1.6.2/scribus/ui/preferencesdialog.cpp scribus16x/scribus/ui/preferencesdialog.cpp
--- scribus-1.6.2/scribus/ui/preferencesdialog.cpp	2024-06-15 16:22:23.000000000 +0200
+++ scribus16x/scribus/ui/preferencesdialog.cpp	2025-01-04 10:59:08.313335127 +0100
@@ -28,7 +28,7 @@ PreferencesDialog::PreferencesDialog(QWi
 {
 	setupUi(this);
 	setObjectName(QString::fromLocal8Bit("PreferencesDialog"));
-	setupListWidget();
+	preferencesTypeList->clear();
 	while (prefsStackWidget->currentWidget() != nullptr)
 		prefsStackWidget->removeWidget(prefsStackWidget->currentWidget());
 
@@ -235,24 +235,6 @@ void PreferencesDialog::accept()
 	QDialog::accept();
 }
 
-void PreferencesDialog::setupListWidget()
-{
-	preferencesTypeList->setDragEnabled(false);
-	preferencesTypeList->setViewMode(QListView::ListMode);
-	preferencesTypeList->setFlow(QListView::TopToBottom);
-	preferencesTypeList->setIconSize(QSize(32,32));
-	preferencesTypeList->setSortingEnabled(false);
-	preferencesTypeList->setWrapping(false);
-	preferencesTypeList->setWordWrap(true);
-	preferencesTypeList->setAcceptDrops(false);
-	preferencesTypeList->setDropIndicatorShown(false);
-	preferencesTypeList->setDragDropMode(QAbstractItemView::NoDragDrop);
-	//preferencesTypeList->setResizeMode(QListView::Adjust);
-	preferencesTypeList->setSelectionMode(QAbstractItemView::SingleSelection);
-	preferencesTypeList->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
-	preferencesTypeList->clear();
-}
-
 void PreferencesDialog::addWidget(Prefs_Pane* tab)
 {
 	//TODO: Can we avoid using this name and duplicating strings by getting it from the tab UIs
diff -Naupr scribus-1.6.2/scribus/ui/preferencesdialog.h scribus16x/scribus/ui/preferencesdialog.h
--- scribus-1.6.2/scribus/ui/preferencesdialog.h	2024-06-15 16:22:23.000000000 +0200
+++ scribus16x/scribus/ui/preferencesdialog.h	2025-01-04 10:59:08.313335127 +0100
@@ -79,7 +79,6 @@ class SCRIBUS_API PreferencesDialog : pu
 
 	protected:
 		void addWidget(Prefs_Pane* tab);
-		void setupListWidget();
 		void arrangeIcons();
 		void initPreferenceValues();
 		/*! \brief Scans plugins for those that want to add a prefs widget and
diff -Naupr scribus-1.6.2/scribus/ui/preferencesdialogbase.ui scribus16x/scribus/ui/preferencesdialogbase.ui
--- scribus-1.6.2/scribus/ui/preferencesdialogbase.ui	2024-06-15 16:22:24.000000000 +0200
+++ scribus16x/scribus/ui/preferencesdialogbase.ui	2025-01-04 10:59:08.313335127 +0100
@@ -45,6 +45,9 @@
          <height>16777215</height>
         </size>
        </property>
+       <property name="horizontalScrollBarPolicy">
+        <enum>Qt::ScrollBarAlwaysOff</enum>
+       </property>
        <property name="editTriggers">
         <set>QAbstractItemView::NoEditTriggers</set>
        </property>
@@ -52,23 +55,29 @@
         <bool>false</bool>
        </property>
        <property name="dragDropMode">
-        <enum>QAbstractItemView::DragDrop</enum>
+        <enum>QAbstractItemView::NoDragDrop</enum>
        </property>
        <property name="alternatingRowColors">
         <bool>true</bool>
        </property>
+       <property name="iconSize">
+        <size>
+         <width>16</width>
+         <height>16</height>
+        </size>
+       </property>
+       <property name="resizeMode">
+        <enum>QListView::Adjust</enum>
+       </property>
        <property name="spacing">
         <number>1</number>
        </property>
        <property name="viewMode">
-        <enum>QListView::IconMode</enum>
+        <enum>QListView::ListMode</enum>
        </property>
        <property name="wordWrap">
         <bool>true</bool>
        </property>
-       <property name="itemAlignment">
-        <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignTop</set>
-       </property>
       </widget>
      </item>
      <item>
diff -Naupr scribus-1.6.2/scribus/ui/prefs_colormanagement.h scribus16x/scribus/ui/prefs_colormanagement.h
--- scribus-1.6.2/scribus/ui/prefs_colormanagement.h	2024-06-15 16:22:23.000000000 +0200
+++ scribus16x/scribus/ui/prefs_colormanagement.h	2025-01-04 10:59:08.313335127 +0100
@@ -14,7 +14,7 @@ for which a new license (GPL+exception)
 
 class ScribusDoc;
 
-typedef QMap<QString,QString> ProfilesL;
+using ProfilesL = QMap<QString, QString>;
 
 class SCRIBUS_API Prefs_ColorManagement : public Prefs_Pane, Ui::Prefs_ColorManagement
 {
diff -Naupr scribus-1.6.2/scribus/ui/prefs_spelling.cpp scribus16x/scribus/ui/prefs_spelling.cpp
--- scribus-1.6.2/scribus/ui/prefs_spelling.cpp	2024-06-15 16:22:24.000000000 +0200
+++ scribus16x/scribus/ui/prefs_spelling.cpp	2025-01-04 10:59:08.313335127 +0100
@@ -78,31 +78,31 @@ void Prefs_Spelling::downloadSpellDicts(
 	downloadProgressBar->setValue(0);
 	downloadProgressBar->setVisible(true);
 	dlLabel->setVisible(true);
-	int i=0;
+	int i = 0;
 	QString userDictDir(ScPaths::userDictDir(ScPaths::Spell, true));
-	foreach(DownloadItem d, dictList)
+	for (const DownloadItem& d : dictList)
 	{
 		if (dlLangs.contains(d.lang))
 		{
-			if (d.filetype=="zip")
+			if (d.filetype == "zip")
 			{
 				ScQApp->dlManager()->addURL(d.url, true, downloadLocation, userDictDir);
 				++i;
 			}
-			if (d.filetype=="plain")
+			if (d.filetype == "plain")
 			{
 				//qDebug()<<d.url<<d.files;
 				const QStringList plainURLs(d.files.split(";", Qt::SkipEmptyParts));
 				for (const QString& s : plainURLs)
 				{
-					ScQApp->dlManager()->addURL(d.url+"/"+s, true, downloadLocation, userDictDir);
+					ScQApp->dlManager()->addURL(d.url + "/" + s, true, downloadLocation, userDictDir);
 					++i;
 				}
 				downloadList.append(d);
 			}
 		}
 	}
-	if (i>0)
+	if (i > 0)
 	{
 		downloadProgressBar->setRange(0, i);
 		connect(ScQApp->dlManager(), SIGNAL(finished()), this, SLOT(downloadSpellDictsFinished()));
@@ -243,9 +243,9 @@ void Prefs_Spelling::setAvailDictsXMLFil
 	availDictTableWidget->setRowCount(dictList.count());
 	availDictTableWidget->setColumnCount(4);
 	int row = 0;
-	foreach(DownloadItem d, dictList)
+	for (const DownloadItem& d : dictList)
 	{
-		int column=0;
+		int column = 0;
 		//qDebug()<<d.version<<d.files<<d.url<<d.desc<<d.license;
 		QTableWidgetItem *newItem1 = new QTableWidgetItem(d.desc);
 		newItem1->setFlags(newItem1->flags() & ~Qt::ItemIsEditable);
diff -Naupr scribus-1.6.2/scribus/ui/propertiespalette_shape.cpp scribus16x/scribus/ui/propertiespalette_shape.cpp
--- scribus-1.6.2/scribus/ui/propertiespalette_shape.cpp	2024-06-15 16:22:24.000000000 +0200
+++ scribus16x/scribus/ui/propertiespalette_shape.cpp	2025-01-04 10:59:08.313335127 +0100
@@ -351,7 +351,7 @@ void PropertiesPalette_Shape::setCurrent
 	{
 		nonZero->setEnabled(true);
 		evenOdd->setEnabled(true);
-		nonZero->setChecked(!m_item->fillRule);
+		showFillRule(m_item->fillRule);
 	}
 	setLocked(m_item->locked());
 	setSizeLocked(m_item->sizeLocked());
@@ -472,7 +472,7 @@ void PropertiesPalette_Shape::handleFill
 {
 	if (!m_haveDoc || !m_haveItem || !m_ScMW || m_ScMW->scriptIsRunning())
 		return;
-	m_item->fillRule = evenOdd->isChecked();
+	m_item->setFillEvenOdd(evenOdd->isChecked());
 	m_item->update();
 }
 
@@ -498,6 +498,14 @@ void PropertiesPalette_Shape::handleNewS
 	}
 }
 
+void PropertiesPalette_Shape::showFillRule(bool fillRule)
+{
+	if (fillRule)
+		evenOdd->setChecked(fillRule);
+	else
+		nonZero->setChecked(!fillRule);
+}
+
 void PropertiesPalette_Shape::showTextFlowMode(PageItem::TextFlowMode mode)
 {
 	if (!m_ScMW || m_ScMW->scriptIsRunning() || !m_haveItem)
diff -Naupr scribus-1.6.2/scribus/ui/propertiespalette_shape.h scribus16x/scribus/ui/propertiespalette_shape.h
--- scribus-1.6.2/scribus/ui/propertiespalette_shape.h	2024-06-15 16:22:24.000000000 +0200
+++ scribus16x/scribus/ui/propertiespalette_shape.h	2025-01-04 10:59:08.313335127 +0100
@@ -35,6 +35,7 @@ public:
 	void setLocked(bool isLocked);
 	void setSizeLocked(bool isLocked);
 	void setRoundRectEnabled(bool enabled);
+	void showFillRule(bool fillRule);
 	void showTextFlowMode(PageItem::TextFlowMode mode);
 
 protected:
diff -Naupr scribus-1.6.2/scribus/ui/propertywidget_textcolor.cpp scribus16x/scribus/ui/propertywidget_textcolor.cpp
--- scribus-1.6.2/scribus/ui/propertywidget_textcolor.cpp	2024-06-15 16:22:24.000000000 +0200
+++ scribus16x/scribus/ui/propertywidget_textcolor.cpp	2025-01-04 10:59:08.315335085 +0100
@@ -196,9 +196,6 @@ void PropertyWidget_TextColor::updateCol
 	fillColor->setColors(m_doc->PageColors, true);
 	strokeColor->setColors(m_doc->PageColors, false);
 	backColor->setColors(m_doc->PageColors, true);
-	fillColor->view()->setMinimumWidth(fillColor->view()->maximumViewportSize().width() + 24);
-	strokeColor->view()->setMinimumWidth(strokeColor->view()->maximumViewportSize().width() + 24);
-	backColor->view()->setMinimumWidth(backColor->view()->maximumViewportSize().width() + 24);
 
 	if (m_item)
 		setCurrentItem(m_item);
diff -Naupr scribus-1.6.2/scribus/ui/resourcemanager.cpp scribus16x/scribus/ui/resourcemanager.cpp
--- scribus-1.6.2/scribus/ui/resourcemanager.cpp	2024-06-15 16:22:24.000000000 +0200
+++ scribus16x/scribus/ui/resourcemanager.cpp	2025-01-04 10:59:08.312335148 +0100
@@ -128,9 +128,9 @@ void ResourceManager::readAvailableFonts
 	{
 //		qDebug()<<errorMsg<<eline<<ecol;
 		if (data.contains("404 not found", Qt::CaseInsensitive))
-			qDebug()<<"File not found on server";
+			qDebug() << "File not found on server";
 		else
-			qDebug()<<"Could not open file"<<dataFile.fileName();
+			qDebug() << "Could not open file" << dataFile.fileName();
 		return;
 	}
 	m_availableList.clear();
@@ -162,7 +162,7 @@ void ResourceManager::readAvailableFonts
 		if (url.isValid() && !url.isEmpty() && !url.host().isEmpty())
 			m_availableList.append(d);
 //		else
-//			qDebug()<<"rm : availFonts : invalid URL"<<d.url;
+//			qDebug() << "rm : availFonts : invalid URL" << d.url;
 	}
 }
 
@@ -185,9 +185,9 @@ void ResourceManager::readAvailableHelp(
 	if ( !doc.setContent( data, &errorMsg, &eline, &ecol ))
 	{
 		if (data.contains("404 not found", Qt::CaseInsensitive))
-			qDebug()<<"File not found on server";
+			qDebug() << "File not found on server";
 		else
-			qDebug()<<"Could not open file"<<dataFile.fileName();
+			qDebug() << "Could not open file" << dataFile.fileName();
 		return;
 	}
 	m_availableList.clear();
@@ -241,9 +241,9 @@ void ResourceManager::readAvailablePalet
 	if ( !doc.setContent( data, &errorMsg, &eline, &ecol ))
 	{
 		if (data.contains("404 not found", Qt::CaseInsensitive))
-			qDebug()<<"File not found on server";
+			qDebug() << "File not found on server";
 		else
-			qDebug()<<"Could not open file"<<dataFile.fileName();
+			qDebug() << "Could not open file" << dataFile.fileName();
 		return;
 	}
 	m_availableList.clear();
@@ -527,7 +527,7 @@ void ResourceManager::updateAvailableFon
 	availableTableWidget->setSortingEnabled(false);
 
 	int row = 0;
-	for (const DownloadItem& d :  qAsConst(m_availableList))
+	for (const DownloadItem& d : qAsConst(m_availableList))
 	{
 		int column = 0;
 //		qDebug()<<d.version<<d.files<<d.url<<d.desc<<d.license;
@@ -576,9 +576,9 @@ void ResourceManager::updateAvailableHyp
 	if ( !doc.setContent( data, &errorMsg, &eline, &ecol ))
 	{
 		if (data.contains("404 not found", Qt::CaseInsensitive))
-			qDebug()<<"File not found on server";
+			qDebug() << "File not found on server";
 		else
-			qDebug()<<"Could not open file"<<dataFile.fileName();
+			qDebug() << "Could not open file" << dataFile.fileName();
 		return;
 	}
 	m_availableList.clear();
@@ -611,7 +611,7 @@ void ResourceManager::updateAvailableHyp
 		if (url.isValid() && !url.isEmpty() && !url.host().isEmpty())
 			m_availableList.append(d);
 		//else
-		//	qDebug()<<"hysettings : availDicts : invalid URL"<<d.url;
+		//	qDebug() << "hysettings : availDicts : invalid URL" << d.url;
 	}
 	availableTableWidget->clear();
 	if (m_availableList.isEmpty())
@@ -676,9 +676,9 @@ void ResourceManager::updateAvailableSpe
 	if ( !doc.setContent( data, &errorMsg, &eline, &ecol ))
 	{
 		if (data.contains("404 not found", Qt::CaseInsensitive))
-			qDebug()<<"File not found on server";
+			qDebug() << "File not found on server";
 		else
-			qDebug()<<"Could not open file"<<dataFile.fileName();
+			qDebug() << "Could not open file" << dataFile.fileName();
 		return;
 	}
 	m_availableList.clear();
@@ -711,7 +711,7 @@ void ResourceManager::updateAvailableSpe
 		if (url.isValid() && !url.isEmpty() && !url.host().isEmpty())
 			m_availableList.append(d);
 		//else
-		//	qDebug()<<"hysettings : availDicts : invalid URL"<<d.url;
+		//	qDebug() << "hysettings : availDicts : invalid URL" << d.url;
 	}
 	availableTableWidget->clear();
 	if (m_availableList.isEmpty())
@@ -775,7 +775,7 @@ void ResourceManager::updateAvailableHel
 	availableTableWidget->setSortingEnabled(false);
 
 	int row = 0;
-	for (const DownloadItem& d :  qAsConst(m_availableList))
+	for (const DownloadItem& d : qAsConst(m_availableList))
 	{
 		int column = 0;
 		QTableWidgetItem *newItem1 = new QTableWidgetItem(d.desc);
@@ -980,19 +980,19 @@ void ResourceManager::downloadListFinish
 			if (fileOk)
 				updateAvailableHelp();
 			else
-				qDebug()<<"Help Failure :(";
+				qDebug() << "Help Failure :(";
 			break;
 		case RM_PALETTES:
 			if (fileOk)
 				updateAvailablePalettes();
 			else
-				qDebug()<<"Palette Failure :(";
+				qDebug() << "Palette Failure :(";
 			break;
 		case RM_TEST:
 			if (fileOk)
-				qDebug()<<"Success!!!";
+				qDebug() << "Success!!!";
 			else
-				qDebug()<<"Failure :(";
+				qDebug() << "Failure :(";
 			break;
 	}
 	updateAvailableButton->setEnabled(true);
@@ -1020,23 +1020,22 @@ void ResourceManager::downloadFilesFinis
 		case RM_FONTS:
 			for (const DownloadItem& d : qAsConst(m_downloadList))
 			{
-				if (d.filetype=="zip")
+				if (d.filetype == "zip")
 				{
-					QString fn(ScPaths::userFontDir(true)+d.files);
+					QString fn(ScPaths::userFontDir(true) + d.files);
 					QFile dledFile(fn);
 					QFileInfo fi(dledFile);
 					if (!dledFile.exists())
-						qDebug()<<"File doesn\'t exist"<<fn;
+						qDebug() << "File doesn\'t exist" << fn;
 					else
 					{
 						ScZipHandler* fun = new ScZipHandler();
 						if (!fun->open(fn))
-							qDebug()<<"Zip file doesn\'t open"<<fn;
+							qDebug() << "Zip file doesn\'t open" << fn;
 						else
 						{
 							const QStringList zipFileContents(fun->files());
-							QStringList extractFiles(d.extractfiles.split(";", Qt::SkipEmptyParts));
-							QString toDir(ScPaths::userFontDir(false)+fi.baseName()+"/");
+							QString toDir(ScPaths::userFontDir(false) + fi.baseName() + "/");
 							QDir dir(ScPaths::userFontDir(false));
 							if (!dir.exists(fi.baseName()))
 								dir.mkdir(fi.baseName());
@@ -1048,7 +1047,7 @@ void ResourceManager::downloadFilesFinis
 						delete fun;
 					}
 				}
-				if (d.filetype=="plain")
+				if (d.filetype == "plain")
 				{
 					//do nothing as the file is already in place from dl mgr
 				}
@@ -1060,16 +1059,16 @@ void ResourceManager::downloadFilesFinis
 				int fileType = category == RM_HYPH ? ScPaths::Hyph : ScPaths::Spell;
 				for (const DownloadItem& d : qAsConst(m_downloadList))
 				{
-					if (d.filetype=="zip")
+					if (d.filetype == "zip")
 					{
-						QString fn(ScPaths::userDictDir(static_cast<ScPaths::DictType>(fileType), true)+d.files);
+						QString fn(ScPaths::userDictDir(static_cast<ScPaths::DictType>(fileType), true) + d.files);
 						if (!QFileInfo::exists(fn))
-							qDebug()<<"File doesn\'t exist"<<fn;
+							qDebug() << "File doesn\'t exist" << fn;
 						else
 						{
 							ScZipHandler* fun = new ScZipHandler();
 							if (!fun->open(fn))
-								qDebug()<<"Zip file doesn\'t open"<<fn;
+								qDebug() << "Zip file doesn\'t open" << fn;
 							else
 							{
 								const QStringList zipContents(fun->files());
@@ -1088,7 +1087,7 @@ void ResourceManager::downloadFilesFinis
 							delete fun;
 						}
 					}
-					if (d.filetype=="plain")
+					if (d.filetype == "plain")
 					{
 						//do nothing as the file is already in place from dl mgr
 					}
@@ -1105,7 +1104,7 @@ void ResourceManager::downloadFilesFinis
 					//qDebug() << fn;
 					QFile dledFile(fn);
 					QFileInfo fi(dledFile);
-					QFile dledFileSHA256(fn+".sha256");
+					QFile dledFileSHA256(fn + ".sha256");
 					QFileInfo fiSHA256(dledFileSHA256);
 					if (!dledFile.exists() || !dledFileSHA256.exists())
 						qDebug() << "File doesn\'t exist" << fn << fn + ".sha256";
diff -Naupr scribus-1.6.2/scribus/ui/scfilewidget.cpp scribus16x/scribus/ui/scfilewidget.cpp
--- scribus-1.6.2/scribus/ui/scfilewidget.cpp	2024-06-15 16:22:23.000000000 +0200
+++ scribus16x/scribus/ui/scfilewidget.cpp	2025-01-04 10:59:08.311335169 +0100
@@ -1,146 +1,162 @@
-/*
-For general Scribus (>=1.3.2) copyright and licensing information please refer
-to the COPYING file provided with the program. Following this notice may exist
-a copyright and/or license notice that predates the release of Scribus 1.3.2
-for which a new license (GPL+exception) is in place.
-*/
-
-#include <cstdlib>
-
-#include <QDebug>
-#include <QStandardPaths>
-#include <QLayout>
-#include <QLineEdit>
-#include <QListView>
-#include <QPushButton>
-#include <QStringList>
-#include <QUrl>
-
-#include "filedialogeventcatcher.h"
-#include "scfilewidget.h"
-
-
-ScFileWidget::ScFileWidget(QWidget * parent) : QFileDialog(parent, Qt::Widget)
-{
-	setOption(QFileDialog::DontUseNativeDialog);
-	setSizeGripEnabled(false);
-	setModal(false);
-	setViewMode(QFileDialog::List);
-	setWindowFlags(Qt::Widget);
-
-	// The margins' content should be set both on the widget and its layout.
-	setContentsMargins(0, 0, 0, 0);
-	layout()->setContentsMargins(0, 0, 0, 0);
-
-#ifdef Q_OS_MACOS
-	QList<QUrl> urls;
-	QUrl computer(QUrl::fromLocalFile(QLatin1String("")));
-	if (!urls.contains(computer))
-		urls << computer;
-	QUrl volumes(QUrl::fromLocalFile("/Volumes"));
-	if (!urls.contains(volumes))
-		urls << volumes;
-	QUrl home(QUrl::fromLocalFile(QStandardPaths::writableLocation(QStandardPaths::HomeLocation)));
-	if (!urls.contains(home))
-		urls << home;
-	QUrl documents(QUrl::fromLocalFile(QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation)));
-	if (!urls.contains(documents))
-		urls << documents;
-	QUrl dt(QUrl::fromLocalFile(QStandardPaths::writableLocation(QStandardPaths::DesktopLocation)));
-	if (!urls.contains(dt))
-		urls << dt;
-	setSidebarUrls(urls);
-#endif
-
-	FileDialogEventCatcher* keyCatcher = new FileDialogEventCatcher(this);
-	QList<QListView *> childListViews = findChildren<QListView *>();
-	for (QListView * lvi : childListViews)
-		lvi->installEventFilter(keyCatcher);
-	connect(keyCatcher, SIGNAL(escapePressed()), this, SLOT(reject()));
-	connect(keyCatcher, SIGNAL(dropLocation(QString)), this, SLOT(locationDropped(QString)));
-	connect(keyCatcher, SIGNAL(desktopPressed()), this, SLOT(gotoDesktopDirectory()));
-	connect(keyCatcher, SIGNAL(homePressed()), this, SLOT(gotoHomeDirectory()));
-	connect(keyCatcher, SIGNAL(parentPressed()), this, SLOT(gotoParentDirectory()));
-	connect(keyCatcher, SIGNAL(enterSelectedPressed()), this, SLOT(gotoSelectedDirectory()));
-
-	QList<QPushButton *> childPushButtons = findChildren<QPushButton *>();
-	for (QPushButton* pb : childPushButtons)
-		pb->setVisible(false);
-	setMinimumSize(QSize(480, 310));
-	setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);
-}
-
-void ScFileWidget::forceDoubleClickActivation(bool force)
-{
-	// Hack to make the previews in our file dialogs usable again,
-	// needed e.g on OpenSuse KDE. Otherwise file would open on first
-	// click, leaving user no time to see preview.
-	if (m_forceDoubleClickActivation == force)
-		return;
-
-	if (force)
-		setStyleSheet(QStringLiteral("QAbstractItemView { activate-on-singleclick: 0; }"));
-	else
-		setStyleSheet(QString());
-	m_forceDoubleClickActivation = force;
-}
-
-QString ScFileWidget::selectedFile()
-{
-	QStringList l(selectedFiles());
-	if (l.count() == 0)
-		return QString();
-	return l.at(0);
-}
-
-void ScFileWidget::locationDropped(const QString& fileUrl)
-{
-	QFileInfo fi(fileUrl);
-	if (fi.isDir())
-	{
-		setDirectory(fi.absoluteFilePath());
-		return;
-	}
-
-	QString absFilePath = fi.absolutePath();
-	QString fileName = fi.fileName();
-		
-	setDirectory(absFilePath);
-	selectFile(fileName);
-}
-
-void ScFileWidget::gotoParentDirectory()
-{
-	QDir d(directory());
-	d.cdUp();
-	setDirectory(d);
-}
-
-void ScFileWidget::gotoSelectedDirectory()
-{
-	QStringList s(selectedFiles());
-	if (!s.isEmpty())
-	{
-		QFileInfo fi(s.first());
-//		qDebug()<<s.first()<<fi.absoluteFilePath();
-		if (fi.isDir())
-			setDirectory(fi.absoluteFilePath());
-	}
-}
-
-void ScFileWidget::gotoDesktopDirectory()
-{
-	QString dp = QStandardPaths::writableLocation(QStandardPaths::DesktopLocation);
-	QFileInfo fi(dp);
-	if (fi.exists())
-		setDirectory(dp);
-}
-
-void ScFileWidget::gotoHomeDirectory()
-{
-	QString dp = QStandardPaths::writableLocation(QStandardPaths::HomeLocation);
-	QFileInfo fi(dp);
-	if (fi.exists())
-		setDirectory(dp);
-}
-
+/*
+For general Scribus (>=1.3.2) copyright and licensing information please refer
+to the COPYING file provided with the program. Following this notice may exist
+a copyright and/or license notice that predates the release of Scribus 1.3.2
+for which a new license (GPL+exception) is in place.
+*/
+
+#include <cstdlib>
+
+#include <QDebug>
+#include <QLayout>
+#include <QLineEdit>
+#include <QListView>
+#include <QPushButton>
+#include <QStandardPaths>
+#include <QStorageInfo>
+#include <QStringList>
+#include <QUrl>
+
+#include "filedialogeventcatcher.h"
+#include "scfilewidget.h"
+
+
+ScFileWidget::ScFileWidget(QWidget * parent) : QFileDialog(parent, Qt::Widget)
+{
+	setOption(QFileDialog::DontUseNativeDialog);
+	setSizeGripEnabled(false);
+	setModal(false);
+	setViewMode(QFileDialog::List);
+	setWindowFlags(Qt::Widget);
+
+	// The margins' content should be set both on the widget and its layout.
+	setContentsMargins(0, 0, 0, 0);
+	layout()->setContentsMargins(0, 0, 0, 0);
+
+#ifdef Q_OS_MACOS
+	QList<QUrl> urls;
+	QUrl macOSUrl(QUrl::fromLocalFile(QLatin1String("")));
+	if (!urls.contains(macOSUrl))
+		urls << macOSUrl;
+	macOSUrl = QUrl::fromLocalFile("/Volumes");
+	if (!urls.contains(macOSUrl))
+		urls << macOSUrl;
+	macOSUrl = QUrl::fromLocalFile(QStandardPaths::writableLocation(QStandardPaths::HomeLocation));
+	if (!urls.contains(macOSUrl))
+		urls << macOSUrl;
+	macOSUrl = QUrl::fromLocalFile(QStandardPaths::writableLocation(QStandardPaths::DesktopLocation));
+	if (!urls.contains(macOSUrl))
+		urls << macOSUrl;
+	macOSUrl = QUrl::fromLocalFile(QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation));
+	if (!urls.contains(macOSUrl))
+		urls << macOSUrl;
+	macOSUrl = QUrl::fromLocalFile(QStandardPaths::writableLocation(QStandardPaths::DownloadLocation));
+	if (!urls.contains(macOSUrl))
+		urls << macOSUrl;
+	setSidebarUrls(urls);
+#endif
+
+#ifdef Q_OS_LINUX
+	QList<QUrl> urls(sidebarUrls());
+	QUrl linuxOSUrl;
+	foreach (const QStorageInfo &storage, QStorageInfo::mountedVolumes())
+	{
+		linuxOSUrl = QUrl::fromLocalFile(storage.rootPath());
+		if (storage.rootPath().startsWith("/media") && !urls.contains(linuxOSUrl))
+			urls << linuxOSUrl;
+	}
+	setSidebarUrls(urls);
+#endif
+
+	FileDialogEventCatcher* keyCatcher = new FileDialogEventCatcher(this);
+	QList<QListView *> childListViews = findChildren<QListView *>();
+	for (QListView * lvi : childListViews)
+		lvi->installEventFilter(keyCatcher);
+	connect(keyCatcher, SIGNAL(escapePressed()), this, SLOT(reject()));
+	connect(keyCatcher, SIGNAL(dropLocation(QString)), this, SLOT(locationDropped(QString)));
+	connect(keyCatcher, SIGNAL(desktopPressed()), this, SLOT(gotoDesktopDirectory()));
+	connect(keyCatcher, SIGNAL(homePressed()), this, SLOT(gotoHomeDirectory()));
+	connect(keyCatcher, SIGNAL(parentPressed()), this, SLOT(gotoParentDirectory()));
+	connect(keyCatcher, SIGNAL(enterSelectedPressed()), this, SLOT(gotoSelectedDirectory()));
+
+	QList<QPushButton *> childPushButtons = findChildren<QPushButton *>();
+	for (QPushButton* pb : childPushButtons)
+		pb->setVisible(false);
+	setMinimumSize(QSize(480, 310));
+	setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);
+}
+
+void ScFileWidget::forceDoubleClickActivation(bool force)
+{
+	// Hack to make the previews in our file dialogs usable again,
+	// needed e.g on OpenSuse KDE. Otherwise file would open on first
+	// click, leaving user no time to see preview.
+	if (m_forceDoubleClickActivation == force)
+		return;
+
+	if (force)
+		setStyleSheet(QStringLiteral("QAbstractItemView { activate-on-singleclick: 0; }"));
+	else
+		setStyleSheet(QString());
+	m_forceDoubleClickActivation = force;
+}
+
+QString ScFileWidget::selectedFile()
+{
+	QStringList l(selectedFiles());
+	if (l.count() == 0)
+		return QString();
+	return l.at(0);
+}
+
+void ScFileWidget::locationDropped(const QString& fileUrl)
+{
+	QFileInfo fi(fileUrl);
+	if (fi.isDir())
+	{
+		setDirectory(fi.absoluteFilePath());
+		return;
+	}
+
+	QString absFilePath = fi.absolutePath();
+	QString fileName = fi.fileName();
+		
+	setDirectory(absFilePath);
+	selectFile(fileName);
+}
+
+void ScFileWidget::gotoParentDirectory()
+{
+	QDir d(directory());
+	d.cdUp();
+	setDirectory(d);
+}
+
+void ScFileWidget::gotoSelectedDirectory()
+{
+	QStringList s(selectedFiles());
+	if (!s.isEmpty())
+	{
+		QFileInfo fi(s.first());
+//		qDebug()<<s.first()<<fi.absoluteFilePath();
+		if (fi.isDir())
+			setDirectory(fi.absoluteFilePath());
+	}
+}
+
+void ScFileWidget::gotoDesktopDirectory()
+{
+	QString dp = QStandardPaths::writableLocation(QStandardPaths::DesktopLocation);
+	QFileInfo fi(dp);
+	if (fi.exists())
+		setDirectory(dp);
+}
+
+void ScFileWidget::gotoHomeDirectory()
+{
+	QString dp = QStandardPaths::writableLocation(QStandardPaths::HomeLocation);
+	QFileInfo fi(dp);
+	if (fi.exists())
+		setDirectory(dp);
+}
+
diff -Naupr scribus-1.6.2/scribus/ui/scrspinbox.cpp scribus16x/scribus/ui/scrspinbox.cpp
--- scribus-1.6.2/scribus/ui/scrspinbox.cpp	2024-06-15 16:22:23.000000000 +0200
+++ scribus16x/scribus/ui/scrspinbox.cpp	2025-01-04 10:59:08.311335169 +0100
@@ -65,6 +65,13 @@ void ScrSpinBox::setValue(double val)
 	QDoubleSpinBox::setValue(val);
 }
 
+void ScrSpinBox::setValue(double val, int unitIndex)
+{
+	double val1 = val / unitGetRatioFromIndex(unitIndex);
+	double val2 = val1 * unitGetRatioFromIndex(m_unitIndex);
+	QDoubleSpinBox::setValue(val2);
+}
+
 void ScrSpinBox::showValue(double val)
 {
 	bool sigBlocked = this->blockSignals(true);
@@ -224,6 +231,7 @@ double ScrSpinBox::valueFromText(const Q
 	ts.replace("%", "");
 	ts.replace("°", "");
 	ts.replace(FinishTag, "");
+	ts.replace(suffix(), ""); // We have to remove custom suffix to get a valid input
 	ts = ts.trimmed();
 
 	if (ts.endsWith(su))
@@ -327,8 +335,7 @@ void ScrSpinBox::textChanged()
 
 bool ScrSpinBox::eventFilter(QObject* watched, QEvent* event)
 {
-	bool retval = false;
-/* Adding this to be sure that the IM* events are processed correctly i.e not intercepted by our KeyPress/Release handlers */
+	/* Adding this to be sure that the IM* events are processed correctly i.e not intercepted by our KeyPress/Release handlers */
  	if (event->type() == QEvent::InputMethod)
  		return QDoubleSpinBox::eventFilter(watched, event);
 
@@ -338,29 +345,36 @@ bool ScrSpinBox::eventFilter(QObject* wa
 		if (isReadOnly())
 			return false;
 		auto* wheelEvent = dynamic_cast<QWheelEvent*>(event);
+		int oldStep = singleStep(); // remember old single steps
 		bool shiftB = wheelEvent->modifiers() & Qt::ShiftModifier;
-		bool altB = wheelEvent->modifiers() & Qt::AltModifier;
-		if (shiftB && !altB)
-		{
+		bool ctrlB = wheelEvent->modifiers() & Qt::ControlModifier; // for macOS it is CMD button
+
+		if (shiftB && !ctrlB)
 			setSingleStep((m_unitIndex == SC_INCHES) ? 0.0625 : 0.1);
-			retval = QAbstractSpinBox::event(event);
-		}
-		else if (!shiftB && altB)
-		{
+		else if (!shiftB && ctrlB)
 			setSingleStep((m_unitIndex == SC_INCHES) ? 1.0 : 10.0);
-			retval = QAbstractSpinBox::event(event);
-		}
-		else if (shiftB && altB)
-		{
+		else if (shiftB && ctrlB)
 			setSingleStep((m_unitIndex == SC_INCHES) ? 0.03125 : 0.01);
-			retval = QAbstractSpinBox::event(event);
-		}
 		else
-		{
 			setSingleStep((m_unitIndex == SC_INCHES) ? 0.125 : 1.0);
-			retval = QAbstractSpinBox::event(event);
-		}
-		return retval;
+
+		// Reimplement MouseWheel behavior without CTRL modifier behavior of QAbstractSpinBox
+#ifdef Q_OS_MACOS
+		if ((wheelEvent->modifiers() & Qt::ShiftModifier) && wheelEvent->source() == Qt::MouseEventNotSynthesized)
+			wheelDeltaRemainder += wheelEvent->angleDelta().x();
+		else
+			wheelDeltaRemainder += wheelEvent->angleDelta().y();
+#else
+		wheelDeltaRemainder += wheelEvent->angleDelta().y();
+#endif
+		const int steps = wheelDeltaRemainder / 120;
+		wheelDeltaRemainder -= steps * 120;
+		if (stepEnabled() & (steps > 0 ? StepUpEnabled : StepDownEnabled))
+			stepBy(steps);
+
+		setSingleStep(oldStep);
+
+		return true;
 	}
 
 	if (event->type() == QEvent::LocaleChange)
diff -Naupr scribus-1.6.2/scribus/ui/scrspinbox.h scribus16x/scribus/ui/scrspinbox.h
--- scribus-1.6.2/scribus/ui/scrspinbox.h	2024-06-15 16:22:23.000000000 +0200
+++ scribus16x/scribus/ui/scrspinbox.h	2025-01-04 10:59:08.311335169 +0100
@@ -5,7 +5,7 @@ a copyright and/or license notice that p
 for which a new license (GPL+exception) is in place.
 */
 /***************************************************************************
- *   Craig Bradney, cbradney@zip.com.au                                    *
+ *   Craig Bradney, cbradney@scribus.info                                  *
  ***************************************************************************/
 
 #ifndef SCRSPINBOX
@@ -50,10 +50,12 @@ class SCRIBUS_API ScrSpinBox : public QD
 		void getValues(double *min, double *max, int *deci, double *val) const;
 		void setValue(int val);
 		void setValue(double val);
+		void setValue(double val, int unitIndex);
 		void setValues(double min, double max, int deci, double val);
 	
 	protected:
 		uint m_unitIndex { 0 };
+		int wheelDeltaRemainder { 0 };
 		const QMap<QString, double>* m_constants;
 
 		void setParameters(int s);
diff -Naupr scribus-1.6.2/scribus/ui/search.cpp scribus16x/scribus/ui/search.cpp
--- scribus-1.6.2/scribus/ui/search.cpp	2024-06-15 16:22:23.000000000 +0200
+++ scribus16x/scribus/ui/search.cpp	2025-01-04 10:59:08.315335085 +0100
@@ -150,7 +150,6 @@ SearchReplace::SearchReplace( QWidget* p
 	searchStrokeValue->setEditable(false);
 	searchStrokeValue->setPixmapType(ColorCombo::fancyPixmaps);
 	searchStrokeValue->setColors(doc->PageColors, true);
-	searchStrokeValue->view()->setMinimumWidth(searchStrokeValue->view()->maximumViewportSize().width() + 24);
 	setCurrentComboItem(searchStrokeValue, doc->currentStyle.charStyle().strokeColor());
 	searchStrokeValue->setEnabled(false);
 	SearchLayout->addWidget( searchStrokeValue, 8, 1 );
@@ -236,7 +235,6 @@ SearchReplace::SearchReplace( QWidget* p
 	replaceFillValue->setEditable(false);
 	replaceFillValue->setPixmapType(ColorCombo::fancyPixmaps);
 	replaceFillValue->setColors(doc->PageColors, true);
-	replaceFillValue->view()->setMinimumWidth(replaceFillValue->view()->maximumViewportSize().width() + 24);
 	setCurrentComboItem(replaceFillValue, doc->currentStyle.charStyle().fillColor());
 	replaceFillValue->setEnabled(false);
 	ReplaceLayout->addWidget( replaceFillValue, 6, 1 );
@@ -247,7 +245,6 @@ SearchReplace::SearchReplace( QWidget* p
 	replaceStrokeValue->setEditable(false);
 	replaceStrokeValue->setPixmapType(ColorCombo::fancyPixmaps);
 	replaceStrokeValue->setColors(doc->PageColors, true);
-	replaceStrokeValue->view()->setMinimumWidth(replaceStrokeValue->view()->maximumViewportSize().width() + 24);
 	setCurrentComboItem(replaceStrokeValue, doc->currentStyle.charStyle().strokeColor());
 	replaceStrokeValue->setEnabled(false);
 	ReplaceLayout->addWidget( replaceStrokeValue, 8, 1 );
diff -Naupr scribus-1.6.2/scribus/ui/smcellstylewidget.cpp scribus16x/scribus/ui/smcellstylewidget.cpp
--- scribus-1.6.2/scribus/ui/smcellstylewidget.cpp	2024-06-15 16:22:24.000000000 +0200
+++ scribus16x/scribus/ui/smcellstylewidget.cpp	2025-01-04 10:59:08.315335085 +0100
@@ -173,5 +173,4 @@ void SMCellStyleWidget::fillFillColorCom
 	fillColor->clear();
 
 	fillColor->setColors(colors, true);
-	fillColor->view()->setMinimumWidth(fillColor->view()->maximumViewportSize().width()+24);
 }
diff -Naupr scribus-1.6.2/scribus/ui/smcstylewidget.cpp scribus16x/scribus/ui/smcstylewidget.cpp
--- scribus-1.6.2/scribus/ui/smcstylewidget.cpp	2024-06-15 16:22:24.000000000 +0200
+++ scribus16x/scribus/ui/smcstylewidget.cpp	2025-01-04 10:59:08.315335085 +0100
@@ -167,9 +167,6 @@ void SMCStyleWidget::fillColorCombo(Colo
 	fillColor_->setColors(colors, true);
 	strokeColor_->setColors(colors, true);
 	backColor_->setColors(colors, true);
-	fillColor_->view()->setMinimumWidth(fillColor_->view()->maximumViewportSize().width()+24);
-	strokeColor_->view()->setMinimumWidth(strokeColor_->view()->maximumViewportSize().width()+24);
-	backColor_->view()->setMinimumWidth(backColor_->view()->maximumViewportSize().width()+24);
 }
 
 void SMCStyleWidget::handleUpdateRequest(int updateFlags)
diff -Naupr scribus-1.6.2/scribus/ui/smpstylewidget.cpp scribus16x/scribus/ui/smpstylewidget.cpp
--- scribus-1.6.2/scribus/ui/smpstylewidget.cpp	2024-06-15 16:22:23.000000000 +0200
+++ scribus16x/scribus/ui/smpstylewidget.cpp	2025-01-04 10:59:08.315335085 +0100
@@ -185,7 +185,6 @@ void SMPStyleWidget::fillColorCombo(Colo
 {
 	backColor_->clear();
 	backColor_->setColors(colors, true);
-	backColor_->view()->setMinimumWidth(backColor_->view()->maximumViewportSize().width()+24);
 }
 
 void SMPStyleWidget::fillBulletStrEditCombo()
diff -Naupr scribus-1.6.2/scribus/ui/smtablestylewidget.cpp scribus16x/scribus/ui/smtablestylewidget.cpp
--- scribus-1.6.2/scribus/ui/smtablestylewidget.cpp	2024-06-15 16:22:24.000000000 +0200
+++ scribus16x/scribus/ui/smtablestylewidget.cpp	2025-01-04 10:59:08.315335085 +0100
@@ -170,7 +170,6 @@ void SMTableStyleWidget::fillFillColorCo
 	fillColor->clear();
 
 	fillColor->setColors(colors, true);
-	fillColor->view()->setMinimumWidth(fillColor->view()->maximumViewportSize().width()+24);
 }
 
 
diff -Naupr scribus-1.6.2/scribus/ui/stylemanager.ui scribus16x/scribus/ui/stylemanager.ui
--- scribus-1.6.2/scribus/ui/stylemanager.ui	2024-06-15 16:22:24.000000000 +0200
+++ scribus16x/scribus/ui/stylemanager.ui	2025-01-04 10:59:08.310335190 +0100
@@ -142,6 +142,9 @@
             <property name="shortcut">
              <string>Alt+N</string>
             </property>
+            <property name="autoDefault">
+             <bool>false</bool>
+            </property>
            </widget>
           </item>
           <item row="0" column="1">
@@ -173,6 +176,9 @@
             <property name="shortcut">
              <string>Alt+C</string>
             </property>
+            <property name="autoDefault">
+             <bool>false</bool>
+            </property>
            </widget>
           </item>
           <item row="1" column="0">
@@ -189,6 +195,9 @@
             <property name="shortcut">
              <string>Alt+I</string>
             </property>
+            <property name="autoDefault">
+             <bool>false</bool>
+            </property>
            </widget>
           </item>
           <item row="1" column="1">
@@ -205,6 +214,9 @@
             <property name="shortcut">
              <string>Alt+D</string>
             </property>
+            <property name="autoDefault">
+             <bool>false</bool>
+            </property>
            </widget>
           </item>
          </layout>
@@ -391,6 +403,9 @@
          <property name="shortcut">
           <string>Alt+D</string>
          </property>
+         <property name="autoDefault">
+          <bool>false</bool>
+         </property>
         </widget>
        </item>
        <item>
@@ -413,6 +428,9 @@
          <property name="shortcut">
           <string>Alt+A</string>
          </property>
+         <property name="autoDefault">
+          <bool>false</bool>
+         </property>
         </widget>
        </item>
        <item>
@@ -435,6 +453,9 @@
          <property name="shortcut">
           <string>Alt+R</string>
          </property>
+         <property name="autoDefault">
+          <bool>false</bool>
+         </property>
         </widget>
        </item>
       </layout>
diff -Naupr scribus-1.6.2/scribus/ui/symbolpalette.cpp scribus16x/scribus/ui/symbolpalette.cpp
--- scribus-1.6.2/scribus/ui/symbolpalette.cpp	2024-06-15 16:22:24.000000000 +0200
+++ scribus16x/scribus/ui/symbolpalette.cpp	2025-01-04 10:59:08.314335107 +0100
@@ -296,10 +296,10 @@ void SymbolPalette::updateSymbolList()
 		const QString& patternName = patK.at(i);
 		ScPattern sp = m_doc->docPatterns.value(patternName);
 		QPixmap pm;
-		if (sp.getPattern()->width() >= sp.getPattern()->height())
-			pm = QPixmap::fromImage(sp.getPattern()->scaledToWidth(48, Qt::SmoothTransformation));
+		if (sp.getPattern().width() >= sp.getPattern().height())
+			pm = QPixmap::fromImage(sp.getPattern().scaledToWidth(48, Qt::SmoothTransformation));
 		else
-			pm = QPixmap::fromImage(sp.getPattern()->scaledToHeight(48, Qt::SmoothTransformation));
+			pm = QPixmap::fromImage(sp.getPattern().scaledToHeight(48, Qt::SmoothTransformation));
 		QPixmap pm2(48, 48);
 		pm2.fill(palette().color(QPalette::Base));
 		QPainter p;
diff -Naupr scribus-1.6.2/scribus/ui/transparencypalette.cpp scribus16x/scribus/ui/transparencypalette.cpp
--- scribus-1.6.2/scribus/ui/transparencypalette.cpp	2024-06-15 16:22:23.000000000 +0200
+++ scribus16x/scribus/ui/transparencypalette.cpp	2025-01-04 10:59:08.314335107 +0100
@@ -480,10 +480,10 @@ void TransparencyPalette::updatePatternL
 	{
 		ScPattern sp = patternList->value(patK[a]);
 		QPixmap pm;
-		if (sp.getPattern()->width() >= sp.getPattern()->height())
-			pm = QPixmap::fromImage(sp.getPattern()->scaledToWidth(48, Qt::SmoothTransformation));
+		if (sp.getPattern().width() >= sp.getPattern().height())
+			pm = QPixmap::fromImage(sp.getPattern().scaledToWidth(48, Qt::SmoothTransformation));
 		else
-			pm = QPixmap::fromImage(sp.getPattern()->scaledToHeight(48, Qt::SmoothTransformation));
+			pm = QPixmap::fromImage(sp.getPattern().scaledToHeight(48, Qt::SmoothTransformation));
 		QPixmap pm2(48, 48);
 		pm2.fill(palette().color(QPalette::Base));
 		QPainter p;
diff -Naupr scribus-1.6.2/scribus/undomanager.cpp scribus16x/scribus/undomanager.cpp
--- scribus-1.6.2/scribus/undomanager.cpp	2024-06-15 16:22:32.000000000 +0200
+++ scribus16x/scribus/undomanager.cpp	2025-01-04 10:59:08.782325341 +0100
@@ -612,6 +612,7 @@ void UndoManager::languageChange()
 	UndoManager::ItemsInvolved2     = tr("More than 20 items involved");
 	UndoManager::Cancel             = tr("Cancel");
 	UndoManager::SetFill            = tr("Set fill color");
+	UndoManager::SetFillRule        = tr("Set fill rule");
 	UndoManager::ColorFromTo        = tr("Color1: %1, Color2: %2");
 	UndoManager::SetShade           = tr("Set fill color shade");
 	UndoManager::SetLineColor       = tr("Set line color");
@@ -968,6 +969,7 @@ int     UndoManager::ItemsInvolvedLimit
 QString UndoManager::Cancel             = "";
 QString UndoManager::TextFrameDist      = "";
 QString UndoManager::SetFill            = "";
+QString UndoManager::SetFillRule        = "";
 QString UndoManager::ColorFromTo        = "";
 QString UndoManager::SetShade           = "";
 QString UndoManager::SetLineColor       = "";
diff -Naupr scribus-1.6.2/scribus/undomanager.h scribus16x/scribus/undomanager.h
--- scribus-1.6.2/scribus/undomanager.h	2024-06-15 16:22:32.000000000 +0200
+++ scribus16x/scribus/undomanager.h	2025-01-04 10:59:08.782325341 +0100
@@ -396,6 +396,7 @@ public:
 	static int     ItemsInvolvedLimit;
 	static QString Cancel;
 	static QString SetFill;
+	static QString SetFillRule;
 	static QString ColorFromTo;
 	static QString SetShade;
 	static QString SetLineColor;
diff -Naupr scribus-1.6.2/scribus/util.cpp scribus16x/scribus/util.cpp
--- scribus-1.6.2/scribus/util.cpp	2024-06-15 16:22:33.000000000 +0200
+++ scribus16x/scribus/util.cpp	2025-01-04 10:59:08.679327490 +0100
@@ -123,7 +123,7 @@ int System(const QString& exename, const
 	{
 		while (!proc.waitForFinished(15000))
 		{
-			qApp->processEvents();
+			QApplication::processEvents();
 			if (cancel && (*cancel))
 			{
 				proc.kill();
@@ -136,7 +136,7 @@ int System(const QString& exename, const
 	return proc.exitCode();
 }
 
-// On Windows, return short path name, else return longPath;
+// On Windows, return short path name, else return longPath
 QString getShortPathName(const QString & longPath)
 {
 	QString shortPath(longPath);
@@ -156,7 +156,7 @@ QString getShortPathName(const QString &
 	return shortPath;
 }
 
-// On Windows, return short path name, else return longPath;
+// On Windows, return short path name, else return longPath
 QString getLongPathName(const QString & shortPath)
 {
 	QString longPath(shortPath);
@@ -194,17 +194,6 @@ bool loadText(const QString& filename, Q
 	f.close();
 	for (int i = 0; i < bb.size(); ++i)
 		*buffer += QChar(bb[i]);
-	/*
-		int len = bb.size();
-		int oldLen = Buffer->length();
-		Buffer->setLength( oldLen + len + 1);
-		// digged into Qt 3.3 sources to find that. Might break in Qt 4 -- AV
-		unsigned short * ucsString = const_cast<unsigned short *>(Buffer->ucs2()) + oldLen;
-		char * data = bb.data();
-		for (uint posi = 0; posi < len; ++posi)
-		*ucsString++ = *data++;
-		*ucsString = 0;
-		*/
 	return true;
 }
 
@@ -294,9 +283,9 @@ QString CompressStr(QString *in)
 		}
 		uLong exlen = (uLong)(bb.size() * 0.001 + 16) + bb.size();
 		QByteArray bc(exlen, ' ');
-		if( bc.size() == static_cast<qint32>(exlen) )
+		if (bc.size() == static_cast<qint32>(exlen))
 		{
-			int errcode = compress2((Byte *)bc.data(), &exlen, (Byte *)bb.data(), uLong(bb.size()), 9);
+			int errcode = compress2((Byte*) bc.data(), &exlen, (const Byte*) bb.data(), uLong(bb.size()), 9);
 			if (errcode != Z_OK)
 			{
 				qDebug("compress2 failed with code %i", errcode);
@@ -327,7 +316,7 @@ QByteArray CompressArray(const QByteArra
 	QByteArray out;
 	uLong exlen = uint(in.size() * 0.001 + 16) + in.size();
 	QByteArray temp(exlen, ' ');
-	int errcode = compress2((Byte *)temp.data(), &exlen, (Byte *)in.data(), uLong(in.size()), 9);
+	int errcode = compress2((Byte*) temp.data(), &exlen, (const Byte*) in.data(), uLong(in.size()), 9);
 	if (errcode == Z_OK)
 	{
 		temp.resize(exlen);
@@ -348,7 +337,7 @@ char *toAscii85( quint32 value, bool& al
 		digit = value % 85;
 		if (digit != 0)
 			allZero = false;
-		asciiVal[4-i] = digit + 33;
+		asciiVal[4 - i] = digit + 33;
 		value = (value - digit) / 85;
 	}
 	asciiVal[5] = 0;
@@ -363,9 +352,9 @@ char *toHex( uchar u )
 	{
 		ushort hex = (u & 0x000f);
 		if ( hex < 0x0a )
-			hexVal[i] = '0'+hex;
+			hexVal[i] = '0' + hex;
 		else
-			hexVal[i] = 'A'+(hex-0x0a);
+			hexVal[i] = 'A' + (hex - 0x0a);
 		u = u >> 4;
 		i--;
 	}
@@ -382,7 +371,7 @@ QString String2Hex(QString *in, bool lan
 		// Qt4 .cell() added ???
 		out += toHex(QChar(in->at(j)).cell());
 		++i;
-		if ((i > 40) && (lang))
+		if ((i > 40) && lang)
 		{
 			out += '\n';
 			i=0;
@@ -442,7 +431,7 @@ bool overwrite(QWidget *parent, const QS
 
 void WordAndPara(PageItem* currItem, int *w, int *p, int *c, int *wN, int *pN, int *cN)
 {
-	QChar Dat = QChar(32);
+	QChar Dat(32);
 	int para = 0;
 	int ww = 0;
 	int cc = 0;
@@ -518,7 +507,7 @@ void ReOrderText(ScribusDoc *currentDoc,
 	view->setScale(1.0);
 	currentDoc->RePos = true;
 	QImage pgPix(10, 10, QImage::Format_ARGB32_Premultiplied);
-	QRect rd; // = QRect(0,0,9,9);
+	QRect rd;
 	ScPainter *painter = new ScPainter(&pgPix, pgPix.width(), pgPix.height());
 	for (auto it = currentDoc->MasterItems.begin(); it != currentDoc->MasterItems.end(); ++it)
 	{
@@ -544,7 +533,7 @@ void ReOrderText(ScribusDoc *currentDoc,
 \param s2 second string
 \retval bool t/f related s1>s2
  */
-bool compareQStrings(const QString& s1, const QString& s2)
+static bool compareQStrings(const QString& s1, const QString& s2)
 {
 	return QString::localeAwareCompare(s1, s2) < 0;
 }
@@ -662,7 +651,7 @@ QString numberToLetterSequence(const QSt
 	if (column > 4058115285U)
 		return  QString("@");
 
-	for (unsigned limit = 28; column >= limit+offset; limit *= letters.length(), digits++)
+	for (unsigned limit = 28; column >= limit + offset; limit *= letters.length(), digits++)
 		offset += limit;
 
 	for (unsigned c = column - offset; digits; --digits, c /= letters.length())
@@ -901,7 +890,7 @@ QString readAdobeUniCodeString(QDataStre
 	quint32 len;
 	s >> len;
 
-	quint32 bytesLen = 2 * len;
+	int bytesLen = 2 * len;
 	QByteArray strData(bytesLen, 0);
 	if (strData.size() != bytesLen)
 		return QString();
@@ -1147,9 +1136,9 @@ bool convertOldTable(ScribusDoc *m_Doc,
 	currItem->OwnPage = gItem->OwnPage;
 	currItem->OnMasterPage = gItem->OnMasterPage;
 
-	currItem->insertRows(0, rowHeights.count()-1);
+	currItem->insertRows(0, rowHeights.count() - 1);
 	m_Doc->dontResize = true;
-	currItem->insertColumns(0, colWidths.count()-1);
+	currItem->insertColumns(0, colWidths.count() - 1);
 	m_Doc->dontResize = true;
 	for (int i = 0; i < rowHeights.count(); i++)
 	{
diff -Naupr scribus-1.6.2/scribus/util_color.cpp scribus16x/scribus/util_color.cpp
--- scribus-1.6.2/scribus/util_color.cpp	2024-06-15 16:22:33.000000000 +0200
+++ scribus16x/scribus/util_color.cpp	2025-01-04 10:59:08.677327531 +0100
@@ -143,9 +143,14 @@ QImage ProofImage(QImage *Image, Scribus
 QColor SetColor(ScribusDoc *currentDoc, const QString& color, int shad)
 {
 	if (color == CommonStrings::None)
-		return {0, 0, 0, 0};
-	const ScColor& col = currentDoc->PageColors[color];
-	return ScColorEngine::getShadeColorProof(col, currentDoc, shad);
+		return { 0, 0, 0, 0 };
+	auto colorIt = currentDoc->PageColors.constFind(color);
+	if (colorIt != currentDoc->PageColors.constEnd())
+	{
+		const ScColor& col = colorIt.value();
+		return ScColorEngine::getShadeColorProof(col, currentDoc, shad);
+	}
+	return { 153, 102, 51, 0 }; // The infamous brown color
 }
 
 /**
diff -Naupr scribus-1.6.2/scribus/util_file.cpp scribus16x/scribus/util_file.cpp
--- scribus-1.6.2/scribus/util_file.cpp	2024-06-15 16:22:35.000000000 +0200
+++ scribus16x/scribus/util_file.cpp	2025-01-04 10:59:08.678327511 +0100
@@ -31,6 +31,7 @@ for which a new license (GPL+exception)
 #include "scstreamfilter.h"
 #include "selection.h"
 #include "util.h"
+#include "util_os.h"
 
 bool copyData(QIODevice& src, QIODevice& dest)
 {
@@ -239,9 +240,10 @@ bool fileInPath(const QString& filename)
 	//Get $PATH
 	QString path;
 	const QStringList env = QProcess::systemEnvironment();
+	Qt::CaseSensitivity pathCaseSensitivity = os_is_win() ? Qt::CaseInsensitive : Qt::CaseSensitive;
 	for (const QString& line : env)
 	{
-		if (line.indexOf("PATH") == 0)
+		if (line.startsWith("PATH=", pathCaseSensitivity))
 		{
 			path = line.mid(5); //Strip "PATH="
 			break;
diff -Naupr scribus-1.6.2/scribus/util_keyboard.h scribus16x/scribus/util_keyboard.h
--- scribus-1.6.2/scribus/util_keyboard.h	1970-01-01 01:00:00.000000000 +0100
+++ scribus16x/scribus/util_keyboard.h	2025-01-04 10:59:08.781325361 +0100
@@ -0,0 +1,170 @@
+/*
+For general Scribus (>=1.3.2) copyright and licensing information please refer
+to the COPYING file provided with the program. Following this notice may exist
+a copyright and/or license notice that predates the release of Scribus 1.3.2
+for which a new license (GPL+exception) is in place.
+*/
+#ifndef UTIL_KEYBOARD_H
+#define UTIL_KEYBOARD_H
+
+#include <qnamespace.h>
+
+// These functions are intended to help concatenating Qt::Modifier and Qt::Key enums 
+// into a single integer while avoiding -Wdeprecated-enum-enum-conversion warnings 
+// when compiling in C++20 mode
+
+template<typename T>
+int makeKeySequence(T first)
+{
+	return static_cast<int>(first);
+}
+
+template<typename T, typename... Ts>
+int makeKeySequence(T first, Ts... args)
+{
+	return static_cast<int>(first) + makeKeySequence(args...);
+}
+
+#if __cplusplus >= 202002L
+inline int operator+(int k1, Qt::Key k2)
+{
+	return k1 + static_cast<int>(k2);
+}
+
+inline int operator+(int k1, Qt::KeyboardModifier k2)
+{
+	return k1 + static_cast<int>(k2);
+}
+
+inline int operator+(int k1, Qt::Modifier k2)
+{
+	return k1 + static_cast<int>(k2);
+}
+
+inline int operator+(Qt::Key k1, int k2)
+{
+	return static_cast<int>(k1) + k2;
+}
+
+inline int operator+(Qt::Key k1, Qt::KeyboardModifier k2)
+{
+	return static_cast<int>(k1) + static_cast<int>(k2);
+}
+
+inline int operator+(Qt::Key k1, Qt::Modifier k2)
+{
+	return static_cast<int>(k1) + static_cast<int>(k2);
+}
+
+inline int operator+(Qt::KeyboardModifier k1, int k2)
+{
+	return static_cast<int>(k1) + k2;
+}
+
+inline int operator+(Qt::KeyboardModifier k1, Qt::Key k2)
+{
+	return static_cast<int>(k1) + static_cast<int>(k2);
+}
+
+inline int operator+(Qt::KeyboardModifier k1, Qt::KeyboardModifier k2)
+{
+	return static_cast<int>(k1) + static_cast<int>(k2);
+}
+
+inline int operator+(Qt::KeyboardModifier k1, Qt::Modifier k2)
+{
+	return static_cast<int>(k1) + static_cast<int>(k2);
+}
+
+inline int operator+(Qt::Modifier k1, int k2)
+{
+	return static_cast<int>(k1) + k2;
+}
+
+inline int operator+(Qt::Modifier k1, Qt::Key k2)
+{
+	return static_cast<int>(k1) + static_cast<int>(k2);
+}
+
+inline int operator+(Qt::Modifier k1, Qt::KeyboardModifier k2)
+{
+	return static_cast<int>(k1) + static_cast<int>(k2);
+}
+
+inline int operator+(Qt::Modifier k1, Qt::Modifier k2)
+{
+	return static_cast<int>(k1) + static_cast<int>(k2);
+}
+
+inline int operator|(int k1, Qt::Key k2)
+{
+	return k1 | static_cast<int>(k2);
+}
+
+inline int operator|(int k1, Qt::KeyboardModifier k2)
+{
+	return k1 | static_cast<int>(k2);
+}
+
+inline int operator|(int k1, Qt::Modifier k2)
+{
+	return k1 | static_cast<int>(k2);
+}
+
+inline int operator|(Qt::Key k1, int k2)
+{
+	return static_cast<int>(k1) | k2;
+}
+
+inline int operator|(Qt::Key k1, Qt::KeyboardModifier k2)
+{
+	return static_cast<int>(k1) | static_cast<int>(k2);
+}
+
+inline int operator|(Qt::Key k1, Qt::Modifier k2)
+{
+	return static_cast<int>(k1) | static_cast<int>(k2);
+}
+
+inline int operator|(Qt::KeyboardModifier k1, int k2)
+{
+	return static_cast<int>(k1) | k2;
+}
+
+inline int operator|(Qt::KeyboardModifier k1, Qt::Key k2)
+{
+	return static_cast<int>(k1) | static_cast<int>(k2);
+}
+
+inline int operator|(Qt::KeyboardModifier k1, Qt::KeyboardModifier k2)
+{
+	return static_cast<int>(k1) | static_cast<int>(k2);
+}
+
+inline int operator|(Qt::KeyboardModifier k1, Qt::Modifier k2)
+{
+	return static_cast<int>(k1) | static_cast<int>(k2);
+}
+
+inline int operator|(Qt::Modifier k1, int k2)
+{
+	return static_cast<int>(k1) | k2;
+}
+
+inline int operator|(Qt::Modifier k1, Qt::Key k2)
+{
+	return static_cast<int>(k1) | static_cast<int>(k2);
+}
+
+inline int operator|(Qt::Modifier k1, Qt::KeyboardModifier k2)
+{
+	return static_cast<int>(k1) | static_cast<int>(k2);
+}
+
+inline int operator|(Qt::Modifier k1, Qt::Modifier k2)
+{
+	return static_cast<int>(k1) | static_cast<int>(k2);
+}
+#endif // #if __cplusplus >= 202002L
+
+#endif
diff -Naupr scribus-1.6.2/scribus/vgradient.cpp scribus16x/scribus/vgradient.cpp
--- scribus-1.6.2/scribus/vgradient.cpp	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/scribus/vgradient.cpp	2025-01-04 10:59:08.779325403 +0100
@@ -36,7 +36,7 @@ bool compareStops(const VColorStop* item
 	return (r1 < r2);
 }
 
-int VGradient::compareItems(const VColorStop* item1, const VColorStop* item2 ) const
+int VGradient::compareItems(const VColorStop* item1, const VColorStop* item2) const
 {
 	double r1 = item1->rampPoint;
 	double r2 = item2->rampPoint;
@@ -47,7 +47,7 @@ int VGradient::compareItems(const VColor
 void VGradient::inSort(VColorStop* d)
 {
 	int index = 0;
-	VColorStop *n = m_colorStops.value(index);
+	const VColorStop *n = m_colorStops.value(index);
 	while (n && compareItems(n,d) <= 0)
 	{
 		++index;
@@ -146,11 +146,6 @@ bool VGradient::operator==(const VGradie
 	return retVal;
 }
 
-const QList<VColorStop*>& VGradient::colorStops() const
-{
-	return m_colorStops;
-}
-
 void VGradient::clearStops()
 {
 	while (!m_colorStops.isEmpty())
@@ -201,30 +196,30 @@ void VGradient::removeStop(int n)
 
 void VGradient::filterStops()
 {
-	VColorStop* colorStop = nullptr;
+	const VColorStop* colorStop = nullptr;
 	bool zeroFound = false;
-	QMutableListIterator<VColorStop*> i(m_colorStops);
-	i.toBack();
-	while (i.hasPrevious())
+	QMutableListIterator<VColorStop*> it(m_colorStops);
+	it.toBack();
+	while (it.hasPrevious())
 	{
-		colorStop = i.previous();
+		colorStop = it.previous();
 		if (colorStop->rampPoint == 0.0 && zeroFound)
 		{
-			delete i.value();
-			i.remove();
+			delete it.value();
+			it.remove();
 		}
 		else if (colorStop->rampPoint == 0.0)
 			zeroFound = true;
 	}
 	bool oneFound = false;
-	i.toFront();
-	while (i.hasNext())
+	it.toFront();
+	while (it.hasNext())
 	{
-		colorStop = i.next();
+		colorStop = it.next();
 		if (colorStop->rampPoint == 1.0 && oneFound)
 		{
-			delete i.value();
-			i.remove();
+			delete it.value();
+			it.remove();
 		}
 		else if (colorStop->rampPoint == 1.0)
 			oneFound = true;
@@ -233,9 +228,8 @@ void VGradient::filterStops()
 
 void VGradient::transform( const QTransform &m )
 {
-	double mx, my;
-	mx = m.m11() * m_origin.x() + m.m21() * m_origin.y() + m.dx();
-	my = m.m22() * m_origin.y() + m.m12() * m_origin.x() + m.dy();
+	double mx = m.m11() * m_origin.x() + m.m21() * m_origin.y() + m.dx();
+	double my = m.m22() * m_origin.y() + m.m12() * m_origin.x() + m.dy();
 	m_origin = FPoint(mx, my);
 	mx = m.m11() * m_focalPoint.x() + m.m21() * m_focalPoint.y() + m.dx();
 	my = m.m22() * m_focalPoint.y() + m.m12() * m_focalPoint.x() + m.dy();
diff -Naupr scribus-1.6.2/scribus/vgradient.h scribus16x/scribus/vgradient.h
--- scribus-1.6.2/scribus/vgradient.h	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/scribus/vgradient.h	2025-01-04 10:59:08.779325403 +0100
@@ -113,13 +113,14 @@ public:
 	VGradientRepeatMethod repeatMethod() const { return m_repeatMethod; }
 	void setRepeatMethod(VGradientRepeatMethod repeatMethod) { m_repeatMethod = repeatMethod; }
 
-	const QList<VColorStop*>& colorStops() const;
+	const QList<VColorStop*>& colorStops() const { return m_colorStops; }
 	void addStop(const VColorStop& colorStop);
 	void addStop(const QColor &color, double rampPoint, double midPoint, double opa, const QString& name = QString(), int shade = 100);
 	void setStop(const QColor &color, double rampPoint, double midPoint, double opa, const QString& name = QString(), int shade = 100);
 	void removeStop(VColorStop& colorStop);
 	void removeStop(int n);
 	void clearStops();
+	bool isEmpty() const { return m_colorStops.isEmpty(); }
 	int  stops() const { return m_colorStops.count(); }
 
 	// This function let only one stop with offset value equal to 0 and 1.0
diff -Naupr scribus-1.6.2/scribus/vgradientex.cpp scribus16x/scribus/vgradientex.cpp
--- scribus-1.6.2/scribus/vgradientex.cpp	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/scribus/vgradientex.cpp	2025-01-04 10:59:08.779325403 +0100
@@ -48,7 +48,7 @@ int VGradientEx::compareItems(const VCol
 void VGradientEx::inSort(VColorStopEx* d)
 {
 	int index = 0;
-	VColorStopEx *n = m_colorStops.value(index);
+	const VColorStopEx *n = m_colorStops.value(index);
 	while (n && compareItems(n,d) <= 0)
 	{
 		n = m_colorStops.value(index);
@@ -135,11 +135,6 @@ VGradientEx::~VGradientEx()
 	clearStops();
 }
 
-const QList<VColorStopEx*>& VGradientEx::colorStops() const
-{
-	return m_colorStops;
-}
-
 void VGradientEx::clearStops()
 {
 	while (!m_colorStops.isEmpty())
diff -Naupr scribus-1.6.2/scribus/vgradientex.h scribus16x/scribus/vgradientex.h
--- scribus-1.6.2/scribus/vgradientex.h	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/scribus/vgradientex.h	2025-01-04 10:59:08.779325403 +0100
@@ -39,7 +39,7 @@ class VGradient;
 class SCRIBUS_API VColorStopEx
 {
 public:
-	VColorStopEx(double r, double m, ScColor c, double o, QString n, int s)
+	VColorStopEx(double r, double m, const ScColor& c, double o, QString n, int s)
 	{
 		rampPoint = r;
 		midPoint = m; 
@@ -116,12 +116,13 @@ public:
 	VGradientEx::RepeatMethod repeatMethod() const { return m_repeatMethod; }
 	void setRepeatMethod(VGradientEx::RepeatMethod repeatMethod) { m_repeatMethod = repeatMethod; }
 
-	const QList<VColorStopEx*>& colorStops() const;
+	const QList<VColorStopEx*>& colorStops() const { return m_colorStops; }
 	void addStop(const VColorStopEx& colorStop);
 	void addStop(const ScColor &color, double rampPoint, double midPoint, double opa, const QString& name = QString(), int shade = 100);
 	void removeStop(VColorStopEx& colorStop);
 	void removeStop(int n);
 	void clearStops();
+	bool isEmpty() const { return m_colorStops.isEmpty(); }
 	int stops() const { return m_colorStops.count(); }
 
 	FPoint origin() const { return m_origin; }
diff -Naupr scribus-1.6.2/scribus.appdata.xml.in scribus16x/scribus.appdata.xml.in
--- scribus-1.6.2/scribus.appdata.xml.in	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/scribus.appdata.xml.in	2025-01-04 10:59:17.698139339 +0100
@@ -33,6 +33,7 @@ separations.</p>
   <update_contact>scribus-dev@lists.scribus.net</update_contact>
   <content_rating type="oars-1.0"/>
   <releases>
+    <release version="1.6.2" date="2024-06-15" type="stable"/>
     <release version="1.6.1" date="2024-01-07" type="stable"/>
     <release version="1.6.0" date="2024-01-01" type="stable"/>
     <release version="1.5.8" date="2022-01-23" type="development"/>
diff -Naupr scribus-1.6.2/scribus.lsm scribus16x/scribus.lsm
--- scribus-1.6.2/scribus.lsm	2024-06-15 16:22:37.000000000 +0200
+++ scribus16x/scribus.lsm	2025-01-04 10:59:17.698139339 +0100
@@ -1,6 +1,6 @@
 Begin
 Title:           Scribus 
-Version:         1.6.2
+Version:         1.6.3.svn
 Entered-date:    2003-10-01
 Description:     Scribus is a Page Layout Program for Linux published under the GNU GPL. 
 Keywords:        desktop publishing, page layout, PDF, text processing, graphics, postscript, SVG, EPS 
diff -Naupr scribus-1.6.2/win32/msvc2015/Scribus-build-props.props scribus16x/win32/msvc2015/Scribus-build-props.props
diff -Naupr scribus-1.6.2/win32/msvc2015/scribus-main/Scribus.rc scribus16x/win32/msvc2015/scribus-main/Scribus.rc
diff -Naupr scribus-1.6.2/win32/msvc2015/scribus-main/Scribus.vcxproj scribus16x/win32/msvc2015/scribus-main/Scribus.vcxproj
diff -Naupr scribus-1.6.2/win32/msvc2015/scribus-main/Scribus.vcxproj.filters scribus16x/win32/msvc2015/scribus-main/Scribus.vcxproj.filters
diff -Naupr scribus-1.6.2/win32/msvc2015/win-config.h scribus16x/win32/msvc2015/win-config.h
diff -Naupr scribus-1.6.2/win32/msvc2017/Scribus-build-props.props scribus16x/win32/msvc2017/Scribus-build-props.props
diff -Naupr scribus-1.6.2/win32/msvc2017/scribus-main/Scribus.rc scribus16x/win32/msvc2017/scribus-main/Scribus.rc
diff -Naupr scribus-1.6.2/win32/msvc2017/scribus-main/Scribus.vcxproj scribus16x/win32/msvc2017/scribus-main/Scribus.vcxproj
diff -Naupr scribus-1.6.2/win32/msvc2017/scribus-main/Scribus.vcxproj.filters scribus16x/win32/msvc2017/scribus-main/Scribus.vcxproj.filters
diff -Naupr scribus-1.6.2/win32/msvc2017/win-config.h scribus16x/win32/msvc2017/win-config.h
diff -Naupr scribus-1.6.2/win32/msvc2019/Scribus-build-props.props scribus16x/win32/msvc2019/Scribus-build-props.props
diff -Naupr scribus-1.6.2/win32/msvc2019/scribus-main/Scribus.rc scribus16x/win32/msvc2019/scribus-main/Scribus.rc
diff -Naupr scribus-1.6.2/win32/msvc2019/scribus-main/Scribus.vcxproj scribus16x/win32/msvc2019/scribus-main/Scribus.vcxproj
diff -Naupr scribus-1.6.2/win32/msvc2019/scribus-main/Scribus.vcxproj.filters scribus16x/win32/msvc2019/scribus-main/Scribus.vcxproj.filters
diff -Naupr scribus-1.6.2/win32/msvc2019/win-config.h scribus16x/win32/msvc2019/win-config.h
diff -Naupr scribus-1.6.2/win32/msvc2022/Scribus-build-props.props scribus16x/win32/msvc2022/Scribus-build-props.props
diff -Naupr scribus-1.6.2/win32/msvc2022/scribus-main/Scribus.rc scribus16x/win32/msvc2022/scribus-main/Scribus.rc
diff -Naupr scribus-1.6.2/win32/msvc2022/scribus-main/Scribus.vcxproj scribus16x/win32/msvc2022/scribus-main/Scribus.vcxproj
diff -Naupr scribus-1.6.2/win32/msvc2022/scribus-main/Scribus.vcxproj.filters scribus16x/win32/msvc2022/scribus-main/Scribus.vcxproj.filters
diff -Naupr scribus-1.6.2/win32/msvc2022/win-config.h scribus16x/win32/msvc2022/win-config.h
